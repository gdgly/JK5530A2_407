; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\sysflag.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\sysflag.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\sysflag.crf --no_multibyte_chars ..\APP\sysflag.c]
                          THUMB

                          AREA ||i.Read_Data_Parse||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_f
                          REQUIRE _printf_fp_dec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Read_Data_Parse PROC
;;;513    
;;;514    char *Read_Data_Parse(vu8 v_f){
000000  b571              PUSH     {r0,r4-r6,lr}
000002  ed2d8b04          VPUSH    {d8-d9}
000006  b089              SUB      sp,sp,#0x24
;;;515    	
;;;516    	char return_char[10], dTemp_Char[10], iTemp_Char[10];
;;;517    	
;;;518    	int  dot_loc = 1024, i = 0 ; 
000008  f44f6480          MOV      r4,#0x400
00000c  2500              MOVS     r5,#0
;;;519    
;;;520    	double dTemp;
;;;521    	
;;;522    	memset( return_char, '\0', sizeof(return_char));
00000e  2000              MOVS     r0,#0
000010  9006              STR      r0,[sp,#0x18]
000012  9007              STR      r0,[sp,#0x1c]
000014  9008              STR      r0,[sp,#0x20]
;;;523    	
;;;524    	memset( dTemp_Char, '\0', sizeof(dTemp_Char));
000016  9003              STR      r0,[sp,#0xc]
000018  9004              STR      r0,[sp,#0x10]
00001a  9005              STR      r0,[sp,#0x14]
;;;525    	
;;;526    	memset( iTemp_Char, '\0', sizeof(iTemp_Char));
00001c  9000              STR      r0,[sp,#0]
00001e  9001              STR      r0,[sp,#4]
000020  9002              STR      r0,[sp,#8]
;;;527    	
;;;528    	switch( FLAG_WIN ){
000022  48fe              LDR      r0,|L1.1052|
000024  7800              LDRB     r0,[r0,#0]  ; FLAG_WIN
000026  2807              CMP      r0,#7
000028  d26d              BCS      |L1.262|
00002a  e8dff000          TBB      [pc,r0]
00002e  046d              DCB      0x04,0x6d
000030  fdfcfbfa          DCB      0xfd,0xfc,0xfb,0xfa
000034  f900              DCB      0xf9,0x00
;;;529    		
;;;530    		case 0:{
;;;531    			
;;;532    			switch( v_f ){
000036  f89d0034          LDRB     r0,[sp,#0x34]
00003a  2801              CMP      r0,#1
00003c  d002              BEQ      |L1.68|
00003e  2802              CMP      r0,#2
000040  d160              BNE      |L1.260|
000042  e02f              B        |L1.164|
                  |L1.68|
;;;533    				//====================================输出电压======================================
;;;534    				case 1:   
;;;535    				
;;;536    					dTemp = (double)CLists.POWER_OutPut_V / 1000;
000044  49f6              LDR      r1,|L1.1056|
000046  f8b100de          LDRH     r0,[r1,#0xde]  ; CLists
00004a  f7fffffe          BL       __aeabi_ui2d
00004e  ec410b19          VMOV     d9,r0,r1
000052  ed9f0bf4          VLDR     d0,|L1.1060|
000056  ec532b10          VMOV     r2,r3,d0
00005a  f7fffffe          BL       __aeabi_ddiv
00005e  ec410b18          VMOV     d8,r0,r1
;;;537    					
;;;538    					sprintf( iTemp_Char, "%f", dTemp );
000062  ec532b18          VMOV     r2,r3,d8
000066  a1f1              ADR      r1,|L1.1068|
000068  4668              MOV      r0,sp
00006a  f7fffffe          BL       __2sprintf
;;;539    					
;;;540    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
00006e  2206              MOVS     r2,#6
000070  4669              MOV      r1,sp
000072  a803              ADD      r0,sp,#0xc
000074  f7fffffe          BL       strncpy
;;;541    
;;;542    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
000078  a803              ADD      r0,sp,#0xc
00007a  f7fffffe          BL       strlen
00007e  4606              MOV      r6,r0
000080  4631              MOV      r1,r6
000082  a803              ADD      r0,sp,#0xc
000084  f7fffffe          BL       dot_Loc_isNull
000088  4604              MOV      r4,r0
;;;543    					
;;;544    					if( dot_loc == 1024 ){
00008a  f5b46f80          CMP      r4,#0x400
00008e  d008              BEQ      |L1.162|
;;;545    										
;;;546    					}else{
;;;547    						
;;;548    						if( dot_loc < 2 ){		
000090  2c02              CMP      r4,#2
000092  da06              BGE      |L1.162|
;;;549    							
;;;550    							if( dTemp_Char[5] == '0' ){								
000094  f89d0011          LDRB     r0,[sp,#0x11]
000098  2830              CMP      r0,#0x30
00009a  d102              BNE      |L1.162|
;;;551    								
;;;552    								 dTemp_Char[5] = '\0';								
00009c  2000              MOVS     r0,#0
00009e  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.162|
;;;553    							}	 					
;;;554    						}	
;;;555    					}
;;;556    					
;;;557    				break;
0000a2  e02f              B        |L1.260|
                  |L1.164|
;;;558    				//====================================限制电流======================================
;;;559    				case 2:
;;;560    				
;;;561    					dTemp = (double)CLists.POWER_Limit_C / 1000;
0000a4  49de              LDR      r1,|L1.1056|
0000a6  f8b100e0          LDRH     r0,[r1,#0xe0]  ; CLists
0000aa  f7fffffe          BL       __aeabi_ui2d
0000ae  ec410b19          VMOV     d9,r0,r1
0000b2  ed9f0bdc          VLDR     d0,|L1.1060|
0000b6  ec532b10          VMOV     r2,r3,d0
0000ba  f7fffffe          BL       __aeabi_ddiv
0000be  ec410b18          VMOV     d8,r0,r1
;;;562    					
;;;563    					sprintf( iTemp_Char, "%f", dTemp );
0000c2  ec532b18          VMOV     r2,r3,d8
0000c6  a1d9              ADR      r1,|L1.1068|
0000c8  4668              MOV      r0,sp
0000ca  f7fffffe          BL       __2sprintf
;;;564    					
;;;565    					strncpy( dTemp_Char, iTemp_Char, 6  );  					//先截取五位
0000ce  2206              MOVS     r2,#6
0000d0  4669              MOV      r1,sp
0000d2  a803              ADD      r0,sp,#0xc
0000d4  f7fffffe          BL       strncpy
;;;566    
;;;567    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
0000d8  a803              ADD      r0,sp,#0xc
0000da  f7fffffe          BL       strlen
0000de  4606              MOV      r6,r0
0000e0  4631              MOV      r1,r6
0000e2  a803              ADD      r0,sp,#0xc
0000e4  f7fffffe          BL       dot_Loc_isNull
0000e8  4604              MOV      r4,r0
;;;568    					
;;;569    					if( dot_loc == 1024 ){
0000ea  f5b46f80          CMP      r4,#0x400
0000ee  d008              BEQ      |L1.258|
;;;570    						
;;;571    					}else{
;;;572    						
;;;573    						if( dot_loc < 2 ){		
0000f0  2c02              CMP      r4,#2
0000f2  da06              BGE      |L1.258|
;;;574    								
;;;575    							if( dTemp_Char[5] == '0' ){								
0000f4  f89d0011          LDRB     r0,[sp,#0x11]
0000f8  2830              CMP      r0,#0x30
0000fa  d102              BNE      |L1.258|
;;;576    								
;;;577    								 dTemp_Char[5] = '\0';								
0000fc  2000              MOVS     r0,#0
0000fe  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.258|
;;;578    							}	 						
;;;579    						}	
;;;580    					}
;;;581    					
;;;582    				break;
000102  bf00              NOP      
                  |L1.260|
000104  bf00              NOP                            ;557
                  |L1.262|
;;;583    			}
;;;584    		
;;;585    		}
;;;586    			
;;;587    		break;
000106  e281              B        |L1.1548|
;;;588    		
;;;589    		case 1:{
;;;590    			
;;;591    			switch( v_f ){
000108  f89d0034          LDRB     r0,[sp,#0x34]
00010c  2801              CMP      r0,#1
00010e  d006              BEQ      |L1.286|
000110  2802              CMP      r0,#2
000112  d034              BEQ      |L1.382|
000114  2803              CMP      r0,#3
000116  d062              BEQ      |L1.478|
000118  2804              CMP      r0,#4
00011a  d12f              BNE      |L1.380|
00011c  e095              B        |L1.586|
                  |L1.286|
;;;592    				//====================================起始电流======================================
;;;593    				case 1:   
;;;594    				
;;;595    					dTemp = (double)CLists.IR_Start_C / 1000;
00011e  49c0              LDR      r1,|L1.1056|
000120  f8b100d4          LDRH     r0,[r1,#0xd4]  ; CLists
000124  f7fffffe          BL       __aeabi_ui2d
000128  ec410b19          VMOV     d9,r0,r1
00012c  ed9f0bbd          VLDR     d0,|L1.1060|
000130  ec532b10          VMOV     r2,r3,d0
000134  f7fffffe          BL       __aeabi_ddiv
000138  ec410b18          VMOV     d8,r0,r1
;;;596    					
;;;597    					sprintf( iTemp_Char, "%f", dTemp );
00013c  ec532b18          VMOV     r2,r3,d8
000140  a1ba              ADR      r1,|L1.1068|
000142  4668              MOV      r0,sp
000144  f7fffffe          BL       __2sprintf
;;;598    					
;;;599    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
000148  2206              MOVS     r2,#6
00014a  4669              MOV      r1,sp
00014c  a803              ADD      r0,sp,#0xc
00014e  f7fffffe          BL       strncpy
;;;600    
;;;601    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
000152  a803              ADD      r0,sp,#0xc
000154  f7fffffe          BL       strlen
000158  4606              MOV      r6,r0
00015a  4631              MOV      r1,r6
00015c  a803              ADD      r0,sp,#0xc
00015e  f7fffffe          BL       dot_Loc_isNull
000162  4604              MOV      r4,r0
;;;602    					
;;;603    					if( dot_loc == 1024 ){
000164  f5b46f80          CMP      r4,#0x400
000168  d008              BEQ      |L1.380|
;;;604    								
;;;605    					}else{
;;;606    						
;;;607    						if( dot_loc < 2 ){		
00016a  2c02              CMP      r4,#2
00016c  da06              BGE      |L1.380|
;;;608    							
;;;609    							if( dTemp_Char[5] == '0' ){								
00016e  f89d0011          LDRB     r0,[sp,#0x11]
000172  2830              CMP      r0,#0x30
000174  d102              BNE      |L1.380|
;;;610    								
;;;611    								 dTemp_Char[5] = '\0';								
000176  2000              MOVS     r0,#0
000178  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.380|
;;;612    							}							
;;;613    						}	
;;;614    					}
;;;615    					
;;;616    				break;
00017c  e08d              B        |L1.666|
                  |L1.382|
;;;617    				//====================================步进电流======================================
;;;618    				case 2:
;;;619    				
;;;620    					dTemp = (double)CLists.IR_Step_C / 1000;
00017e  49a8              LDR      r1,|L1.1056|
000180  f8b100d6          LDRH     r0,[r1,#0xd6]  ; CLists
000184  f7fffffe          BL       __aeabi_ui2d
000188  ec410b19          VMOV     d9,r0,r1
00018c  ed9f0ba5          VLDR     d0,|L1.1060|
000190  ec532b10          VMOV     r2,r3,d0
000194  f7fffffe          BL       __aeabi_ddiv
000198  ec410b18          VMOV     d8,r0,r1
;;;621    					
;;;622    					sprintf( iTemp_Char, "%f", dTemp );
00019c  ec532b18          VMOV     r2,r3,d8
0001a0  a1a2              ADR      r1,|L1.1068|
0001a2  4668              MOV      r0,sp
0001a4  f7fffffe          BL       __2sprintf
;;;623    					
;;;624    					strncpy( dTemp_Char, iTemp_Char, 6 );  					//先截取五位
0001a8  2206              MOVS     r2,#6
0001aa  4669              MOV      r1,sp
0001ac  a803              ADD      r0,sp,#0xc
0001ae  f7fffffe          BL       strncpy
;;;625    
;;;626    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
0001b2  a803              ADD      r0,sp,#0xc
0001b4  f7fffffe          BL       strlen
0001b8  4606              MOV      r6,r0
0001ba  4631              MOV      r1,r6
0001bc  a803              ADD      r0,sp,#0xc
0001be  f7fffffe          BL       dot_Loc_isNull
0001c2  4604              MOV      r4,r0
;;;627    					
;;;628    					if( dot_loc == 1024 ){
0001c4  f5b46f80          CMP      r4,#0x400
0001c8  d008              BEQ      |L1.476|
;;;629    						
;;;630    					}else{
;;;631    						
;;;632    						if( dot_loc < 2 ){		
0001ca  2c02              CMP      r4,#2
0001cc  da06              BGE      |L1.476|
;;;633    								
;;;634    							if( dTemp_Char[5] == '0'  ){								
0001ce  f89d0011          LDRB     r0,[sp,#0x11]
0001d2  2830              CMP      r0,#0x30
0001d4  d102              BNE      |L1.476|
;;;635    								
;;;636    								dTemp_Char[5] = '\0';								
0001d6  2000              MOVS     r0,#0
0001d8  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.476|
;;;637    							}							
;;;638    						}	
;;;639    					}
;;;640    					
;;;641    				break;
0001dc  e05d              B        |L1.666|
                  |L1.478|
;;;642    				//====================================门槛电压======================================
;;;643    				case 3:
;;;644    				
;;;645    					dTemp =  (double)CLists.IR_Threshold_V / 1000 ;
0001de  4990              LDR      r1,|L1.1056|
0001e0  f8d100d8          LDR      r0,[r1,#0xd8]  ; CLists
0001e4  f7fffffe          BL       __aeabi_ui2d
0001e8  ec410b19          VMOV     d9,r0,r1
0001ec  ed9f0b8d          VLDR     d0,|L1.1060|
0001f0  ec532b10          VMOV     r2,r3,d0
0001f4  f7fffffe          BL       __aeabi_ddiv
0001f8  ec410b18          VMOV     d8,r0,r1
;;;646    					
;;;647    					sprintf( iTemp_Char, "%f", dTemp );
0001fc  ec532b18          VMOV     r2,r3,d8
000200  a18a              ADR      r1,|L1.1068|
000202  4668              MOV      r0,sp
000204  f7fffffe          BL       __2sprintf
;;;648    					
;;;649    					strncpy( dTemp_Char, iTemp_Char, 6  );  					//先截取五位
000208  2206              MOVS     r2,#6
00020a  4669              MOV      r1,sp
00020c  a803              ADD      r0,sp,#0xc
00020e  f7fffffe          BL       strncpy
;;;650    
;;;651    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
000212  a803              ADD      r0,sp,#0xc
000214  f7fffffe          BL       strlen
000218  4606              MOV      r6,r0
00021a  4631              MOV      r1,r6
00021c  a803              ADD      r0,sp,#0xc
00021e  e004              B        |L1.554|
000220  e309              B        |L1.2102|
000222  e1f5              B        |L1.1552|
000224  e1f3              B        |L1.1550|
000226  e0a3              B        |L1.880|
000228  e039              B        |L1.670|
                  |L1.554|
00022a  f7fffffe          BL       dot_Loc_isNull
00022e  4604              MOV      r4,r0
;;;652    					
;;;653    					if( dot_loc == 1024 ){
000230  f5b46f80          CMP      r4,#0x400
000234  d008              BEQ      |L1.584|
;;;654    						
;;;655    					}else{
;;;656    						
;;;657    						if( dot_loc < 2 ){		
000236  2c02              CMP      r4,#2
000238  da06              BGE      |L1.584|
;;;658    								
;;;659    							if( dTemp_Char[5] == '0'  ){								
00023a  f89d0011          LDRB     r0,[sp,#0x11]
00023e  2830              CMP      r0,#0x30
000240  d102              BNE      |L1.584|
;;;660    								
;;;661    								dTemp_Char[5] = '\0';						
000242  2000              MOVS     r0,#0
000244  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.584|
;;;662    							}							
;;;663    						}	
;;;664    					}
;;;665    					
;;;666    				break;
000248  e027              B        |L1.666|
                  |L1.586|
;;;667    				//====================================步进时间======================================
;;;668    				case 4:			
;;;669    					
;;;670    					sprintf( iTemp_Char, "%d", CLists.IR_Step_Time );
00024a  4875              LDR      r0,|L1.1056|
00024c  f89020dc          LDRB     r2,[r0,#0xdc]  ; CLists
000250  a177              ADR      r1,|L1.1072|
000252  4668              MOV      r0,sp
000254  f7fffffe          BL       __2sprintf
;;;671    					
;;;672    					if( strlen(iTemp_Char) == 1 && iTemp_Char[0] == '0' ){
000258  4668              MOV      r0,sp
00025a  f7fffffe          BL       strlen
00025e  2801              CMP      r0,#1
000260  d108              BNE      |L1.628|
000262  f89d0000          LDRB     r0,[sp,#0]
000266  2830              CMP      r0,#0x30
000268  d104              BNE      |L1.628|
;;;673    						
;;;674    						strcpy( dTemp_Char, "0000" );
00026a  a172              ADR      r1,|L1.1076|
00026c  a803              ADD      r0,sp,#0xc
00026e  f7fffffe          BL       strcpy
;;;675    						
;;;676    						break;			
000272  e012              B        |L1.666|
                  |L1.628|
;;;677    					}	
;;;678    					for( i = 0; i < 4 - strlen(iTemp_Char); i++ ){
000274  2500              MOVS     r5,#0
000276  e004              B        |L1.642|
                  |L1.632|
;;;679    						
;;;680    						strcat( dTemp_Char, "0");	
000278  a170              ADR      r1,|L1.1084|
00027a  a803              ADD      r0,sp,#0xc
00027c  f7fffffe          BL       strcat
000280  1c6d              ADDS     r5,r5,#1              ;678
                  |L1.642|
000282  4668              MOV      r0,sp                 ;678
000284  f7fffffe          BL       strlen
000288  f1c00004          RSB      r0,r0,#4              ;678
00028c  42a8              CMP      r0,r5                 ;678
00028e  d8f3              BHI      |L1.632|
;;;681    						
;;;682    					}			
;;;683    					strcat( dTemp_Char, iTemp_Char ); 
000290  4669              MOV      r1,sp
000292  a803              ADD      r0,sp,#0xc
000294  f7fffffe          BL       strcat
;;;684    				
;;;685    				break;	
000298  bf00              NOP      
                  |L1.666|
00029a  bf00              NOP                            ;616
;;;686    			}	
;;;687    		
;;;688    		}
;;;689    		
;;;690    		break;
00029c  e33f              B        |L1.2334|
                  |L1.670|
;;;691    		
;;;692    		case 2:{
;;;693    			
;;;694    			switch( v_f ){
00029e  f89d0034          LDRB     r0,[sp,#0x34]
0002a2  2801              CMP      r0,#1
0002a4  d002              BEQ      |L1.684|
0002a6  2802              CMP      r0,#2
0002a8  d160              BNE      |L1.876|
0002aa  e02f              B        |L1.780|
                  |L1.684|
;;;695    				//====================================负载电流======================================
;;;696    				case 1:   
;;;697    				
;;;698    					dTemp = (double)CLists.LOAD_C / 1000;
0002ac  495c              LDR      r1,|L1.1056|
0002ae  f8b100e2          LDRH     r0,[r1,#0xe2]  ; CLists
0002b2  f7fffffe          BL       __aeabi_ui2d
0002b6  ec410b19          VMOV     d9,r0,r1
0002ba  ed9f0b5a          VLDR     d0,|L1.1060|
0002be  ec532b10          VMOV     r2,r3,d0
0002c2  f7fffffe          BL       __aeabi_ddiv
0002c6  ec410b18          VMOV     d8,r0,r1
;;;699    					
;;;700    					sprintf( iTemp_Char, "%f", dTemp );
0002ca  ec532b18          VMOV     r2,r3,d8
0002ce  a157              ADR      r1,|L1.1068|
0002d0  4668              MOV      r0,sp
0002d2  f7fffffe          BL       __2sprintf
;;;701    					
;;;702    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
0002d6  2206              MOVS     r2,#6
0002d8  4669              MOV      r1,sp
0002da  a803              ADD      r0,sp,#0xc
0002dc  f7fffffe          BL       strncpy
;;;703    
;;;704    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
0002e0  a803              ADD      r0,sp,#0xc
0002e2  f7fffffe          BL       strlen
0002e6  4606              MOV      r6,r0
0002e8  4631              MOV      r1,r6
0002ea  a803              ADD      r0,sp,#0xc
0002ec  f7fffffe          BL       dot_Loc_isNull
0002f0  4604              MOV      r4,r0
;;;705    					
;;;706    					if( dot_loc == 1024 ){
0002f2  f5b46f80          CMP      r4,#0x400
0002f6  d008              BEQ      |L1.778|
;;;707    									
;;;708    					}else{
;;;709    						
;;;710    						if( dot_loc < 2 ){		
0002f8  2c02              CMP      r4,#2
0002fa  da06              BGE      |L1.778|
;;;711    							
;;;712    							if( dTemp_Char[5] == '0' ){								
0002fc  f89d0011          LDRB     r0,[sp,#0x11]
000300  2830              CMP      r0,#0x30
000302  d102              BNE      |L1.778|
;;;713    								
;;;714    								 dTemp_Char[5] = '\0';								
000304  2000              MOVS     r0,#0
000306  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.778|
;;;715    							}							
;;;716    						}	
;;;717    					}
;;;718    					
;;;719    				break;
00030a  e02f              B        |L1.876|
                  |L1.780|
;;;720    				
;;;721    				//====================================负载电流======================================
;;;722    				case 2:   
;;;723    				
;;;724    					dTemp = (double)CLists.LOAD_V / 1000;
00030c  4944              LDR      r1,|L1.1056|
00030e  f8b100e4          LDRH     r0,[r1,#0xe4]  ; CLists
000312  f7fffffe          BL       __aeabi_ui2d
000316  ec410b19          VMOV     d9,r0,r1
00031a  ed9f0b42          VLDR     d0,|L1.1060|
00031e  ec532b10          VMOV     r2,r3,d0
000322  f7fffffe          BL       __aeabi_ddiv
000326  ec410b18          VMOV     d8,r0,r1
;;;725    					
;;;726    					sprintf( iTemp_Char, "%f", dTemp );
00032a  ec532b18          VMOV     r2,r3,d8
00032e  a13f              ADR      r1,|L1.1068|
000330  4668              MOV      r0,sp
000332  f7fffffe          BL       __2sprintf
;;;727    					
;;;728    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
000336  2206              MOVS     r2,#6
000338  4669              MOV      r1,sp
00033a  a803              ADD      r0,sp,#0xc
00033c  f7fffffe          BL       strncpy
;;;729    
;;;730    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
000340  a803              ADD      r0,sp,#0xc
000342  f7fffffe          BL       strlen
000346  4606              MOV      r6,r0
000348  4631              MOV      r1,r6
00034a  a803              ADD      r0,sp,#0xc
00034c  f7fffffe          BL       dot_Loc_isNull
000350  4604              MOV      r4,r0
;;;731    					
;;;732    					if( dot_loc == 1024 ){
000352  f5b46f80          CMP      r4,#0x400
000356  d008              BEQ      |L1.874|
;;;733    									
;;;734    					}else{
;;;735    						
;;;736    						if( dot_loc < 2 ){		
000358  2c02              CMP      r4,#2
00035a  da06              BGE      |L1.874|
;;;737    							
;;;738    							if( dTemp_Char[5] == '0' ){								
00035c  f89d0011          LDRB     r0,[sp,#0x11]
000360  2830              CMP      r0,#0x30
000362  d102              BNE      |L1.874|
;;;739    								
;;;740    								 dTemp_Char[5] = '\0';								
000364  2000              MOVS     r0,#0
000366  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.874|
;;;741    							}							
;;;742    						}	
;;;743    					}
;;;744    					
;;;745    				break;
00036a  bf00              NOP      
                  |L1.876|
00036c  bf00              NOP                            ;719
;;;746    			}	
;;;747    		}
;;;748    		
;;;749    		break;
00036e  e2d6              B        |L1.2334|
                  |L1.880|
;;;750    		
;;;751    		case 3:{
;;;752    			
;;;753    			switch( v_f ){
000370  f89d0034          LDRB     r0,[sp,#0x34]
000374  2808              CMP      r0,#8
000376  d234              BCS      |L1.994|
000378  e8dff000          TBB      [pc,r0]
00037c  33043477          DCB      0x33,0x04,0x34,0x77
000380  a8d9fcfb          DCB      0xa8,0xd9,0xfc,0xfb
;;;754    				//====================================输出电压======================================
;;;755    				case 1:   
;;;756    				
;;;757    					dTemp = (double)CLists.CDC_OutPut_V / 1000;
000384  4926              LDR      r1,|L1.1056|
000386  f8b100e6          LDRH     r0,[r1,#0xe6]  ; CLists
00038a  f7fffffe          BL       __aeabi_ui2d
00038e  ec410b19          VMOV     d9,r0,r1
000392  ed9f0b24          VLDR     d0,|L1.1060|
000396  ec532b10          VMOV     r2,r3,d0
00039a  f7fffffe          BL       __aeabi_ddiv
00039e  ec410b18          VMOV     d8,r0,r1
;;;758    					
;;;759    					sprintf( iTemp_Char, "%f", dTemp );
0003a2  ec532b18          VMOV     r2,r3,d8
0003a6  a121              ADR      r1,|L1.1068|
0003a8  4668              MOV      r0,sp
0003aa  f7fffffe          BL       __2sprintf
;;;760    					
;;;761    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
0003ae  2206              MOVS     r2,#6
0003b0  4669              MOV      r1,sp
0003b2  a803              ADD      r0,sp,#0xc
0003b4  f7fffffe          BL       strncpy
;;;762    
;;;763    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
0003b8  a803              ADD      r0,sp,#0xc
0003ba  f7fffffe          BL       strlen
0003be  4606              MOV      r6,r0
0003c0  4631              MOV      r1,r6
0003c2  a803              ADD      r0,sp,#0xc
0003c4  f7fffffe          BL       dot_Loc_isNull
0003c8  4604              MOV      r4,r0
;;;764    					
;;;765    					if( dot_loc == 1024 ){
0003ca  f5b46f80          CMP      r4,#0x400
0003ce  d008              BEQ      |L1.994|
;;;766    									
;;;767    					}else{
;;;768    						
;;;769    						if( dot_loc < 2 ){		
0003d0  2c02              CMP      r4,#2
0003d2  da06              BGE      |L1.994|
;;;770    							
;;;771    							if( dTemp_Char[5] == '0' ){								
0003d4  f89d0011          LDRB     r0,[sp,#0x11]
0003d8  2830              CMP      r0,#0x30
0003da  d102              BNE      |L1.994|
;;;772    								
;;;773    								 dTemp_Char[5] = '\0';								
0003dc  2000              MOVS     r0,#0
0003de  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.994|
;;;774    							}							
;;;775    						}	
;;;776    					}	
;;;777    					
;;;778    				break;
0003e2  e112              B        |L1.1546|
;;;779    				//====================================限制电流======================================
;;;780    				case 2:   
;;;781    				
;;;782    					dTemp = (double)CLists.CDC_Limit_C / 1000;
0003e4  490e              LDR      r1,|L1.1056|
0003e6  f8b100e8          LDRH     r0,[r1,#0xe8]  ; CLists
0003ea  f7fffffe          BL       __aeabi_ui2d
0003ee  ec410b19          VMOV     d9,r0,r1
0003f2  ed9f0b0c          VLDR     d0,|L1.1060|
0003f6  ec532b10          VMOV     r2,r3,d0
0003fa  f7fffffe          BL       __aeabi_ddiv
0003fe  ec410b18          VMOV     d8,r0,r1
;;;783    					
;;;784    					sprintf( iTemp_Char, "%f", dTemp );
000402  ec532b18          VMOV     r2,r3,d8
000406  a109              ADR      r1,|L1.1068|
000408  4668              MOV      r0,sp
00040a  f7fffffe          BL       __2sprintf
;;;785    					
;;;786    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
00040e  2206              MOVS     r2,#6
000410  4669              MOV      r1,sp
000412  a803              ADD      r0,sp,#0xc
000414  f7fffffe          BL       strncpy
;;;787    
;;;788    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
000418  a803              ADD      r0,sp,#0xc
00041a  e011              B        |L1.1088|
                  |L1.1052|
                          DCD      FLAG_WIN
                  |L1.1056|
                          DCD      CLists
                  |L1.1060|
000424  00000000          DCFD     0x408f400000000000 ; 1000
000428  408f4000
                  |L1.1068|
00042c  256600            DCB      "%f",0
00042f  00                DCB      0
                  |L1.1072|
000430  256400            DCB      "%d",0
000433  00                DCB      0
                  |L1.1076|
000434  30303030          DCB      "0000",0
000438  00      
000439  00                DCB      0
00043a  00                DCB      0
00043b  00                DCB      0
                  |L1.1084|
00043c  3000              DCB      "0",0
00043e  00                DCB      0
00043f  00                DCB      0
                  |L1.1088|
000440  f7fffffe          BL       strlen
000444  4606              MOV      r6,r0
000446  4631              MOV      r1,r6
000448  a803              ADD      r0,sp,#0xc
00044a  f7fffffe          BL       dot_Loc_isNull
00044e  4604              MOV      r4,r0
;;;789    					
;;;790    					if( dot_loc == 1024 ){
000450  f5b46f80          CMP      r4,#0x400
000454  d008              BEQ      |L1.1128|
;;;791    									
;;;792    					}else{
;;;793    						
;;;794    						if( dot_loc < 2 ){		
000456  2c02              CMP      r4,#2
000458  da06              BGE      |L1.1128|
;;;795    							
;;;796    							if( dTemp_Char[5] == '0' ){								
00045a  f89d0011          LDRB     r0,[sp,#0x11]
00045e  2830              CMP      r0,#0x30
000460  d102              BNE      |L1.1128|
;;;797    								
;;;798    								 dTemp_Char[5] = '\0';								
000462  2000              MOVS     r0,#0
000464  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.1128|
;;;799    							}							
;;;800    						}	
;;;801    					}	
;;;802    					
;;;803    				break;
000468  e0cf              B        |L1.1546|
;;;804    				//====================================截止电压======================================
;;;805    				case 3:   
;;;806    				
;;;807    					dTemp = (double)CLists.CDC_Ccutoff_V / 1000;
00046a  49f8              LDR      r1,|L1.2124|
00046c  f8d100ec          LDR      r0,[r1,#0xec]  ; CLists
000470  f7fffffe          BL       __aeabi_ui2d
000474  ec410b19          VMOV     d9,r0,r1
000478  ed1f0b16          VLDR     d0,|L1.1060|
00047c  ec532b10          VMOV     r2,r3,d0
000480  f7fffffe          BL       __aeabi_ddiv
000484  ec410b18          VMOV     d8,r0,r1
;;;808    					
;;;809    					sprintf( iTemp_Char, "%f", dTemp );
000488  ec532b18          VMOV     r2,r3,d8
00048c  f2af0164          ADR      r1,|L1.1068|
000490  4668              MOV      r0,sp
000492  f7fffffe          BL       __2sprintf
;;;810    					
;;;811    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
000496  2206              MOVS     r2,#6
000498  4669              MOV      r1,sp
00049a  a803              ADD      r0,sp,#0xc
00049c  f7fffffe          BL       strncpy
;;;812    
;;;813    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
0004a0  a803              ADD      r0,sp,#0xc
0004a2  f7fffffe          BL       strlen
0004a6  4606              MOV      r6,r0
0004a8  4631              MOV      r1,r6
0004aa  a803              ADD      r0,sp,#0xc
0004ac  f7fffffe          BL       dot_Loc_isNull
0004b0  4604              MOV      r4,r0
;;;814    					
;;;815    					if( dot_loc == 1024 ){
0004b2  f5b46f80          CMP      r4,#0x400
0004b6  d008              BEQ      |L1.1226|
;;;816    									
;;;817    					}else{
;;;818    						
;;;819    						if( dot_loc < 2 ){		
0004b8  2c02              CMP      r4,#2
0004ba  da06              BGE      |L1.1226|
;;;820    							
;;;821    							if( dTemp_Char[5] == '0' ){								
0004bc  f89d0011          LDRB     r0,[sp,#0x11]
0004c0  2830              CMP      r0,#0x30
0004c2  d102              BNE      |L1.1226|
;;;822    								
;;;823    								 dTemp_Char[5] = '\0';								
0004c4  2000              MOVS     r0,#0
0004c6  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.1226|
;;;824    							}							
;;;825    						}	
;;;826    					}	
;;;827    					
;;;828    				break;
0004ca  e09e              B        |L1.1546|
;;;829    				//====================================截止电流======================================
;;;830    				case 4:   
;;;831    				
;;;832    					dTemp = (double)CLists.CDC_Ccutoff_C / 1000;
0004cc  49df              LDR      r1,|L1.2124|
0004ce  f8b100f0          LDRH     r0,[r1,#0xf0]  ; CLists
0004d2  f7fffffe          BL       __aeabi_ui2d
0004d6  ec410b19          VMOV     d9,r0,r1
0004da  ed1f0b2e          VLDR     d0,|L1.1060|
0004de  ec532b10          VMOV     r2,r3,d0
0004e2  f7fffffe          BL       __aeabi_ddiv
0004e6  ec410b18          VMOV     d8,r0,r1
;;;833    					
;;;834    					sprintf( iTemp_Char, "%f", dTemp );
0004ea  ec532b18          VMOV     r2,r3,d8
0004ee  f2af01c4          ADR      r1,|L1.1068|
0004f2  4668              MOV      r0,sp
0004f4  f7fffffe          BL       __2sprintf
;;;835    					
;;;836    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
0004f8  2206              MOVS     r2,#6
0004fa  4669              MOV      r1,sp
0004fc  a803              ADD      r0,sp,#0xc
0004fe  f7fffffe          BL       strncpy
;;;837    
;;;838    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
000502  a803              ADD      r0,sp,#0xc
000504  f7fffffe          BL       strlen
000508  4606              MOV      r6,r0
00050a  4631              MOV      r1,r6
00050c  a803              ADD      r0,sp,#0xc
00050e  f7fffffe          BL       dot_Loc_isNull
000512  4604              MOV      r4,r0
;;;839    					
;;;840    					if( dot_loc == 1024 ){
000514  f5b46f80          CMP      r4,#0x400
000518  d008              BEQ      |L1.1324|
;;;841    									
;;;842    					}else{
;;;843    						
;;;844    						if( dot_loc < 2 ){		
00051a  2c02              CMP      r4,#2
00051c  da06              BGE      |L1.1324|
;;;845    							
;;;846    							if( dTemp_Char[5] == '0' ){								
00051e  f89d0011          LDRB     r0,[sp,#0x11]
000522  2830              CMP      r0,#0x30
000524  d102              BNE      |L1.1324|
;;;847    								
;;;848    								 dTemp_Char[5] = '\0';								
000526  2000              MOVS     r0,#0
000528  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.1324|
;;;849    							}							
;;;850    						}	
;;;851    					}	
;;;852    					
;;;853    				break;
00052c  e06d              B        |L1.1546|
;;;854    				//====================================负载电流======================================
;;;855    				case 5:   
;;;856    				
;;;857    					dTemp = (double)CLists.CDC_Load_C / 1000;
00052e  49c7              LDR      r1,|L1.2124|
000530  f8b100f2          LDRH     r0,[r1,#0xf2]  ; CLists
000534  f7fffffe          BL       __aeabi_ui2d
000538  ec410b19          VMOV     d9,r0,r1
00053c  ed1f0b47          VLDR     d0,|L1.1060|
000540  ec532b10          VMOV     r2,r3,d0
000544  f7fffffe          BL       __aeabi_ddiv
000548  ec410b18          VMOV     d8,r0,r1
;;;858    					
;;;859    					sprintf( iTemp_Char, "%f", dTemp );
00054c  ec532b18          VMOV     r2,r3,d8
000550  f2af1128          ADR      r1,|L1.1068|
000554  4668              MOV      r0,sp
000556  f7fffffe          BL       __2sprintf
;;;860    					
;;;861    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
00055a  2206              MOVS     r2,#6
00055c  4669              MOV      r1,sp
00055e  a803              ADD      r0,sp,#0xc
000560  f7fffffe          BL       strncpy
;;;862    
;;;863    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
000564  a803              ADD      r0,sp,#0xc
000566  f7fffffe          BL       strlen
00056a  4606              MOV      r6,r0
00056c  4631              MOV      r1,r6
00056e  a803              ADD      r0,sp,#0xc
000570  e001              B        |L1.1398|
000572  e041              B        |L1.1528|
000574  e00f              B        |L1.1430|
                  |L1.1398|
000576  f7fffffe          BL       dot_Loc_isNull
00057a  4604              MOV      r4,r0
;;;864    					
;;;865    					if( dot_loc == 1024 ){
00057c  f5b46f80          CMP      r4,#0x400
000580  d008              BEQ      |L1.1428|
;;;866    									
;;;867    					}else{
;;;868    						
;;;869    						if( dot_loc < 2 ){		
000582  2c02              CMP      r4,#2
000584  da06              BGE      |L1.1428|
;;;870    							
;;;871    							if( dTemp_Char[5] == '0' ){								
000586  f89d0011          LDRB     r0,[sp,#0x11]
00058a  2830              CMP      r0,#0x30
00058c  d102              BNE      |L1.1428|
;;;872    								
;;;873    								 dTemp_Char[5] = '\0';								
00058e  2000              MOVS     r0,#0
000590  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.1428|
;;;874    							}							
;;;875    						}	
;;;876    					}	
;;;877    					
;;;878    				break;
000594  e039              B        |L1.1546|
                  |L1.1430|
;;;879    				//====================================截止电压======================================
;;;880    				case 6:   
;;;881    				
;;;882    					dTemp = (double)CLists.CDC_Dcutoff_V / 1000;
000596  49ad              LDR      r1,|L1.2124|
000598  f8d100f4          LDR      r0,[r1,#0xf4]  ; CLists
00059c  f7fffffe          BL       __aeabi_ui2d
0005a0  ec410b19          VMOV     d9,r0,r1
0005a4  ed1f0b61          VLDR     d0,|L1.1060|
0005a8  ec532b10          VMOV     r2,r3,d0
0005ac  f7fffffe          BL       __aeabi_ddiv
0005b0  ec410b18          VMOV     d8,r0,r1
;;;883    					
;;;884    					sprintf( iTemp_Char, "%f", dTemp );
0005b4  ec532b18          VMOV     r2,r3,d8
0005b8  f2af1190          ADR      r1,|L1.1068|
0005bc  4668              MOV      r0,sp
0005be  f7fffffe          BL       __2sprintf
;;;885    					
;;;886    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
0005c2  2206              MOVS     r2,#6
0005c4  4669              MOV      r1,sp
0005c6  a803              ADD      r0,sp,#0xc
0005c8  f7fffffe          BL       strncpy
;;;887    
;;;888    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
0005cc  a803              ADD      r0,sp,#0xc
0005ce  f7fffffe          BL       strlen
0005d2  4606              MOV      r6,r0
0005d4  4631              MOV      r1,r6
0005d6  a803              ADD      r0,sp,#0xc
0005d8  f7fffffe          BL       dot_Loc_isNull
0005dc  4604              MOV      r4,r0
;;;889    					
;;;890    					if( dot_loc == 1024 ){
0005de  f5b46f80          CMP      r4,#0x400
0005e2  d008              BEQ      |L1.1526|
;;;891    									
;;;892    					}else{
;;;893    						
;;;894    						if( dot_loc < 2 ){		
0005e4  2c02              CMP      r4,#2
0005e6  da06              BGE      |L1.1526|
;;;895    							
;;;896    							if( dTemp_Char[5] == '0' ){								
0005e8  f89d0011          LDRB     r0,[sp,#0x11]
0005ec  2830              CMP      r0,#0x30
0005ee  d102              BNE      |L1.1526|
;;;897    								
;;;898    								 dTemp_Char[5] = '\0';								
0005f0  2000              MOVS     r0,#0
0005f2  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.1526|
;;;899    							}							
;;;900    						}	
;;;901    					}	
;;;902    					
;;;903    				break;
0005f6  e008              B        |L1.1546|
                  |L1.1528|
;;;904    				//====================================循环次数======================================
;;;905    				case 7:   
;;;906    				
;;;907    					sprintf( dTemp_Char, "%d", CLists.CDC_Cycle_Time );
0005f8  4894              LDR      r0,|L1.2124|
0005fa  f89020f8          LDRB     r2,[r0,#0xf8]  ; CLists
0005fe  f2af11d0          ADR      r1,|L1.1072|
000602  a803              ADD      r0,sp,#0xc
000604  f7fffffe          BL       __2sprintf
;;;908    					
;;;909    				break;
000608  bf00              NOP      
                  |L1.1546|
00060a  bf00              NOP                            ;778
                  |L1.1548|
;;;910    			}	
;;;911    		
;;;912    		}
;;;913    		
;;;914    		break;
00060c  e187              B        |L1.2334|
                  |L1.1550|
;;;915    		
;;;916    		case 4:{
;;;917    				
;;;918    		}
;;;919    		
;;;920    		break;
00060e  e186              B        |L1.2334|
                  |L1.1552|
;;;921    		
;;;922    		case 5:{
;;;923    				
;;;924    			switch( v_f ){
000610  f89d0034          LDRB     r0,[sp,#0x34]
000614  280c              CMP      r0,#0xc
000616  d20f              BCS      |L1.1592|
000618  e8dff000          TBB      [pc,r0]
00061c  0e060f18          DCB      0x0e,0x06,0x0f,0x18
000620  2152838c          DCB      0x21,0x52,0x83,0x8c
000624  95c6f9f7          DCB      0x95,0xc6,0xf9,0xf7
;;;925    				//====================================分选开关======================================
;;;926    				case 1:   
;;;927    				
;;;928    					sprintf( dTemp_Char, "%d", CLists.SYS_Comparator );
000628  4888              LDR      r0,|L1.2124|
00062a  f89020f9          LDRB     r2,[r0,#0xf9]  ; CLists
00062e  f2af2100          ADR      r1,|L1.1072|
000632  a803              ADD      r0,sp,#0xc
000634  f7fffffe          BL       __2sprintf
                  |L1.1592|
;;;929    					
;;;930    				break;
000638  e0fb              B        |L1.2098|
;;;931    				//====================================过流测试======================================
;;;932    				case 2:   
;;;933    				
;;;934    					sprintf( dTemp_Char, "%d", CLists.SYS_Overflow );
00063a  4884              LDR      r0,|L1.2124|
00063c  f89020fa          LDRB     r2,[r0,#0xfa]  ; CLists
000640  f2af2114          ADR      r1,|L1.1072|
000644  a803              ADD      r0,sp,#0xc
000646  f7fffffe          BL       __2sprintf
;;;935    					
;;;936    				break;
00064a  e0f2              B        |L1.2098|
;;;937    				//====================================报警声音======================================
;;;938    				case 3:   
;;;939    				
;;;940    					sprintf( dTemp_Char, "%d", CLists.SYS_Beep );
00064c  487f              LDR      r0,|L1.2124|
00064e  f89020fb          LDRB     r2,[r0,#0xfb]  ; CLists
000652  f2af2124          ADR      r1,|L1.1072|
000656  a803              ADD      r0,sp,#0xc
000658  f7fffffe          BL       __2sprintf
;;;941    					
;;;942    				break;
00065c  e0e9              B        |L1.2098|
;;;943    				//====================================电压上限======================================
;;;944    				case 4:   
;;;945    				
;;;946    					dTemp = (double)CLists.SYS_UL_V / 1000;
00065e  497b              LDR      r1,|L1.2124|
000660  f8d100fc          LDR      r0,[r1,#0xfc]  ; CLists
000664  f7fffffe          BL       __aeabi_ui2d
000668  ec410b19          VMOV     d9,r0,r1
00066c  ed1f0b93          VLDR     d0,|L1.1060|
000670  ec532b10          VMOV     r2,r3,d0
000674  f7fffffe          BL       __aeabi_ddiv
000678  ec410b18          VMOV     d8,r0,r1
;;;947    					
;;;948    					sprintf( iTemp_Char, "%f", dTemp );
00067c  ec532b18          VMOV     r2,r3,d8
000680  f2af2158          ADR      r1,|L1.1068|
000684  4668              MOV      r0,sp
000686  f7fffffe          BL       __2sprintf
;;;949    					
;;;950    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
00068a  2206              MOVS     r2,#6
00068c  4669              MOV      r1,sp
00068e  a803              ADD      r0,sp,#0xc
000690  f7fffffe          BL       strncpy
;;;951    
;;;952    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
000694  a803              ADD      r0,sp,#0xc
000696  f7fffffe          BL       strlen
00069a  4606              MOV      r6,r0
00069c  4631              MOV      r1,r6
00069e  a803              ADD      r0,sp,#0xc
0006a0  f7fffffe          BL       dot_Loc_isNull
0006a4  4604              MOV      r4,r0
;;;953    					
;;;954    					if( dot_loc == 1024 ){
0006a6  f5b46f80          CMP      r4,#0x400
0006aa  d008              BEQ      |L1.1726|
;;;955    									
;;;956    					}else{
;;;957    						
;;;958    						if( dot_loc < 2 ){		
0006ac  2c02              CMP      r4,#2
0006ae  da06              BGE      |L1.1726|
;;;959    							
;;;960    							if( dTemp_Char[5] == '0' ){								
0006b0  f89d0011          LDRB     r0,[sp,#0x11]
0006b4  2830              CMP      r0,#0x30
0006b6  d102              BNE      |L1.1726|
;;;961    								
;;;962    								 dTemp_Char[5] = '\0';								
0006b8  2000              MOVS     r0,#0
0006ba  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.1726|
;;;963    							}							
;;;964    						}	
;;;965    					}	
;;;966    					
;;;967    				break;
0006be  e0b8              B        |L1.2098|
;;;968    				//====================================电压下限======================================
;;;969    				case 5:   
;;;970    				
;;;971    					dTemp = (double)CLists.SYS_LL_V / 1000;
0006c0  4962              LDR      r1,|L1.2124|
0006c2  f8d10100          LDR      r0,[r1,#0x100]  ; CLists
0006c6  f7fffffe          BL       __aeabi_ui2d
0006ca  ec410b19          VMOV     d9,r0,r1
0006ce  ed1f0bab          VLDR     d0,|L1.1060|
0006d2  ec532b10          VMOV     r2,r3,d0
0006d6  f7fffffe          BL       __aeabi_ddiv
0006da  ec410b18          VMOV     d8,r0,r1
;;;972    					
;;;973    					sprintf( iTemp_Char, "%f", dTemp );
0006de  ec532b18          VMOV     r2,r3,d8
0006e2  f2af21b8          ADR      r1,|L1.1068|
0006e6  4668              MOV      r0,sp
0006e8  f7fffffe          BL       __2sprintf
;;;974    					
;;;975    					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
0006ec  2206              MOVS     r2,#6
0006ee  4669              MOV      r1,sp
0006f0  a803              ADD      r0,sp,#0xc
0006f2  f7fffffe          BL       strncpy
;;;976    
;;;977    					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
0006f6  a803              ADD      r0,sp,#0xc
0006f8  f7fffffe          BL       strlen
0006fc  4606              MOV      r6,r0
0006fe  4631              MOV      r1,r6
000700  a803              ADD      r0,sp,#0xc
000702  f7fffffe          BL       dot_Loc_isNull
000706  4604              MOV      r4,r0
;;;978    					
;;;979    					if( dot_loc == 1024 ){
000708  f5b46f80          CMP      r4,#0x400
00070c  d008              BEQ      |L1.1824|
;;;980    									
;;;981    					}else{
;;;982    						
;;;983    						if( dot_loc < 2 ){		
00070e  2c02              CMP      r4,#2
000710  da06              BGE      |L1.1824|
;;;984    							
;;;985    							if( dTemp_Char[5] == '0' ){								
000712  f89d0011          LDRB     r0,[sp,#0x11]
000716  2830              CMP      r0,#0x30
000718  d102              BNE      |L1.1824|
;;;986    								
;;;987    								 dTemp_Char[5] = '\0';								
00071a  2000              MOVS     r0,#0
00071c  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.1824|
;;;988    							}							
;;;989    						}	
;;;990    					}	
;;;991    					
;;;992    				break;
000720  e087              B        |L1.2098|
;;;993    				//====================================内阻上限======================================
;;;994    				case 6:   
;;;995    				
;;;996    					/* dTemp = (double)CLists.SYS_UL_II / 1000;
;;;997    					
;;;998    					sprintf( iTemp_Char, "%f", dTemp );
;;;999    					
;;;1000   					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
;;;1001   
;;;1002   					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
;;;1003   					
;;;1004   					if( dot_loc == 1024 ){
;;;1005   									
;;;1006   					}else{
;;;1007   						
;;;1008   						if( dot_loc < 2 ){		
;;;1009   							
;;;1010   							if( dTemp_Char[5] == '0' ){								
;;;1011   								
;;;1012   								 dTemp_Char[5] = '\0';								
;;;1013   							}							
;;;1014   						}	
;;;1015   					}	 */
;;;1016   					
;;;1017   					sprintf( dTemp_Char, "%d", CLists.SYS_UL_II );
000722  484a              LDR      r0,|L1.2124|
000724  f8b02104          LDRH     r2,[r0,#0x104]  ; CLists
000728  f2af21fc          ADR      r1,|L1.1072|
00072c  a803              ADD      r0,sp,#0xc
00072e  f7fffffe          BL       __2sprintf
;;;1018   					
;;;1019   				break;
000732  e07e              B        |L1.2098|
;;;1020   				//====================================内阻下限======================================
;;;1021   				case 7:   
;;;1022   
;;;1023   					/* dTemp = (double)CLists.SYS_LL_IR / 1000;
;;;1024   					
;;;1025   					sprintf( iTemp_Char, "%f", dTemp );
;;;1026   					
;;;1027   					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
;;;1028   
;;;1029   					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
;;;1030   					
;;;1031   					if( dot_loc == 1024 ){
;;;1032   									
;;;1033   					}else{
;;;1034   						
;;;1035   						if( dot_loc < 2 ){		
;;;1036   							
;;;1037   							if( dTemp_Char[5] == '0' ){								
;;;1038   								
;;;1039   								 dTemp_Char[5] = '\0';								
;;;1040   							}							
;;;1041   						}	
;;;1042   					} */
;;;1043   					
;;;1044   					sprintf( dTemp_Char, "%d", CLists.SYS_LL_IR );
000734  4845              LDR      r0,|L1.2124|
000736  f8b02106          LDRH     r2,[r0,#0x106]  ; CLists
00073a  f2af310c          ADR      r1,|L1.1072|
00073e  a803              ADD      r0,sp,#0xc
000740  f7fffffe          BL       __2sprintf
;;;1045   					
;;;1046   				break;	
000744  e075              B        |L1.2098|
;;;1047   				//====================================过流上限======================================
;;;1048   				case 8:   
;;;1049   				
;;;1050   					dTemp = (double)CLists.SYS_UL_Overflow / 1000;
000746  4941              LDR      r1,|L1.2124|
000748  f8b10108          LDRH     r0,[r1,#0x108]  ; CLists
00074c  f7fffffe          BL       __aeabi_ui2d
000750  ec410b19          VMOV     d9,r0,r1
000754  ed1f0bcd          VLDR     d0,|L1.1060|
000758  ec532b10          VMOV     r2,r3,d0
00075c  f7fffffe          BL       __aeabi_ddiv
000760  ec410b18          VMOV     d8,r0,r1
;;;1051   					
;;;1052   					sprintf( iTemp_Char, "%f", dTemp );
000764  ec532b18          VMOV     r2,r3,d8
000768  f2af3140          ADR      r1,|L1.1068|
00076c  4668              MOV      r0,sp
00076e  f7fffffe          BL       __2sprintf
;;;1053   					
;;;1054   					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
000772  2206              MOVS     r2,#6
000774  4669              MOV      r1,sp
000776  a803              ADD      r0,sp,#0xc
000778  f7fffffe          BL       strncpy
;;;1055   
;;;1056   					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
00077c  a803              ADD      r0,sp,#0xc
00077e  f7fffffe          BL       strlen
000782  4606              MOV      r6,r0
000784  4631              MOV      r1,r6
000786  a803              ADD      r0,sp,#0xc
000788  f7fffffe          BL       dot_Loc_isNull
00078c  4604              MOV      r4,r0
;;;1057   					
;;;1058   					if( dot_loc == 1024 ){
00078e  f5b46f80          CMP      r4,#0x400
000792  d008              BEQ      |L1.1958|
;;;1059   									
;;;1060   					}else{
;;;1061   						
;;;1062   						if( dot_loc < 2 ){		
000794  2c02              CMP      r4,#2
000796  da06              BGE      |L1.1958|
;;;1063   							
;;;1064   							if( dTemp_Char[5] == '0' ){								
000798  f89d0011          LDRB     r0,[sp,#0x11]
00079c  2830              CMP      r0,#0x30
00079e  d102              BNE      |L1.1958|
;;;1065   								
;;;1066   								 dTemp_Char[5] = '\0';								
0007a0  2000              MOVS     r0,#0
0007a2  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.1958|
;;;1067   							}							
;;;1068   						}	
;;;1069   					}	
;;;1070   					
;;;1071   				break;
0007a6  e044              B        |L1.2098|
;;;1072   				//====================================过流下限======================================
;;;1073   				case 9:   
;;;1074   				
;;;1075   					dTemp = (double)CLists.SYS_LL_Overflow / 1000;
0007a8  4928              LDR      r1,|L1.2124|
0007aa  f8b1010a          LDRH     r0,[r1,#0x10a]  ; CLists
0007ae  f7fffffe          BL       __aeabi_ui2d
0007b2  ec410b19          VMOV     d9,r0,r1
0007b6  ed1f0be5          VLDR     d0,|L1.1060|
0007ba  ec532b10          VMOV     r2,r3,d0
0007be  f7fffffe          BL       __aeabi_ddiv
0007c2  ec410b18          VMOV     d8,r0,r1
;;;1076   					
;;;1077   					sprintf( iTemp_Char, "%f", dTemp );
0007c6  ec532b18          VMOV     r2,r3,d8
0007ca  f2af31a0          ADR      r1,|L1.1068|
0007ce  4668              MOV      r0,sp
0007d0  f7fffffe          BL       __2sprintf
;;;1078   					
;;;1079   					strncpy( dTemp_Char, iTemp_Char , 6  );  					//先截取五位
0007d4  2206              MOVS     r2,#6
0007d6  4669              MOV      r1,sp
0007d8  a803              ADD      r0,sp,#0xc
0007da  f7fffffe          BL       strncpy
;;;1080   
;;;1081   					dot_loc = dot_Loc_isNull( dTemp_Char,strlen(dTemp_Char) );	//获取小数点位置
0007de  a803              ADD      r0,sp,#0xc
0007e0  f7fffffe          BL       strlen
0007e4  4606              MOV      r6,r0
0007e6  4631              MOV      r1,r6
0007e8  a803              ADD      r0,sp,#0xc
0007ea  f7fffffe          BL       dot_Loc_isNull
0007ee  4604              MOV      r4,r0
;;;1082   					
;;;1083   					if( dot_loc == 1024 ){
0007f0  f5b46f80          CMP      r4,#0x400
0007f4  d008              BEQ      |L1.2056|
;;;1084   									
;;;1085   					}else{
;;;1086   						
;;;1087   						if( dot_loc < 2 ){		
0007f6  2c02              CMP      r4,#2
0007f8  da06              BGE      |L1.2056|
;;;1088   							
;;;1089   							if( dTemp_Char[5] == '0' ){								
0007fa  f89d0011          LDRB     r0,[sp,#0x11]
0007fe  2830              CMP      r0,#0x30
000800  d102              BNE      |L1.2056|
;;;1090   								
;;;1091   								 dTemp_Char[5] = '\0';								
000802  2000              MOVS     r0,#0
000804  f88d0011          STRB     r0,[sp,#0x11]
                  |L1.2056|
;;;1092   							}							
;;;1093   						}	
;;;1094   					}	
;;;1095   					
;;;1096   				break;
000808  e013              B        |L1.2098|
00080a  e009              B        |L1.2080|
00080c  e7ff              B        |L1.2062|
                  |L1.2062|
;;;1097   				//====================================电池类型======================================
;;;1098   				case 10:   
;;;1099   				
;;;1100   					sprintf( dTemp_Char, "%d", CLists.SYS_BatteryType );
00080e  480f              LDR      r0,|L1.2124|
000810  f890210c          LDRB     r2,[r0,#0x10c]  ; CLists
000814  f2af31e8          ADR      r1,|L1.1072|
000818  a803              ADD      r0,sp,#0xc
00081a  f7fffffe          BL       __2sprintf
;;;1101   					
;;;1102   				break;
00081e  e008              B        |L1.2098|
                  |L1.2080|
;;;1103   				//======================================语言=========================================
;;;1104   				case 11:   
;;;1105   					
;;;1106   					sprintf( dTemp_Char, "%d", CLists.SYS_LANUGAGE );
000820  480a              LDR      r0,|L1.2124|
000822  f890210d          LDRB     r2,[r0,#0x10d]  ; CLists
000826  f2af31f8          ADR      r1,|L1.1072|
00082a  a803              ADD      r0,sp,#0xc
00082c  f7fffffe          BL       __2sprintf
;;;1107   					
;;;1108   				break;
000830  bf00              NOP      
                  |L1.2098|
000832  bf00              NOP                            ;930
;;;1109   				
;;;1110   				
;;;1111   			}	
;;;1112   			
;;;1113   		}
;;;1114   		
;;;1115   		break;
000834  e073              B        |L1.2334|
                  |L1.2102|
;;;1116   		
;;;1117   		case 6:{
;;;1118   			switch( v_f ){
000836  f89d0034          LDRB     r0,[sp,#0x34]
00083a  2801              CMP      r0,#1
00083c  d008              BEQ      |L1.2128|
00083e  2802              CMP      r0,#2
000840  d00f              BEQ      |L1.2146|
000842  2803              CMP      r0,#3
000844  d024              BEQ      |L1.2192|
000846  2804              CMP      r0,#4
000848  d167              BNE      |L1.2330|
00084a  e038              B        |L1.2238|
                  |L1.2124|
                          DCD      CLists
                  |L1.2128|
;;;1119   				
;;;1120   				case 1:   
;;;1121   					
;;;1122   					sprintf( dTemp_Char, "%d", CLists.SYS_SYEARS );
000850  4838              LDR      r0,|L1.2356|
000852  f8b0210e          LDRH     r2,[r0,#0x10e]  ; CLists
000856  f2af4128          ADR      r1,|L1.1072|
00085a  a803              ADD      r0,sp,#0xc
00085c  f7fffffe          BL       __2sprintf
;;;1123   					
;;;1124   				break;
000860  e05b              B        |L1.2330|
                  |L1.2146|
;;;1125   				
;;;1126   				case 2:   
;;;1127   					
;;;1128   					sprintf( iTemp_Char, "%d", CLists.SYS_SMONTHS );
000862  4834              LDR      r0,|L1.2356|
000864  f8902110          LDRB     r2,[r0,#0x110]  ; CLists
000868  f2af413c          ADR      r1,|L1.1072|
00086c  4668              MOV      r0,sp
00086e  f7fffffe          BL       __2sprintf
;;;1129   					
;;;1130   					if( strlen( iTemp_Char) < 2 ){    strcat( dTemp_Char, "0");    }
000872  4668              MOV      r0,sp
000874  f7fffffe          BL       strlen
000878  2802              CMP      r0,#2
00087a  d204              BCS      |L1.2182|
00087c  f2af4144          ADR      r1,|L1.1084|
000880  a803              ADD      r0,sp,#0xc
000882  f7fffffe          BL       strcat
                  |L1.2182|
;;;1131   					
;;;1132   					strcat( dTemp_Char, iTemp_Char ); 
000886  4669              MOV      r1,sp
000888  a803              ADD      r0,sp,#0xc
00088a  f7fffffe          BL       strcat
;;;1133   					
;;;1134   				break;
00088e  e044              B        |L1.2330|
                  |L1.2192|
;;;1135   				
;;;1136   				case 3:   
;;;1137   				
;;;1138   					sprintf( iTemp_Char, "%d", CLists.SYS_SDAYS );
000890  4828              LDR      r0,|L1.2356|
000892  f8902111          LDRB     r2,[r0,#0x111]  ; CLists
000896  f2af4168          ADR      r1,|L1.1072|
00089a  4668              MOV      r0,sp
00089c  f7fffffe          BL       __2sprintf
;;;1139   					
;;;1140   					if( strlen( iTemp_Char) < 2 ){    strcat( dTemp_Char, "0");    }
0008a0  4668              MOV      r0,sp
0008a2  f7fffffe          BL       strlen
0008a6  2802              CMP      r0,#2
0008a8  d204              BCS      |L1.2228|
0008aa  f2af4170          ADR      r1,|L1.1084|
0008ae  a803              ADD      r0,sp,#0xc
0008b0  f7fffffe          BL       strcat
                  |L1.2228|
;;;1141   					
;;;1142   					strcat( dTemp_Char, iTemp_Char ); 
0008b4  4669              MOV      r1,sp
0008b6  a803              ADD      r0,sp,#0xc
0008b8  f7fffffe          BL       strcat
;;;1143   					
;;;1144   				break;
0008bc  e02d              B        |L1.2330|
                  |L1.2238|
;;;1145   				
;;;1146   				case 4:   
;;;1147   				
;;;1148   					sprintf( iTemp_Char, "%d", CLists.SYS_SerialNO );
0008be  481d              LDR      r0,|L1.2356|
0008c0  f8d02114          LDR      r2,[r0,#0x114]  ; CLists
0008c4  f2af4198          ADR      r1,|L1.1072|
0008c8  4668              MOV      r0,sp
0008ca  f7fffffe          BL       __2sprintf
;;;1149   					
;;;1150   					if( strlen(iTemp_Char) == 1 && CLists.SYS_SerialNO == 0 ){
0008ce  4668              MOV      r0,sp
0008d0  f7fffffe          BL       strlen
0008d4  2801              CMP      r0,#1
0008d6  d107              BNE      |L1.2280|
0008d8  4816              LDR      r0,|L1.2356|
0008da  f8d00114          LDR      r0,[r0,#0x114]  ; CLists
0008de  b918              CBNZ     r0,|L1.2280|
;;;1151   						
;;;1152   						strcpy( dTemp_Char, "00000000" );		
0008e0  a115              ADR      r1,|L1.2360|
0008e2  a803              ADD      r0,sp,#0xc
0008e4  f7fffffe          BL       strcpy
                  |L1.2280|
;;;1153   					}
;;;1154   					if( strlen(iTemp_Char) < 8 ){
0008e8  4668              MOV      r0,sp
0008ea  f7fffffe          BL       strlen
0008ee  2808              CMP      r0,#8
0008f0  d20e              BCS      |L1.2320|
;;;1155   						
;;;1156   						for( i = 0; i < 8 - strlen(iTemp_Char); i++ ){
0008f2  2500              MOVS     r5,#0
0008f4  e005              B        |L1.2306|
                  |L1.2294|
;;;1157   							
;;;1158   							strcat( dTemp_Char, "0" ); 
0008f6  f2af41bc          ADR      r1,|L1.1084|
0008fa  a803              ADD      r0,sp,#0xc
0008fc  f7fffffe          BL       strcat
000900  1c6d              ADDS     r5,r5,#1              ;1156
                  |L1.2306|
000902  4668              MOV      r0,sp                 ;1156
000904  f7fffffe          BL       strlen
000908  f1c00008          RSB      r0,r0,#8              ;1156
00090c  42a8              CMP      r0,r5                 ;1156
00090e  d8f2              BHI      |L1.2294|
                  |L1.2320|
;;;1159   						}	
;;;1160   					}
;;;1161   					strcat( dTemp_Char, iTemp_Char);	
000910  4669              MOV      r1,sp
000912  a803              ADD      r0,sp,#0xc
000914  f7fffffe          BL       strcat
;;;1162   				break;
000918  bf00              NOP      
                  |L1.2330|
00091a  bf00              NOP                            ;1124
;;;1163   
;;;1164   			}				
;;;1165   		}
;;;1166   		
;;;1167   		break;
00091c  bf00              NOP      
                  |L1.2334|
00091e  bf00              NOP                            ;587
;;;1168   		
;;;1169   	}
;;;1170   	strcpy( return_char, dTemp_Char );
000920  a903              ADD      r1,sp,#0xc
000922  a806              ADD      r0,sp,#0x18
000924  f7fffffe          BL       strcpy
;;;1171   	
;;;1172   	return return_char;
000928  a806              ADD      r0,sp,#0x18
;;;1173   } 
00092a  b009              ADD      sp,sp,#0x24
00092c  ecbd8b04          VPOP     {d8-d9}
000930  bd78              POP      {r3-r6,pc}
;;;1174   
                          ENDP

000932  0000              DCW      0x0000
                  |L1.2356|
                          DCD      CLists
                  |L1.2360|
000938  30303030          DCB      "00000000",0
00093c  30303030
000940  00      
000941  00                DCB      0
000942  00                DCB      0
000943  00                DCB      0

                          AREA ||i.Read_Flash_Bytes||, CODE, READONLY, ALIGN=2

                  Read_Flash_Bytes PROC
;;;505    
;;;506    void Read_Flash_Bytes(){
000000  b510              PUSH     {r4,lr}
;;;507    	
;;;508    	int return_flag;
;;;509    	
;;;510    	return_flag = ReadBytes( &CLists, 0, sizeof(CLists));
000002  f44f728c          MOV      r2,#0x118
000006  2100              MOVS     r1,#0
000008  4802              LDR      r0,|L2.20|
00000a  f7fffffe          BL       ReadBytes
00000e  4604              MOV      r4,r0
;;;511    
;;;512    }
000010  bd10              POP      {r4,pc}
;;;513    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      CLists

                          AREA ||i.Write_Flash_Bytes||, CODE, READONLY, ALIGN=2

                  Write_Flash_Bytes PROC
;;;497    
;;;498    void Write_Flash_Bytes(){
000000  b510              PUSH     {r4,lr}
;;;499    	
;;;500    	int return_flag;
;;;501    	
;;;502    	return_flag = WriteBytes( &CLists, 0, sizeof(CLists));
000002  f44f728c          MOV      r2,#0x118
000006  2100              MOVS     r1,#0
000008  4802              LDR      r0,|L3.20|
00000a  f7fffffe          BL       WriteBytes
00000e  4604              MOV      r4,r0
;;;503    	
;;;504    }
000010  bd10              POP      {r4,pc}
;;;505    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      CLists

                          AREA ||i.bush_Graph_String||, CODE, READONLY, ALIGN=2

                  bush_Graph_String PROC
;;;404    //绘制矩形+文本        当前语言     数据      字体
;;;405    void bush_Graph_String(vu8 langType , struct SGraphData SGData ){	
000000  b40f              PUSH     {r0-r3}
000002  b570              PUSH     {r4-r6,lr}
;;;406    
;;;407    	int fx;
;;;408    	char* G_FStr;
;;;409    	
;;;410    	switch( SGData.t_Type ){
000004  9807              LDR      r0,[sp,#0x1c]
000006  2806              CMP      r0,#6
000008  d204              BCS      |L4.20|
00000a  e8dff000          TBB      [pc,r0]
00000e  0306              DCB      0x03,0x06
000010  64048905          DCB      0x64,0x04,0x89,0x05
                  |L4.20|
;;;411    		
;;;412    		case T_Button:  
;;;413    		
;;;414    		break;
000014  e098              B        |L4.328|
;;;415    		case T_TLISTBOX:
;;;416    			//构图思路
;;;417    			//如果为下拉框  则需要下拉数据  设置ID与列表ID对应 
;;;418    		    //包含ID，是否得到焦点，中文显示，英文显示 ，
;;;419    			//列表数据所占的框
;;;420    			//列表数据获取焦点
;;;421    		case T_LBox_Text:
000016  bf00              NOP      
;;;422    			
;;;423    		case T_THref:
000018  bf00              NOP      
;;;424    		
;;;425    			if( SGData.focusType ){    //  1  ---  点击		
00001a  9806              LDR      r0,[sp,#0x18]
00001c  b1a8              CBZ      r0,|L4.74|
;;;426    			
;;;427    				GUI_SetColor( 0x00FDF3E6 );
00001e  484c              LDR      r0,|L4.336|
000020  f7fffffe          BL       GUI_SetColor
;;;428    				
;;;429    				if( SGData.d_BKColor !=     0x0 ) 	    GUI_SetColor(SGData.d_BKColor);
000024  9813              LDR      r0,[sp,#0x4c]
000026  b110              CBZ      r0,|L4.46|
000028  9813              LDR      r0,[sp,#0x4c]
00002a  f7fffffe          BL       GUI_SetColor
                  |L4.46|
;;;430    				
;;;431    				GUI_FillRect(SGData.d_x, SGData.d_y, SGData.d_x1, SGData.d_y1);   //绘制矩形
00002e  f8bd305a          LDRH     r3,[sp,#0x5a]
000032  f8bd2058          LDRH     r2,[sp,#0x58]
000036  f8bd1056          LDRH     r1,[sp,#0x56]
00003a  f8bd0054          LDRH     r0,[sp,#0x54]
00003e  f7fffffe          BL       GUI_FillRect
;;;432    				
;;;433    				GUI_SetColor( 0x00000000 );
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       GUI_SetColor
000048  e015              B        |L4.118|
                  |L4.74|
;;;434    				 		
;;;435    			}else{
;;;436    				
;;;437    				GUI_SetColor( 0x004A4655 );
00004a  4842              LDR      r0,|L4.340|
00004c  f7fffffe          BL       GUI_SetColor
;;;438    				
;;;439    				if( SGData.d_BKColor !=      0x0 ) 		GUI_SetColor(SGData.d_BKColor);
000050  9813              LDR      r0,[sp,#0x4c]
000052  b110              CBZ      r0,|L4.90|
000054  9813              LDR      r0,[sp,#0x4c]
000056  f7fffffe          BL       GUI_SetColor
                  |L4.90|
;;;440    				
;;;441    				GUI_FillRect(SGData.d_x, SGData.d_y, SGData.d_x1, SGData.d_y1);   //绘制矩形
00005a  f8bd305a          LDRH     r3,[sp,#0x5a]
00005e  f8bd2058          LDRH     r2,[sp,#0x58]
000062  f8bd1056          LDRH     r1,[sp,#0x56]
000066  f8bd0054          LDRH     r0,[sp,#0x54]
00006a  f7fffffe          BL       GUI_FillRect
;;;442    				
;;;443    				GUI_SetColor( 0x00FFFFFF );  
00006e  f06f407f          MVN      r0,#0xff000000
000072  f7fffffe          BL       GUI_SetColor
                  |L4.118|
;;;444    			}
;;;445    			if( SGData.d_FColor      !=      0x0 )      GUI_SetColor(SGData.d_FColor); 
000076  9812              LDR      r0,[sp,#0x48]
000078  b110              CBZ      r0,|L4.128|
00007a  9812              LDR      r0,[sp,#0x48]
00007c  f7fffffe          BL       GUI_SetColor
                  |L4.128|
;;;446    			
;;;447    			GUI_SetTextMode(GUI_TM_TRANS);  //透明   GUI_TEXTMODE_NORMAL   //正常
000080  2002              MOVS     r0,#2
000082  f7fffffe          BL       GUI_SetTextMode
;;;448    			
;;;449    			GUI_UC_SetEncodeUTF8();
000086  f7fffffe          BL       GUI_UC_SetEncodeUTF8
;;;450    			
;;;451    			GUI_SetFont(&GUI_FontSONG16); 
00008a  4833              LDR      r0,|L4.344|
00008c  f7fffffe          BL       GUI_SetFont
;;;452    			
;;;453    			if( SGData.d_Font        !=      0x0  )		GUI_SetFont( SGData.d_Font );
000090  9814              LDR      r0,[sp,#0x50]
000092  b110              CBZ      r0,|L4.154|
000094  9814              LDR      r0,[sp,#0x50]
000096  f7fffffe          BL       GUI_SetFont
                  |L4.154|
;;;454    			
;;;455    			fx = (SGData.d_y1 - SGData.d_y  - GUI_GetFontSizeY()) / 2 ;
00009a  f7fffffe          BL       GUI_GetFontSizeY
00009e  f8bd105a          LDRH     r1,[sp,#0x5a]
0000a2  f8bd2056          LDRH     r2,[sp,#0x56]
0000a6  1a89              SUBS     r1,r1,r2
0000a8  1a0e              SUBS     r6,r1,r0
0000aa  eb0670d6          ADD      r0,r6,r6,LSR #31
0000ae  1044              ASRS     r4,r0,#1
;;;456    			
;;;457    			if( fx <= 0 )     fx = 0 ;
0000b0  2c00              CMP      r4,#0
0000b2  dc00              BGT      |L4.182|
0000b4  2400              MOVS     r4,#0
                  |L4.182|
;;;458    			
;;;459    			G_FStr = ( langType == 0 ) ? SGData.f_SName : SGData.f_EName; 
0000b6  f89d0010          LDRB     r0,[sp,#0x10]
0000ba  b908              CBNZ     r0,|L4.192|
0000bc  a808              ADD      r0,sp,#0x20
0000be  e000              B        |L4.194|
                  |L4.192|
0000c0  a80d              ADD      r0,sp,#0x34
                  |L4.194|
0000c2  4605              MOV      r5,r0
;;;460    			
;;;461    			GUI_DispStringAt(G_FStr, SGData.d_x, SGData.d_y + fx);	
0000c4  f8bd0056          LDRH     r0,[sp,#0x56]
0000c8  1902              ADDS     r2,r0,r4
0000ca  f8bd1054          LDRH     r1,[sp,#0x54]
0000ce  4628              MOV      r0,r5
0000d0  f7fffffe          BL       GUI_DispStringAt
;;;462    			
;;;463    		break;
0000d4  e038              B        |L4.328|
;;;464    
;;;465    		case T_Text:
;;;466    		
;;;467    			GUI_SetColor( 0x00ffffff ); 
0000d6  f06f407f          MVN      r0,#0xff000000
0000da  f7fffffe          BL       GUI_SetColor
;;;468    			
;;;469    			if( SGData.d_FColor      !=      0x0 )    GUI_SetColor( SGData.d_FColor );  
0000de  9812              LDR      r0,[sp,#0x48]
0000e0  b110              CBZ      r0,|L4.232|
0000e2  9812              LDR      r0,[sp,#0x48]
0000e4  f7fffffe          BL       GUI_SetColor
                  |L4.232|
;;;470    			
;;;471    			GUI_SetTextMode(GUI_TM_TRANS); 
0000e8  2002              MOVS     r0,#2
0000ea  f7fffffe          BL       GUI_SetTextMode
;;;472    			
;;;473    			GUI_UC_SetEncodeUTF8();
0000ee  f7fffffe          BL       GUI_UC_SetEncodeUTF8
;;;474    			
;;;475    			GUI_SetFont(&GUI_FontSONG16); 
0000f2  4819              LDR      r0,|L4.344|
0000f4  f7fffffe          BL       GUI_SetFont
;;;476    			
;;;477    			if( SGData.d_Font        !=      0x0  )		GUI_SetFont( SGData.d_Font );
0000f8  9814              LDR      r0,[sp,#0x50]
0000fa  b110              CBZ      r0,|L4.258|
0000fc  9814              LDR      r0,[sp,#0x50]
0000fe  f7fffffe          BL       GUI_SetFont
                  |L4.258|
;;;478    			
;;;479    			G_FStr = ( langType == 0 ) ? SGData.f_SName : SGData.f_EName; 
000102  f89d0010          LDRB     r0,[sp,#0x10]
000106  b908              CBNZ     r0,|L4.268|
000108  a808              ADD      r0,sp,#0x20
00010a  e000              B        |L4.270|
                  |L4.268|
00010c  a80d              ADD      r0,sp,#0x34
                  |L4.270|
00010e  4605              MOV      r5,r0
;;;480    			
;;;481    			GUI_DispStringAtCEOL( G_FStr, SGData.d_x, SGData.d_y );  // 覆盖已经存在的
000110  f8bd2056          LDRH     r2,[sp,#0x56]
000114  f8bd1054          LDRH     r1,[sp,#0x54]
000118  4628              MOV      r0,r5
00011a  f7fffffe          BL       GUI_DispStringAtCEOL
;;;482    
;;;483    		break;		
00011e  e013              B        |L4.328|
;;;484    			
;;;485    		
;;;486    		case T_TRect:
;;;487    		
;;;488    			GUI_SetColor(0x00ffffff);
000120  f06f407f          MVN      r0,#0xff000000
000124  f7fffffe          BL       GUI_SetColor
;;;489    			
;;;490    			if( SGData.d_BKColor != 0x0 ) 	GUI_SetColor(SGData.d_BKColor);
000128  9813              LDR      r0,[sp,#0x4c]
00012a  b110              CBZ      r0,|L4.306|
00012c  9813              LDR      r0,[sp,#0x4c]
00012e  f7fffffe          BL       GUI_SetColor
                  |L4.306|
;;;491    			
;;;492    			GUI_FillRect(SGData.d_x, SGData.d_y, SGData.d_x1, SGData.d_y1);   //绘制矩形
000132  f8bd305a          LDRH     r3,[sp,#0x5a]
000136  f8bd2058          LDRH     r2,[sp,#0x58]
00013a  f8bd1056          LDRH     r1,[sp,#0x56]
00013e  f8bd0054          LDRH     r0,[sp,#0x54]
000142  f7fffffe          BL       GUI_FillRect
;;;493    		
;;;494    		break;
000146  bf00              NOP      
                  |L4.328|
000148  bf00              NOP                            ;414
;;;495    	}	
;;;496    }
00014a  bc70              POP      {r4-r6}
00014c  f85dfb14          LDR      pc,[sp],#0x14
;;;497    
                          ENDP

                  |L4.336|
                          DCD      0x00fdf3e6
                  |L4.340|
                          DCD      0x004a4655
                  |L4.344|
                          DCD      GUI_FontSONG16

                          AREA ||i.bush_Graph_StringList||, CODE, READONLY, ALIGN=1

                  bush_Graph_StringList PROC
;;;392    //列表绘制矩形+文本
;;;393    void bush_Graph_StringList(vu8 langType ,struct SGraphData SGList[], int MAX_LEN ){
000000  b577              PUSH     {r0-r2,r4-r6,lr}
000002  b0a1              SUB      sp,sp,#0x84
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;394    	
;;;395    	int i ;
;;;396    	
;;;397    	WM_HWIN hItem;
;;;398    	
;;;399    	for( i = 0 ; i < MAX_LEN ; i++ )
000008  2400              MOVS     r4,#0
00000a  e045              B        |L5.152|
                  |L5.12|
;;;400    
;;;401    		bush_Graph_String( langType , SGList[i] );
00000c  eb0400c4          ADD      r0,r4,r4,LSL #3
000010  eb0501c0          ADD      r1,r5,r0,LSL #3
000014  2234              MOVS     r2,#0x34
000016  a80f              ADD      r0,sp,#0x3c
000018  f7fffffe          BL       __aeabi_memcpy4
00001c  eb0400c4          ADD      r0,r4,r4,LSL #3
000020  eb0500c0          ADD      r0,r5,r0,LSL #3
000024  6b40              LDR      r0,[r0,#0x34]
000026  901c              STR      r0,[sp,#0x70]
000028  eb0400c4          ADD      r0,r4,r4,LSL #3
00002c  eb0500c0          ADD      r0,r5,r0,LSL #3
000030  6b80              LDR      r0,[r0,#0x38]
000032  901d              STR      r0,[sp,#0x74]
000034  eb0400c4          ADD      r0,r4,r4,LSL #3
000038  eb0500c0          ADD      r0,r5,r0,LSL #3
00003c  6bc0              LDR      r0,[r0,#0x3c]
00003e  901e              STR      r0,[sp,#0x78]
000040  eb0400c4          ADD      r0,r4,r4,LSL #3
000044  eb0500c0          ADD      r0,r5,r0,LSL #3
000048  f8b00040          LDRH     r0,[r0,#0x40]
00004c  f8ad007c          STRH     r0,[sp,#0x7c]
000050  eb0400c4          ADD      r0,r4,r4,LSL #3
000054  eb0500c0          ADD      r0,r5,r0,LSL #3
000058  f8b00042          LDRH     r0,[r0,#0x42]
00005c  f8ad007e          STRH     r0,[sp,#0x7e]
000060  eb0400c4          ADD      r0,r4,r4,LSL #3
000064  eb0500c0          ADD      r0,r5,r0,LSL #3
000068  f8b00044          LDRH     r0,[r0,#0x44]
00006c  f8ad0080          STRH     r0,[sp,#0x80]
000070  eb0400c4          ADD      r0,r4,r4,LSL #3
000074  eb0500c0          ADD      r0,r5,r0,LSL #3
000078  f8b00046          LDRH     r0,[r0,#0x46]
00007c  f8ad0082          STRH     r0,[sp,#0x82]
000080  223c              MOVS     r2,#0x3c
000082  a912              ADD      r1,sp,#0x48
000084  4668              MOV      r0,sp
000086  f7fffffe          BL       __aeabi_memcpy4
00008a  f89d0084          LDRB     r0,[sp,#0x84]
00008e  a90f              ADD      r1,sp,#0x3c
000090  c90e              LDM      r1,{r1-r3}
000092  f7fffffe          BL       bush_Graph_String
000096  1c64              ADDS     r4,r4,#1              ;399
                  |L5.152|
000098  42b4              CMP      r4,r6                 ;399
00009a  dbb7              BLT      |L5.12|
;;;402    }
00009c  b024              ADD      sp,sp,#0x90
00009e  bd70              POP      {r4-r6,pc}
;;;403    
                          ENDP


                          AREA ||i.bush_SingleWin||, CODE, READONLY, ALIGN=2

                  bush_SingleWin PROC
;;;343    //单个绘制小工具
;;;344    void bush_SingleWin(vu8 langType ,WM_MESSAGE * pMsg ,struct SListData sData , const GUI_FONT * pNewFont){
000000  b40f              PUSH     {r0-r3}
000002  e92d41f0          PUSH     {r4-r8,lr}
000006  460d              MOV      r5,r1
000008  9c16              LDR      r4,[sp,#0x58]
;;;345    	
;;;346    	WM_HWIN hItem;
;;;347    	
;;;348    	char* W_FStr;
;;;349    	
;;;350    	hItem = WM_GetDialogItem ( pMsg->hWin , sData.d_ID ) ;
00000a  9915              LDR      r1,[sp,#0x54]
00000c  6868              LDR      r0,[r5,#4]
00000e  f7fffffe          BL       WM_GetDialogItem
000012  4607              MOV      r7,r0
;;;351    	
;;;352    	GUI_UC_SetEncodeUTF8();
000014  f7fffffe          BL       GUI_UC_SetEncodeUTF8
;;;353    	
;;;354    	W_FStr = ( langType == 0 ) ? sData.d_SName : sData.d_EName;
000018  f89d0018          LDRB     r0,[sp,#0x18]
00001c  b910              CBNZ     r0,|L6.36|
00001e  f10d0021          ADD      r0,sp,#0x21
000022  e001              B        |L6.40|
                  |L6.36|
000024  f10d0035          ADD      r0,sp,#0x35
                  |L6.40|
000028  4606              MOV      r6,r0
;;;355    	
;;;356    	switch( sData.d_Type ){
00002a  f89d0020          LDRB     r0,[sp,#0x20]
00002e  b110              CBZ      r0,|L6.54|
000030  2802              CMP      r0,#2
000032  d14d              BNE      |L6.208|
000034  e025              B        |L6.130|
                  |L6.54|
;;;357    		
;;;358    		case T_Button:
;;;359    		
;;;360    			BUTTON_SetBkColor(hItem ,0, 0x00f33333);
000036  4a29              LDR      r2,|L6.220|
000038  2100              MOVS     r1,#0
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       BUTTON_SetBkColor
;;;361    			if( sData.d_BKColor != 0x0 ) 	  BUTTON_SetBkColor(hItem ,0, sData.d_BKColor);
000040  9814              LDR      r0,[sp,#0x50]
000042  b120              CBZ      r0,|L6.78|
000044  9a14              LDR      r2,[sp,#0x50]
000046  2100              MOVS     r1,#0
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       BUTTON_SetBkColor
                  |L6.78|
;;;362    			
;;;363    			BUTTON_SetTextColor(hItem , 0,0x00B22222);
00004e  4a24              LDR      r2,|L6.224|
000050  2100              MOVS     r1,#0
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       BUTTON_SetTextColor
;;;364    			if( sData.d_Color   != 0x0 )  	BUTTON_SetTextColor(hItem, 0, sData.d_Color);
000058  9813              LDR      r0,[sp,#0x4c]
00005a  b120              CBZ      r0,|L6.102|
00005c  9a13              LDR      r2,[sp,#0x4c]
00005e  2100              MOVS     r1,#0
000060  4638              MOV      r0,r7
000062  f7fffffe          BL       BUTTON_SetTextColor
                  |L6.102|
;;;365    			
;;;366    			BUTTON_SetFont(hItem, &GUI_FontSONG12);
000066  491f              LDR      r1,|L6.228|
000068  4638              MOV      r0,r7
00006a  f7fffffe          BL       BUTTON_SetFont
;;;367    			if( pNewFont        != 0x0 )  	BUTTON_SetFont(hItem, pNewFont);
00006e  b11c              CBZ      r4,|L6.120|
000070  4621              MOV      r1,r4
000072  4638              MOV      r0,r7
000074  f7fffffe          BL       BUTTON_SetFont
                  |L6.120|
;;;368    			
;;;369    			BUTTON_SetText( hItem , W_FStr );
000078  4631              MOV      r1,r6
00007a  4638              MOV      r0,r7
00007c  f7fffffe          BL       BUTTON_SetText
;;;370    			
;;;371    		break;
000080  e026              B        |L6.208|
                  |L6.130|
;;;372    		
;;;373    		case T_Text:
;;;374    		
;;;375    			TEXT_SetBkColor( hItem ,  0x00FFF8DC);
000082  4919              LDR      r1,|L6.232|
000084  4638              MOV      r0,r7
000086  f7fffffe          BL       TEXT_SetBkColor
;;;376    			if( sData.d_BKColor != 0x0 ) 	TEXT_SetBkColor(hItem , sData.d_BKColor);
00008a  9814              LDR      r0,[sp,#0x50]
00008c  b118              CBZ      r0,|L6.150|
00008e  9914              LDR      r1,[sp,#0x50]
000090  4638              MOV      r0,r7
000092  f7fffffe          BL       TEXT_SetBkColor
                  |L6.150|
;;;377    			
;;;378    			TEXT_SetTextColor(hItem , 0x00ffffff);
000096  f06f417f          MVN      r1,#0xff000000
00009a  4638              MOV      r0,r7
00009c  f7fffffe          BL       TEXT_SetTextColor
;;;379    			if( sData.d_Color   != 0x0 )  	TEXT_SetTextColor(hItem, sData.d_Color);
0000a0  9813              LDR      r0,[sp,#0x4c]
0000a2  b118              CBZ      r0,|L6.172|
0000a4  9913              LDR      r1,[sp,#0x4c]
0000a6  4638              MOV      r0,r7
0000a8  f7fffffe          BL       TEXT_SetTextColor
                  |L6.172|
;;;380    			
;;;381    			TEXT_SetFont(hItem, &GUI_FontSONG16);
0000ac  490f              LDR      r1,|L6.236|
0000ae  4638              MOV      r0,r7
0000b0  f7fffffe          BL       TEXT_SetFont
;;;382    			if( pNewFont        != 0x0 )  	TEXT_SetFont(hItem, pNewFont);
0000b4  b11c              CBZ      r4,|L6.190|
0000b6  4621              MOV      r1,r4
0000b8  4638              MOV      r0,r7
0000ba  f7fffffe          BL       TEXT_SetFont
                  |L6.190|
;;;383    			
;;;384    			TEXT_SetTextAlign( hItem, TEXT_CF_LEFT | TEXT_CF_VCENTER );
0000be  210c              MOVS     r1,#0xc
0000c0  4638              MOV      r0,r7
0000c2  f7fffffe          BL       TEXT_SetTextAlign
;;;385    			
;;;386    			TEXT_SetText(hItem, W_FStr);
0000c6  4631              MOV      r1,r6
0000c8  4638              MOV      r0,r7
0000ca  f7fffffe          BL       TEXT_SetText
;;;387    			
;;;388    		break;
0000ce  bf00              NOP      
                  |L6.208|
0000d0  bf00              NOP                            ;371
;;;389    	}
;;;390    }
0000d2  e8bd01f0          POP      {r4-r8}
0000d6  f85dfb14          LDR      pc,[sp],#0x14
;;;391    
                          ENDP

0000da  0000              DCW      0x0000
                  |L6.220|
                          DCD      0x00f33333
                  |L6.224|
                          DCD      0x00b22222
                  |L6.228|
                          DCD      GUI_FontSONG12
                  |L6.232|
                          DCD      0x00fff8dc
                  |L6.236|
                          DCD      GUI_FontSONG16

                          AREA ||i.bush_WinObj||, CODE, READONLY, ALIGN=1

                  bush_WinObj PROC
;;;331    //列表绘制小工具
;;;332    void bush_WinObj(vu8 langType ,WM_MESSAGE * pMsg ,struct SListData sList[], int MAX_LEN  ){
000000  b5ff              PUSH     {r0-r7,lr}
000002  b09b              SUB      sp,sp,#0x6c
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;333    	
;;;334    	int i ;
;;;335    	WM_HWIN hItem;
;;;336    	
;;;337    	for( i = 0 ; i < MAX_LEN ; i++ )
00000a  2400              MOVS     r4,#0
00000c  e030              B        |L7.112|
                  |L7.14|
;;;338    		
;;;339    		bush_SingleWin( langType, pMsg , sList[i] , 0x0 );
00000e  ebc400c4          RSB      r0,r4,r4,LSL #3
000012  f8150030          LDRB     r0,[r5,r0,LSL #3]
000016  f88d0034          STRB     r0,[sp,#0x34]
00001a  ebc400c4          RSB      r0,r4,r4,LSL #3
00001e  eb0500c0          ADD      r0,r5,r0,LSL #3
000022  1c41              ADDS     r1,r0,#1
000024  222b              MOVS     r2,#0x2b
000026  f10d0035          ADD      r0,sp,#0x35
00002a  f7fffffe          BL       __aeabi_memcpy
00002e  ebc400c4          RSB      r0,r4,r4,LSL #3
000032  eb0500c0          ADD      r0,r5,r0,LSL #3
000036  6ac0              LDR      r0,[r0,#0x2c]
000038  9018              STR      r0,[sp,#0x60]
00003a  ebc400c4          RSB      r0,r4,r4,LSL #3
00003e  eb0500c0          ADD      r0,r5,r0,LSL #3
000042  6b00              LDR      r0,[r0,#0x30]
000044  9019              STR      r0,[sp,#0x64]
000046  ebc400c4          RSB      r0,r4,r4,LSL #3
00004a  eb0500c0          ADD      r0,r5,r0,LSL #3
00004e  6b40              LDR      r0,[r0,#0x34]
000050  901a              STR      r0,[sp,#0x68]
000052  2000              MOVS     r0,#0
000054  2230              MOVS     r2,#0x30
000056  a90f              ADD      r1,sp,#0x3c
000058  900c              STR      r0,[sp,#0x30]
00005a  4668              MOV      r0,sp
00005c  f7fffffe          BL       __aeabi_memcpy4
000060  4639              MOV      r1,r7
000062  f89d006c          LDRB     r0,[sp,#0x6c]
000066  e9dd230d          LDRD     r2,r3,[sp,#0x34]
00006a  f7fffffe          BL       bush_SingleWin
00006e  1c64              ADDS     r4,r4,#1              ;337
                  |L7.112|
000070  42b4              CMP      r4,r6                 ;337
000072  dbcc              BLT      |L7.14|
;;;340    
;;;341    }
000074  b01f              ADD      sp,sp,#0x7c
000076  bdf0              POP      {r4-r7,pc}
;;;342    
                          ENDP


                          AREA ||i.dot_Loc_isNull||, CODE, READONLY, ALIGN=1

                  dot_Loc_isNull PROC
;;;1175   int dot_Loc_isNull(char *_Char, int _Len);
;;;1176   int dot_Loc_isNull(char *_Char, int _Len){
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;1177   	
;;;1178   	int dot_loc = 1024;
000006  f44f6080          MOV      r0,#0x400
;;;1179   	
;;;1180   	int i = 0;
00000a  2100              MOVS     r1,#0
;;;1181   	
;;;1182   	for( i = 0; i < _Len; i++ ){
00000c  bf00              NOP      
00000e  e005              B        |L8.28|
                  |L8.16|
;;;1183   		
;;;1184   		if( _Char[i] == 0x2e ){
000010  5c54              LDRB     r4,[r2,r1]
000012  2c2e              CMP      r4,#0x2e
000014  d101              BNE      |L8.26|
;;;1185   			
;;;1186   			dot_loc = i;
000016  4608              MOV      r0,r1
;;;1187   			
;;;1188   			break;
000018  e002              B        |L8.32|
                  |L8.26|
00001a  1c49              ADDS     r1,r1,#1              ;1182
                  |L8.28|
00001c  4299              CMP      r1,r3                 ;1182
00001e  dbf7              BLT      |L8.16|
                  |L8.32|
000020  bf00              NOP      
;;;1189   		}	
;;;1190   	}
;;;1191   	
;;;1192   	return dot_loc;
;;;1193   	
;;;1194   }
000022  bd10              POP      {r4,pc}
;;;1195   
                          ENDP


                          AREA ||i.focus_FunLocation||, CODE, READONLY, ALIGN=2

                  focus_FunLocation PROC
;;;34     //  获取当前焦点的顺序值  
;;;35     int *focus_FunLocation( struct SGraphData dList[], int dlen, const int fList[], int flen ){
000000  b5fc              PUSH     {r2-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;36     
;;;37     	int i, j;
;;;38     	int focus_loc[] = { 1024, 1024 };   //焦点  1. 数据列表中的位置   2. 焦点列表中的位置
000008  4f1b              LDR      r7,|L9.120|
00000a  cf81              LDM      r7,{r0,r7}
00000c  e9cd0700          STRD     r0,r7,[sp,#0]
;;;39     	
;;;40     	for( i = 0; i < dlen; i++ )
000010  2100              MOVS     r1,#0
000012  e02c              B        |L9.110|
                  |L9.20|
;;;41     	{
;;;42     		if( dList[i].focusType == 1 && (dList[i].t_Type == T_THref || dList[i].t_Type == T_TLISTBOX) )
000014  eb0100c1          ADD      r0,r1,r1,LSL #3
000018  eb0400c0          ADD      r0,r4,r0,LSL #3
00001c  6840              LDR      r0,[r0,#4]
00001e  2801              CMP      r0,#1
000020  d121              BNE      |L9.102|
000022  eb0100c1          ADD      r0,r1,r1,LSL #3
000026  eb0400c0          ADD      r0,r4,r0,LSL #3
00002a  6880              LDR      r0,[r0,#8]
00002c  2801              CMP      r0,#1
00002e  d006              BEQ      |L9.62|
000030  eb0100c1          ADD      r0,r1,r1,LSL #3
000034  eb0400c0          ADD      r0,r4,r0,LSL #3
000038  6880              LDR      r0,[r0,#8]
00003a  2803              CMP      r0,#3
00003c  d113              BNE      |L9.102|
                  |L9.62|
;;;43     		{	
;;;44     			for( j = 0; j < flen; j++)
00003e  2200              MOVS     r2,#0
000040  e00e              B        |L9.96|
                  |L9.66|
;;;45     			{		
;;;46     				if( fList[j] == dList[i].d_ID )
000042  f8560022          LDR      r0,[r6,r2,LSL #2]
000046  eb0107c1          ADD      r7,r1,r1,LSL #3
00004a  f8547037          LDR      r7,[r4,r7,LSL #3]
00004e  42b8              CMP      r0,r7
000050  d102              BNE      |L9.88|
;;;47     				{
;;;48     						
;;;49     					focus_loc[0] = i;  		//存在焦点  获取在数据列表中的排序
000052  9100              STR      r1,[sp,#0]
;;;50     						
;;;51     					focus_loc[1] = j;   	//          获取在焦点列表中的排序
000054  9201              STR      r2,[sp,#4]
;;;52     						
;;;53     					goto focus_break;
000056  e00d              B        |L9.116|
                  |L9.88|
;;;54     					
;;;55     				}
;;;56     				else
;;;57     					
;;;58     					focus_loc[1] = 404; 	//存在焦点  焦点列表中不存在	
000058  f44f70ca          MOV      r0,#0x194
00005c  9001              STR      r0,[sp,#4]
00005e  1c52              ADDS     r2,r2,#1              ;44
                  |L9.96|
000060  429a              CMP      r2,r3                 ;44
000062  dbee              BLT      |L9.66|
000064  e002              B        |L9.108|
                  |L9.102|
;;;59     			}
;;;60     		}
;;;61     		else
;;;62     				
;;;63     			focus_loc[0] = 404;   			//数据列表中无焦点
000066  f44f70ca          MOV      r0,#0x194
00006a  9000              STR      r0,[sp,#0]
                  |L9.108|
00006c  1c49              ADDS     r1,r1,#1              ;40
                  |L9.110|
00006e  42a9              CMP      r1,r5                 ;40
000070  dbd0              BLT      |L9.20|
;;;64     	}
;;;65     	focus_break:
000072  bf00              NOP      
                  |L9.116|
;;;66     	
;;;67     		return focus_loc;
000074  4668              MOV      r0,sp
;;;68     }
000076  bdfc              POP      {r2-r7,pc}
;;;69     
                          ENDP

                  |L9.120|
                          DCD      ||.constdata||+0x54

                          AREA ||i.get_id_index||, CODE, READONLY, ALIGN=2

                  get_id_index PROC
;;;80     */
;;;81     int *get_id_index( struct SGraphData temp_dList[], int dataLen)
000000  b51c              PUSH     {r2-r4,lr}
;;;82     {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;83     	int id_index[] = { 0X194 , 0 };
000006  4c13              LDR      r4,|L10.84|
000008  cc11              LDM      r4,{r0,r4}
00000a  e9cd0400          STRD     r0,r4,[sp,#0]
;;;84     	
;;;85     	int i = 0;
00000e  2100              MOVS     r1,#0
;;;86     
;;;87     	for( i = 0; i < dataLen; i++ )
000010  bf00              NOP      
000012  e01b              B        |L10.76|
                  |L10.20|
;;;88     	{
;;;89     		if( ( temp_dList[i].focusType == 1 ) && ( temp_dList[i].t_Type == T_THref || temp_dList[i].t_Type == T_TLISTBOX ) )
000014  eb0100c1          ADD      r0,r1,r1,LSL #3
000018  eb0200c0          ADD      r0,r2,r0,LSL #3
00001c  6840              LDR      r0,[r0,#4]
00001e  2801              CMP      r0,#1
000020  d113              BNE      |L10.74|
000022  eb0100c1          ADD      r0,r1,r1,LSL #3
000026  eb0200c0          ADD      r0,r2,r0,LSL #3
00002a  6880              LDR      r0,[r0,#8]
00002c  2801              CMP      r0,#1
00002e  d006              BEQ      |L10.62|
000030  eb0100c1          ADD      r0,r1,r1,LSL #3
000034  eb0200c0          ADD      r0,r2,r0,LSL #3
000038  6880              LDR      r0,[r0,#8]
00003a  2803              CMP      r0,#3
00003c  d105              BNE      |L10.74|
                  |L10.62|
;;;90     		{	
;;;91     			id_index[0] = temp_dList[i].d_ID;	
00003e  eb0100c1          ADD      r0,r1,r1,LSL #3
000042  f8520030          LDR      r0,[r2,r0,LSL #3]
000046  9000              STR      r0,[sp,#0]
;;;92     			id_index[1] = i;
000048  9101              STR      r1,[sp,#4]
                  |L10.74|
00004a  1c49              ADDS     r1,r1,#1              ;87
                  |L10.76|
00004c  4299              CMP      r1,r3                 ;87
00004e  dbe1              BLT      |L10.20|
;;;93     		}		
;;;94     	}
;;;95     
;;;96     	return id_index;
000050  4668              MOV      r0,sp
;;;97     }
000052  bd1c              POP      {r2-r4,pc}
;;;98     
                          ENDP

                  |L10.84|
                          DCD      ||.constdata||+0x5c

                          AREA ||i.get_nextindex||, CODE, READONLY, ALIGN=2

                  get_nextindex PROC
;;;144    */
;;;145    int get_nextindex( int id, const int idList[], int handle )
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;146    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;147    	int i = 0, x = 0 ,y = 0, old_x = 0;
00000a  2500              MOVS     r5,#0
00000c  2100              MOVS     r1,#0
00000e  2200              MOVS     r2,#0
000010  4689              MOV      r9,r1
;;;148    	
;;;149    	int next_id = 0XFF;    
000012  20ff              MOVS     r0,#0xff
000014  9001              STR      r0,[sp,#4]
;;;150    	
;;;151    	int isWin = 0, isNumNull = 0, winIndex = 0; 
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
00001a  4684              MOV      r12,r0
00001c  4682              MOV      r10,r0
;;;152    	
;;;153    	int _c = 0, _l = 0;
00001e  2300              MOVS     r3,#0
000020  2700              MOVS     r7,#0
;;;154    
;;;155    	int dlen = sizeof(winList)/sizeof(winList[0]);
000022  f04f0b07          MOV      r11,#7
;;;156    	
;;;157    	for( i = 0; i < dlen; i++ )
000026  bf00              NOP      
000028  e00f              B        |L11.74|
                  |L11.42|
;;;158    	{
;;;159    		if( FLAG_WIN == winList[i].winFlag)
00002a  eb050045          ADD      r0,r5,r5,LSL #1
00002e  f8dfe214          LDR      lr,|L11.580|
000032  f85e0020          LDR      r0,[lr,r0,LSL #2]
000036  f8dfe210          LDR      lr,|L11.584|
00003a  f89ee000          LDRB     lr,[lr,#0]  ; FLAG_WIN
00003e  4570              CMP      r0,lr
000040  d102              BNE      |L11.72|
;;;160    		{	
;;;161    			isWin = 1;	
000042  2001              MOVS     r0,#1
000044  9000              STR      r0,[sp,#0]
;;;162    			
;;;163    			winIndex = i; 			
000046  46aa              MOV      r10,r5
                  |L11.72|
000048  1c6d              ADDS     r5,r5,#1              ;157
                  |L11.74|
00004a  455d              CMP      r5,r11                ;157
00004c  dbed              BLT      |L11.42|
;;;164    		}	
;;;165    	}	
;;;166    	if( isWin )
00004e  9800              LDR      r0,[sp,#0]
000050  2800              CMP      r0,#0
000052  d074              BEQ      |L11.318|
;;;167    	{
;;;168    		i = 0;
000054  2500              MOVS     r5,#0
;;;169    		
;;;170    		_c = winList[winIndex].Columns; //列数
000056  eb0a004a          ADD      r0,r10,r10,LSL #1
00005a  f8dfe1e8          LDR      lr,|L11.580|
00005e  eb0e0080          ADD      r0,lr,r0,LSL #2
000062  6883              LDR      r3,[r0,#8]
;;;171    		
;;;172    		_l = winList[winIndex].Lines;  //行数
000064  eb0a004a          ADD      r0,r10,r10,LSL #1
000068  eb0e0080          ADD      r0,lr,r0,LSL #2
00006c  6847              LDR      r7,[r0,#4]
;;;173    		
;;;174    		while(1)
00006e  e00f              B        |L11.144|
                  |L11.112|
;;;175    		{
;;;176    			if( id == idList[i] )
000070  f8540025          LDR      r0,[r4,r5,LSL #2]
000074  4540              CMP      r0,r8
000076  d100              BNE      |L11.122|
;;;177    				
;;;178    				break;
000078  e00b              B        |L11.146|
                  |L11.122|
;;;179    			
;;;180    			y++;
00007a  1c52              ADDS     r2,r2,#1
;;;181    			i++;
00007c  1c6d              ADDS     r5,r5,#1
;;;182    			
;;;183    			if( y == _c )
00007e  429a              CMP      r2,r3
000080  d101              BNE      |L11.134|
;;;184    			{				
;;;185    				y = 0;
000082  2200              MOVS     r2,#0
;;;186    				x++;
000084  1c49              ADDS     r1,r1,#1
                  |L11.134|
;;;187    			}	
;;;188    			if( x == _l )
000086  42b9              CMP      r1,r7
000088  d102              BNE      |L11.144|
;;;189    			{
;;;190    				x = 0XFF;
00008a  21ff              MOVS     r1,#0xff
;;;191    				y = 0XFF;
00008c  22ff              MOVS     r2,#0xff
;;;192    				break;
00008e  e000              B        |L11.146|
                  |L11.144|
000090  e7ee              B        |L11.112|
                  |L11.146|
000092  bf00              NOP                            ;178
;;;193    			}	
;;;194    		}
;;;195    		if( x == 0XFF || y == 0XFF )
000094  29ff              CMP      r1,#0xff
000096  d001              BEQ      |L11.156|
000098  2aff              CMP      r2,#0xff
00009a  d102              BNE      |L11.162|
                  |L11.156|
;;;196    			
;;;197    			return next_id;
00009c  9801              LDR      r0,[sp,#4]
                  |L11.158|
;;;198    		
;;;199    		i = 0;
;;;200    		while(1)
;;;201    		{
;;;202    			if( ( i / _c ) < _l && ( handle == 8 || handle == 2 ) )
;;;203    			{	
;;;204    				if( i % _c == 0 )
;;;205    
;;;206    					isNumNull += ( idList[ ( (i / _c) * _c ) + y ] ) == 0 ? 1 : 0;
;;;207    				
;;;208    			}
;;;209    			if( handle == 4 || handle == 6 )
;;;210    			
;;;211    				isNumNull += idList[i] == 0 ? 1 : 0;
;;;212    			
;;;213    			i++;
;;;214    			
;;;215    			if( ( i > ( _l - 1 ) * _c + y ) && ( handle == 8 || handle == 2 )  )
;;;216    			{
;;;217    				if( isNumNull >= _l - 1 )
;;;218    					
;;;219    					return id;
;;;220    				else	
;;;221    					
;;;222    					break;
;;;223    			}
;;;224    			if( isNumNull >= ( _l - 1 ) * _c + _c - 1 )
;;;225    				
;;;226    				return id;
;;;227    			
;;;228    			else
;;;229    				
;;;230    				break;
;;;231    			
;;;232    		}
;;;233    		while(1)
;;;234    		{
;;;235    			if( handle == 8 )
;;;236    			{
;;;237    				while( 1 )
;;;238    				{
;;;239    					if( x == 0)
;;;240    					
;;;241    						x = _l - 1;
;;;242    							
;;;243    					else
;;;244    							
;;;245    						x--;
;;;246    					
;;;247    					if( idList[x * _c + y] != 0  )		break;		
;;;248    				}
;;;249    				
;;;250    			}
;;;251    			if( handle == 2 )
;;;252    			{	
;;;253    				while( 1 )
;;;254    				{
;;;255    					if( x == _l - 1 )
;;;256    						
;;;257    						x = 0;
;;;258    					
;;;259    					else
;;;260    							
;;;261    						x++;
;;;262    					
;;;263    					if( idList[x * _c + y] != 0  )		break;
;;;264    				}	
;;;265    			}	
;;;266    			if( handle == 4 )
;;;267    			{
;;;268    				old_x = x; //存储原始行数值
;;;269    				
;;;270    				while( 1 )
;;;271    				{	
;;;272    					if( y == 0 )
;;;273    					{		
;;;274    						x--;	
;;;275    							
;;;276    						y = _c - 1;
;;;277    					}		
;;;278    					else	
;;;279    							
;;;280    						y--;
;;;281    							
;;;282    					if( y == _c - 1 && idList[x * _c + y] != 0)  //换行后判断数值  
;;;283    									
;;;284    						break;
;;;285    							
;;;286    					else     //为零  则更改行值
;;;287    								
;;;288    						old_x = x;
;;;289    						
;;;290    					if( y != _c - 1 && x == old_x &&  idList[x * _c + y] != idList[x * _c + y + 1] && idList[x * _c + y] != 0  )   //同一行判断数值
;;;291    								
;;;292    						break;		
;;;293    				}
;;;294    			}	
;;;295    			if( handle == 6 )
;;;296    			{
;;;297    				old_x = x;
;;;298    
;;;299    				while( 1 )
;;;300    				{	
;;;301    					if( y == _c - 1)
;;;302    					{	
;;;303    						x++;
;;;304    						
;;;305    						y = 0;
;;;306    					}
;;;307    					else
;;;308    						y++;
;;;309    					
;;;310    					if( y == 0 && idList[x * _c + y] != 0)  //换行后判断数值  
;;;311    									
;;;312    						break;
;;;313    							
;;;314    					else     //为零  则更改行值
;;;315    								
;;;316    						old_x = x;
;;;317    						
;;;318    					if( y != 0 && x == old_x &&  idList[x * _c + y] != idList[x * _c + y - 1] && idList[x * _c + y] != 0  )   //同一行判断数值
;;;319    								
;;;320    						break;		
;;;321    				}
;;;322    			}	
;;;323    			if( idList[ x  * _c + y] != 0xFF || idList[x * _c + y] == id || idList[x * _c + y] != 0 )	
;;;324    				
;;;325    				return idList[ x * _c + y];
;;;326    		}
;;;327    	}
;;;328    	return next_id;
;;;329    }
00009e  e8bd8ffc          POP      {r2-r11,pc}
                  |L11.162|
0000a2  2500              MOVS     r5,#0                 ;199
0000a4  e03b              B        |L11.286|
                  |L11.166|
0000a6  fb95f0f3          SDIV     r0,r5,r3              ;202
0000aa  42b8              CMP      r0,r7                 ;202
0000ac  da13              BGE      |L11.214|
0000ae  2e08              CMP      r6,#8                 ;202
0000b0  d001              BEQ      |L11.182|
0000b2  2e02              CMP      r6,#2                 ;202
0000b4  d10f              BNE      |L11.214|
                  |L11.182|
0000b6  fb95f0f3          SDIV     r0,r5,r3              ;204
0000ba  fb035010          MLS      r0,r3,r0,r5           ;204
0000be  b950              CBNZ     r0,|L11.214|
0000c0  fb95f0f3          SDIV     r0,r5,r3              ;206
0000c4  fb002003          MLA      r0,r0,r3,r2           ;206
0000c8  f8540020          LDR      r0,[r4,r0,LSL #2]     ;206
0000cc  b908              CBNZ     r0,|L11.210|
0000ce  2001              MOVS     r0,#1                 ;206
0000d0  e000              B        |L11.212|
                  |L11.210|
0000d2  2000              MOVS     r0,#0                 ;206
                  |L11.212|
0000d4  4484              ADD      r12,r12,r0            ;206
                  |L11.214|
0000d6  2e04              CMP      r6,#4                 ;209
0000d8  d001              BEQ      |L11.222|
0000da  2e06              CMP      r6,#6                 ;209
0000dc  d106              BNE      |L11.236|
                  |L11.222|
0000de  f8540025          LDR      r0,[r4,r5,LSL #2]     ;211
0000e2  b908              CBNZ     r0,|L11.232|
0000e4  2001              MOVS     r0,#1                 ;211
0000e6  e000              B        |L11.234|
                  |L11.232|
0000e8  2000              MOVS     r0,#0                 ;211
                  |L11.234|
0000ea  4484              ADD      r12,r12,r0            ;211
                  |L11.236|
0000ec  1c6d              ADDS     r5,r5,#1              ;213
0000ee  1e78              SUBS     r0,r7,#1              ;215
0000f0  fb002003          MLA      r0,r0,r3,r2           ;215
0000f4  42a8              CMP      r0,r5                 ;215
0000f6  da09              BGE      |L11.268|
0000f8  2e08              CMP      r6,#8                 ;215
0000fa  d001              BEQ      |L11.256|
0000fc  2e02              CMP      r6,#2                 ;215
0000fe  d105              BNE      |L11.268|
                  |L11.256|
000100  1e78              SUBS     r0,r7,#1              ;217
000102  4560              CMP      r0,r12                ;217
000104  dc01              BGT      |L11.266|
000106  4640              MOV      r0,r8                 ;219
000108  e7c9              B        |L11.158|
                  |L11.266|
00010a  e009              B        |L11.288|
                  |L11.268|
00010c  1e78              SUBS     r0,r7,#1              ;224
00010e  fb003003          MLA      r0,r0,r3,r3           ;224
000112  1e40              SUBS     r0,r0,#1              ;224
000114  4560              CMP      r0,r12                ;224
000116  dc01              BGT      |L11.284|
000118  4640              MOV      r0,r8                 ;226
00011a  e7c0              B        |L11.158|
                  |L11.284|
00011c  e000              B        |L11.288|
                  |L11.286|
00011e  e7c2              B        |L11.166|
                  |L11.288|
000120  bf00              NOP                            ;222
000122  e08c              B        |L11.574|
                  |L11.292|
000124  2e08              CMP      r6,#8                 ;235
000126  d10d              BNE      |L11.324|
000128  e00a              B        |L11.320|
                  |L11.298|
00012a  b909              CBNZ     r1,|L11.304|
00012c  1e79              SUBS     r1,r7,#1              ;241
00012e  e000              B        |L11.306|
                  |L11.304|
000130  1e49              SUBS     r1,r1,#1              ;245
                  |L11.306|
000132  fb012003          MLA      r0,r1,r3,r2           ;247
000136  f8540020          LDR      r0,[r4,r0,LSL #2]     ;247
00013a  b108              CBZ      r0,|L11.320|
00013c  e001              B        |L11.322|
                  |L11.318|
00013e  e07f              B        |L11.576|
                  |L11.320|
000140  e7f3              B        |L11.298|
                  |L11.322|
000142  bf00              NOP                            ;247
                  |L11.324|
000144  2e02              CMP      r6,#2                 ;251
000146  d10e              BNE      |L11.358|
000148  e00b              B        |L11.354|
                  |L11.330|
00014a  1e78              SUBS     r0,r7,#1              ;255
00014c  4288              CMP      r0,r1                 ;255
00014e  d101              BNE      |L11.340|
000150  2100              MOVS     r1,#0                 ;257
000152  e000              B        |L11.342|
                  |L11.340|
000154  1c49              ADDS     r1,r1,#1              ;261
                  |L11.342|
000156  fb012003          MLA      r0,r1,r3,r2           ;263
00015a  f8540020          LDR      r0,[r4,r0,LSL #2]     ;263
00015e  b100              CBZ      r0,|L11.354|
000160  e000              B        |L11.356|
                  |L11.354|
000162  e7f2              B        |L11.330|
                  |L11.356|
000164  bf00              NOP                            ;263
                  |L11.358|
000166  2e04              CMP      r6,#4                 ;266
000168  d129              BNE      |L11.446|
00016a  4689              MOV      r9,r1                 ;268
00016c  e025              B        |L11.442|
                  |L11.366|
00016e  b912              CBNZ     r2,|L11.374|
000170  1e49              SUBS     r1,r1,#1              ;274
000172  1e5a              SUBS     r2,r3,#1              ;276
000174  e000              B        |L11.376|
                  |L11.374|
000176  1e52              SUBS     r2,r2,#1              ;280
                  |L11.376|
000178  1e58              SUBS     r0,r3,#1              ;282
00017a  4290              CMP      r0,r2                 ;282
00017c  d105              BNE      |L11.394|
00017e  fb012003          MLA      r0,r1,r3,r2           ;282
000182  f8540020          LDR      r0,[r4,r0,LSL #2]     ;282
000186  b100              CBZ      r0,|L11.394|
000188  e018              B        |L11.444|
                  |L11.394|
00018a  4689              MOV      r9,r1                 ;288
00018c  1e58              SUBS     r0,r3,#1              ;290
00018e  4290              CMP      r0,r2                 ;290
000190  d013              BEQ      |L11.442|
000192  4549              CMP      r1,r9                 ;290
000194  d111              BNE      |L11.442|
000196  fb012003          MLA      r0,r1,r3,r2           ;290
00019a  f8540020          LDR      r0,[r4,r0,LSL #2]     ;290
00019e  fb012e03          MLA      lr,r1,r3,r2           ;290
0001a2  f10e0e01          ADD      lr,lr,#1              ;290
0001a6  f854e02e          LDR      lr,[r4,lr,LSL #2]     ;290
0001aa  4570              CMP      r0,lr                 ;290
0001ac  d005              BEQ      |L11.442|
0001ae  fb012003          MLA      r0,r1,r3,r2           ;290
0001b2  f8540020          LDR      r0,[r4,r0,LSL #2]     ;290
0001b6  b100              CBZ      r0,|L11.442|
0001b8  e000              B        |L11.444|
                  |L11.442|
0001ba  e7d8              B        |L11.366|
                  |L11.444|
0001bc  bf00              NOP                            ;284
                  |L11.446|
0001be  2e06              CMP      r6,#6                 ;295
0001c0  d127              BNE      |L11.530|
0001c2  4689              MOV      r9,r1                 ;297
0001c4  e023              B        |L11.526|
                  |L11.454|
0001c6  1e58              SUBS     r0,r3,#1              ;301
0001c8  4290              CMP      r0,r2                 ;301
0001ca  d102              BNE      |L11.466|
0001cc  1c49              ADDS     r1,r1,#1              ;303
0001ce  2200              MOVS     r2,#0                 ;305
0001d0  e000              B        |L11.468|
                  |L11.466|
0001d2  1c52              ADDS     r2,r2,#1              ;308
                  |L11.468|
0001d4  b92a              CBNZ     r2,|L11.482|
0001d6  fb012003          MLA      r0,r1,r3,r2           ;310
0001da  f8540020          LDR      r0,[r4,r0,LSL #2]     ;310
0001de  b100              CBZ      r0,|L11.482|
0001e0  e016              B        |L11.528|
                  |L11.482|
0001e2  4689              MOV      r9,r1                 ;316
0001e4  b19a              CBZ      r2,|L11.526|
0001e6  4549              CMP      r1,r9                 ;318
0001e8  d111              BNE      |L11.526|
0001ea  fb012003          MLA      r0,r1,r3,r2           ;318
0001ee  f8540020          LDR      r0,[r4,r0,LSL #2]     ;318
0001f2  fb012e03          MLA      lr,r1,r3,r2           ;318
0001f6  f1ae0e01          SUB      lr,lr,#1              ;318
0001fa  f854e02e          LDR      lr,[r4,lr,LSL #2]     ;318
0001fe  4570              CMP      r0,lr                 ;318
000200  d005              BEQ      |L11.526|
000202  fb012003          MLA      r0,r1,r3,r2           ;318
000206  f8540020          LDR      r0,[r4,r0,LSL #2]     ;318
00020a  b100              CBZ      r0,|L11.526|
00020c  e000              B        |L11.528|
                  |L11.526|
00020e  e7da              B        |L11.454|
                  |L11.528|
000210  bf00              NOP                            ;312
                  |L11.530|
000212  fb012003          MLA      r0,r1,r3,r2           ;323
000216  f8540020          LDR      r0,[r4,r0,LSL #2]     ;323
00021a  28ff              CMP      r0,#0xff              ;323
00021c  d10a              BNE      |L11.564|
00021e  fb012003          MLA      r0,r1,r3,r2           ;323
000222  f8540020          LDR      r0,[r4,r0,LSL #2]     ;323
000226  4540              CMP      r0,r8                 ;323
000228  d004              BEQ      |L11.564|
00022a  fb012003          MLA      r0,r1,r3,r2           ;323
00022e  f8540020          LDR      r0,[r4,r0,LSL #2]     ;323
000232  b120              CBZ      r0,|L11.574|
                  |L11.564|
000234  fb012003          MLA      r0,r1,r3,r2           ;325
000238  f8540020          LDR      r0,[r4,r0,LSL #2]     ;325
00023c  e72f              B        |L11.158|
                  |L11.574|
00023e  e771              B        |L11.292|
                  |L11.576|
000240  9801              LDR      r0,[sp,#4]            ;328
000242  e72c              B        |L11.158|
;;;330    
                          ENDP

                  |L11.580|
                          DCD      winList
                  |L11.584|
                          DCD      FLAG_WIN

                          AREA ||i.set_sgraphdata||, CODE, READONLY, ALIGN=1

                  set_sgraphdata PROC
;;;112    
;;;113    struct SGraphData set_sgraphdata( char _type, struct SGraphData *_old_Data,void *_t_data )
000000  b5f0              PUSH     {r4-r7,lr}
;;;114    {
000002  b093              SUB      sp,sp,#0x4c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;115    	struct SGraphData _set_Data;
;;;116    	
;;;117    	switch(_type)
00000c  2d41              CMP      r5,#0x41
00000e  d002              BEQ      |L12.22|
000010  2d42              CMP      r5,#0x42
000012  d102              BNE      |L12.26|
000014  e000              B        |L12.24|
                  |L12.22|
;;;118    	{
;;;119    		case 'A':
;;;120    			
;;;121    		break;
000016  e000              B        |L12.26|
                  |L12.24|
;;;122    		case 'B':
;;;123    			
;;;124    		
;;;125    		break;
000018  bf00              NOP      
                  |L12.26|
00001a  bf00              NOP                            ;121
;;;126    	}
;;;127    	
;;;128    	
;;;129    	return _set_Data;
00001c  2234              MOVS     r2,#0x34
00001e  a901              ADD      r1,sp,#4
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       __aeabi_memcpy4
000026  980e              LDR      r0,[sp,#0x38]
000028  f8440f34          STR      r0,[r4,#0x34]!
00002c  980f              LDR      r0,[sp,#0x3c]
00002e  6060              STR      r0,[r4,#4]
000030  9810              LDR      r0,[sp,#0x40]
000032  60a0              STR      r0,[r4,#8]
000034  f8bd0044          LDRH     r0,[sp,#0x44]
000038  81a0              STRH     r0,[r4,#0xc]
00003a  f8bd0046          LDRH     r0,[sp,#0x46]
00003e  81e0              STRH     r0,[r4,#0xe]
000040  f8bd0048          LDRH     r0,[sp,#0x48]
000044  8220              STRH     r0,[r4,#0x10]
000046  f8bd004a          LDRH     r0,[sp,#0x4a]
00004a  8260              STRH     r0,[r4,#0x12]
00004c  3c34              SUBS     r4,r4,#0x34
;;;130    }
00004e  b013              ADD      sp,sp,#0x4c
000050  bdf0              POP      {r4-r7,pc}
;;;131    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  CLists
                          %        280
                  displayStr
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  winList
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000002
                          DCD      0x00000001
                          DCD      0x00000003
                          DCD      0x00000007
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x00000002
                          DCD      0x00000006
                          DCD      0x00000002
                          DCD      0x00000003
                          DCD      0x00000400
                          DCD      0x00000400
                          DCD      0x00000194
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=0

                  FLAG_FIRSTWIN
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\APP\\sysflag.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_sysflag_c_a63d2f31____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_sysflag_c_a63d2f31____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_sysflag_c_a63d2f31____REVSH|
#line 144
|__asm___9_sysflag_c_a63d2f31____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
