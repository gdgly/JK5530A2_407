; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\ad7689.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\ad7689.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\ad7689.crf --no_multibyte_chars ..\drive\AD7689.c]
                          THUMB

                          AREA ||i.AD7689_Delay||, CODE, READONLY, ALIGN=1

                  AD7689_Delay PROC
;;;110    /************************************************************************/
;;;111    void AD7689_Delay(void)
000000  b508              PUSH     {r3,lr}
;;;112    {
;;;113    	vu16 count ;
;;;114      for(count = 1000; count != 0; count--);
000002  f44f707a          MOV      r0,#0x3e8
000006  9000              STR      r0,[sp,#0]
000008  e004              B        |L1.20|
                  |L1.10|
00000a  f8bd0000          LDRH     r0,[sp,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  b280              UXTH     r0,r0
000012  9000              STR      r0,[sp,#0]
                  |L1.20|
000014  f8bd0000          LDRH     r0,[sp,#0]
000018  2800              CMP      r0,#0
00001a  d1f6              BNE      |L1.10|
;;;115    }
00001c  bd08              POP      {r3,pc}
;;;116    void AD7689_Delay1(void)
                          ENDP


                          AREA ||i.AD7689_Delay1||, CODE, READONLY, ALIGN=1

                  AD7689_Delay1 PROC
;;;115    }
;;;116    void AD7689_Delay1(void)
000000  b508              PUSH     {r3,lr}
;;;117    {
;;;118    	vu16 count ;
;;;119      for(count = 1000; count != 0; count--);
000002  f44f707a          MOV      r0,#0x3e8
000006  9000              STR      r0,[sp,#0]
000008  e004              B        |L2.20|
                  |L2.10|
00000a  f8bd0000          LDRH     r0,[sp,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  b280              UXTH     r0,r0
000012  9000              STR      r0,[sp,#0]
                  |L2.20|
000014  f8bd0000          LDRH     r0,[sp,#0]
000018  2800              CMP      r0,#0
00001a  d1f6              BNE      |L2.10|
;;;120    }
00001c  bd08              POP      {r3,pc}
;;;121    void AD7689_Scan_CH(void)
                          ENDP


                          AREA ||i.AD7689_InitializeSPI1||, CODE, READONLY, ALIGN=2

                  AD7689_InitializeSPI1 PROC
;;;26     void Bubble_sort(vu16 *D_temp,vu8 num);
;;;27     void AD7689_InitializeSPI1(void)
000000  b500              PUSH     {lr}
;;;28     {
000002  b087              SUB      sp,sp,#0x1c
;;;29     	GPIO_InitTypeDef GPIO_InitStructure;
;;;30       SPI_InitTypeDef  SPI_InitStructure;
;;;31       /*!< SD_SPI_CS_GPIO, SD_SPI_MOSI_GPIO, SD_SPI_MISO_GPIO, SD_SPI_DETECT_GPIO 
;;;32            and SD_SPI_SCK_GPIO Periph clock enable 
;;;33     	// 	 RCC_AHBPeriphClockCmd(FLASH_CS_PIN_SCK|FLASH_SCK_PIN_SCK|FLASH_MISO_PIN_SCK | FLASH_MOSI_PIN_SCK, ENABLE);
;;;34       !< SD_SPI Periph clock enable */
;;;35     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);
000004  2101              MOVS     r1,#1
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;36     	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
00000c  2002              MOVS     r0,#2
00000e  f88d0019          STRB     r0,[sp,#0x19]
;;;37     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000012  2001              MOVS     r0,#1
000014  f88d0018          STRB     r0,[sp,#0x18]
;;;38     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000018  2000              MOVS     r0,#0
00001a  f88d001a          STRB     r0,[sp,#0x1a]
;;;39     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//inv
00001e  2004              MOVS     r0,#4
000020  9005              STR      r0,[sp,#0x14]
;;;40     	GPIO_Init(GPIOD, &GPIO_InitStructure);//
000022  a905              ADD      r1,sp,#0x14
000024  482a              LDR      r0,|L3.208|
000026  f7fffffe          BL       GPIO_Init
;;;41       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;//PB3~5复用功能输出	
00002a  2038              MOVS     r0,#0x38
00002c  9005              STR      r0,[sp,#0x14]
;;;42       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
00002e  2002              MOVS     r0,#2
000030  f88d0018          STRB     r0,[sp,#0x18]
;;;43       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
000034  2000              MOVS     r0,#0
000036  f88d001a          STRB     r0,[sp,#0x1a]
;;;44       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
00003a  2003              MOVS     r0,#3
00003c  f88d0019          STRB     r0,[sp,#0x19]
;;;45       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
000040  2001              MOVS     r0,#1
000042  f88d001b          STRB     r0,[sp,#0x1b]
;;;46       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
000046  a905              ADD      r1,sp,#0x14
000048  4822              LDR      r0,|L3.212|
00004a  f7fffffe          BL       GPIO_Init
;;;47     	
;;;48       GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1); //PC2复用为 SPI1
00004e  2205              MOVS     r2,#5
000050  2103              MOVS     r1,#3
000052  4820              LDR      r0,|L3.212|
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;49     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1); //PBC3复用为 SPI1
000058  2205              MOVS     r2,#5
00005a  2104              MOVS     r1,#4
00005c  481d              LDR      r0,|L3.212|
00005e  f7fffffe          BL       GPIO_PinAFConfig
;;;50     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1); //PB13复用为 SPI1
000062  2205              MOVS     r2,#5
000064  4611              MOV      r1,r2
000066  481b              LDR      r0,|L3.212|
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;51     	
;;;52     	AD7689_CNV_1;
00006c  2104              MOVS     r1,#4
00006e  4818              LDR      r0,|L3.208|
000070  f7fffffe          BL       GPIO_SetBits
;;;53     	AD7689_Delay();
000074  f7fffffe          BL       AD7689_Delay
;;;54     	AD7689_CNV_0;
000078  2104              MOVS     r1,#4
00007a  4815              LDR      r0,|L3.208|
00007c  f7fffffe          BL       GPIO_ResetBits
;;;55     	//这里只针对SPI口初始化
;;;56       SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
000080  2000              MOVS     r0,#0
000082  f8ad0000          STRH     r0,[sp,#0]
;;;57     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
000086  f44f7082          MOV      r0,#0x104
00008a  f8ad0002          STRH     r0,[sp,#2]
;;;58     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;		//设置SPI的数据大小:SPI发送接收16位帧结构
00008e  f44f6000          MOV      r0,#0x800
000092  f8ad0004          STRH     r0,[sp,#4]
;;;59     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;		//串行同步时钟的空闲状态为高电平
000096  2000              MOVS     r0,#0
000098  f8ad0006          STRH     r0,[sp,#6]
;;;60     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
00009c  f8ad0008          STRH     r0,[sp,#8]
;;;61     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
0000a0  f44f7000          MOV      r0,#0x200
0000a4  f8ad000a          STRH     r0,[sp,#0xa]
;;;62     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
0000a8  2038              MOVS     r0,#0x38
0000aa  f8ad000c          STRH     r0,[sp,#0xc]
;;;63     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
0000ae  2000              MOVS     r0,#0
0000b0  f8ad000e          STRH     r0,[sp,#0xe]
;;;64     	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
0000b4  2007              MOVS     r0,#7
0000b6  f8ad0010          STRH     r0,[sp,#0x10]
;;;65     	SPI_Init(SPI1, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
0000ba  4669              MOV      r1,sp
0000bc  4806              LDR      r0,|L3.216|
0000be  f7fffffe          BL       SPI_Init
;;;66     	
;;;67     	SPI_Cmd(SPI1, ENABLE); //使能SPI外设
0000c2  2101              MOVS     r1,#1
0000c4  4804              LDR      r0,|L3.216|
0000c6  f7fffffe          BL       SPI_Cmd
;;;68     }
0000ca  b007              ADD      sp,sp,#0x1c
0000cc  bd00              POP      {pc}
;;;69     
                          ENDP

0000ce  0000              DCW      0x0000
                  |L3.208|
                          DCD      0x40020c00
                  |L3.212|
                          DCD      0x40020400
                  |L3.216|
                          DCD      0x40013000

                          AREA ||i.AD7689_Scan_CH||, CODE, READONLY, ALIGN=2

                  AD7689_Scan_CH PROC
;;;120    }
;;;121    void AD7689_Scan_CH(void)
000000  b500              PUSH     {lr}
;;;122    {
000002  b085              SUB      sp,sp,#0x14
;;;123    // 	vu8 i,f,d;
;;;124    // 	vu32 sum1;
;;;125    // 	vu16 var_chI,var_chV;
;;;126    // 	static vu8 I_cont,V_cont;
;;;127    // 	for(i=0;i<7;i++)
;;;128    // 	{
;;;129    // 		AD7689_Buffer[i]=SPI_AD7689_Read(1, i);
;;;130    // 		R1mon_value=AD7689_Buffer[0];
;;;131    // 		R2mon_value=AD7689_Buffer[1];
;;;132    // 		Vmon_Load_value=AD7689_Buffer[2];
;;;133    // 		Imon_Load_value=AD7689_Buffer[3];
;;;134    // 		Rmon_value=AD7689_Buffer[4];
;;;135    // 		Vmon_POWE_value=AD7689_Buffer[5];
;;;136    // 		Imon_POWE_value=AD7689_Buffer[6];
;;;137    
;;;138    vu8 i,f,d;
;;;139    	vu32 sum1;
;;;140    	vu16 var_chI,var_chI1,var_chV,var_chV1,var_chR;
;;;141    	static vu8 I_cont,I1_cont,V_cont,R_cont,V1_cont;
;;;142    	for(i=0;i<7;i++)
000004  2000              MOVS     r0,#0
000006  9004              STR      r0,[sp,#0x10]
000008  e028              B        |L4.92|
                  |L4.10|
;;;143    	{
;;;144    		AD7689_Buffer[i]=SPI_AD7689_Read(1, i);
00000a  f89d1010          LDRB     r1,[sp,#0x10]
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       SPI_AD7689_Read
000014  493f              LDR      r1,|L4.276|
000016  f89d2010          LDRB     r2,[sp,#0x10]
00001a  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;145    		R1mon_value=AD7689_Buffer[0];
00001e  4608              MOV      r0,r1
000020  8800              LDRH     r0,[r0,#0]  ; AD7689_Buffer
000022  493d              LDR      r1,|L4.280|
000024  8008              STRH     r0,[r1,#0]
;;;146    		R2mon_value=AD7689_Buffer[1];
000026  483b              LDR      r0,|L4.276|
000028  8840              LDRH     r0,[r0,#2]  ; AD7689_Buffer
00002a  493c              LDR      r1,|L4.284|
00002c  8008              STRH     r0,[r1,#0]
;;;147    		Vmon_Load_value=AD7689_Buffer[2];
00002e  4839              LDR      r0,|L4.276|
000030  8880              LDRH     r0,[r0,#4]  ; AD7689_Buffer
000032  493b              LDR      r1,|L4.288|
000034  8008              STRH     r0,[r1,#0]
;;;148    		var_chI=AD7689_Buffer[3];
000036  4837              LDR      r0,|L4.276|
000038  88c0              LDRH     r0,[r0,#6]  ; AD7689_Buffer
00003a  9001              STR      r0,[sp,#4]
;;;149    		var_chR=AD7689_Buffer[4];
00003c  4835              LDR      r0,|L4.276|
00003e  8900              LDRH     r0,[r0,#8]  ; AD7689_Buffer
000040  9000              STR      r0,[sp,#0]
;;;150    		Vmon_POWE_value=AD7689_Buffer[5];
000042  4834              LDR      r0,|L4.276|
000044  8940              LDRH     r0,[r0,#0xa]  ; AD7689_Buffer
000046  4937              LDR      r1,|L4.292|
000048  8008              STRH     r0,[r1,#0]
;;;151    		Imon_POWE_value=AD7689_Buffer[6];
00004a  4832              LDR      r0,|L4.276|
00004c  8980              LDRH     r0,[r0,#0xc]  ; AD7689_Buffer
00004e  4936              LDR      r1,|L4.296|
000050  8008              STRH     r0,[r1,#0]
000052  f89d0010          LDRB     r0,[sp,#0x10]         ;142
000056  1c40              ADDS     r0,r0,#1              ;142
000058  b2c0              UXTB     r0,r0                 ;142
00005a  9004              STR      r0,[sp,#0x10]         ;142
                  |L4.92|
00005c  f89d0010          LDRB     r0,[sp,#0x10]         ;142
000060  2807              CMP      r0,#7                 ;142
000062  dbd2              BLT      |L4.10|
;;;152    	}
;;;153    	
;;;154    	Ad7689_Fit_Rmon[R_cont++]=var_chR;
000064  f8bd2000          LDRH     r2,[sp,#0]
000068  4930              LDR      r1,|L4.300|
00006a  7808              LDRB     r0,[r1,#0]  ; R_cont
00006c  1c41              ADDS     r1,r0,#1
00006e  4b2f              LDR      r3,|L4.300|
000070  7019              STRB     r1,[r3,#0]
000072  492f              LDR      r1,|L4.304|
000074  f8212010          STRH     r2,[r1,r0,LSL #1]
;;;155    	if(R_cont==100)
000078  4618              MOV      r0,r3
00007a  7800              LDRB     r0,[r0,#0]  ; R_cont
00007c  2864              CMP      r0,#0x64
00007e  d11c              BNE      |L4.186|
;;;156    	{
;;;157    		R_cont=0;
000080  2000              MOVS     r0,#0
000082  4619              MOV      r1,r3
000084  7008              STRB     r0,[r1,#0]
;;;158    		sum1=0;
000086  9002              STR      r0,[sp,#8]
;;;159    		for(f=0;f<100;f++)
000088  9003              STR      r0,[sp,#0xc]
00008a  e00c              B        |L4.166|
                  |L4.140|
;;;160    		{
;;;161    			sum1 +=Ad7689_Fit_Rmon[f];
00008c  4828              LDR      r0,|L4.304|
00008e  f89d100c          LDRB     r1,[sp,#0xc]
000092  f8300011          LDRH     r0,[r0,r1,LSL #1]
000096  9902              LDR      r1,[sp,#8]
000098  4408              ADD      r0,r0,r1
00009a  9002              STR      r0,[sp,#8]
00009c  f89d000c          LDRB     r0,[sp,#0xc]          ;159
0000a0  1c40              ADDS     r0,r0,#1              ;159
0000a2  b2c0              UXTB     r0,r0                 ;159
0000a4  9003              STR      r0,[sp,#0xc]          ;159
                  |L4.166|
0000a6  f89d000c          LDRB     r0,[sp,#0xc]          ;159
0000aa  2864              CMP      r0,#0x64              ;159
0000ac  dbee              BLT      |L4.140|
;;;162    		}
;;;163    		Rmon_value=sum1/100;//
0000ae  2164              MOVS     r1,#0x64
0000b0  9802              LDR      r0,[sp,#8]
0000b2  fbb0f0f1          UDIV     r0,r0,r1
0000b6  491f              LDR      r1,|L4.308|
0000b8  8008              STRH     r0,[r1,#0]
                  |L4.186|
;;;164    	}
;;;165    
;;;166    	Ad7689_Fit_Imon[I_cont++] = var_chI;
0000ba  f8bd2004          LDRH     r2,[sp,#4]
0000be  491e              LDR      r1,|L4.312|
0000c0  7808              LDRB     r0,[r1,#0]  ; I_cont
0000c2  1c41              ADDS     r1,r0,#1
0000c4  4b1c              LDR      r3,|L4.312|
0000c6  7019              STRB     r1,[r3,#0]
0000c8  491c              LDR      r1,|L4.316|
0000ca  f8212010          STRH     r2,[r1,r0,LSL #1]
;;;167    	if(I_cont==50)
0000ce  4618              MOV      r0,r3
0000d0  7800              LDRB     r0,[r0,#0]  ; I_cont
0000d2  2832              CMP      r0,#0x32
0000d4  d11c              BNE      |L4.272|
;;;168    	{
;;;169    		I_cont=0;
0000d6  2000              MOVS     r0,#0
0000d8  4619              MOV      r1,r3
0000da  7008              STRB     r0,[r1,#0]
;;;170    		sum1=0;
0000dc  9002              STR      r0,[sp,#8]
;;;171    		for(f=0;f<50;f++)
0000de  9003              STR      r0,[sp,#0xc]
0000e0  e00c              B        |L4.252|
                  |L4.226|
;;;172    		{
;;;173    			sum1 +=Ad7689_Fit_Imon[f];
0000e2  4816              LDR      r0,|L4.316|
0000e4  f89d100c          LDRB     r1,[sp,#0xc]
0000e8  f8300011          LDRH     r0,[r0,r1,LSL #1]
0000ec  9902              LDR      r1,[sp,#8]
0000ee  4408              ADD      r0,r0,r1
0000f0  9002              STR      r0,[sp,#8]
0000f2  f89d000c          LDRB     r0,[sp,#0xc]          ;171
0000f6  1c40              ADDS     r0,r0,#1              ;171
0000f8  b2c0              UXTB     r0,r0                 ;171
0000fa  9003              STR      r0,[sp,#0xc]          ;171
                  |L4.252|
0000fc  f89d000c          LDRB     r0,[sp,#0xc]          ;171
000100  2832              CMP      r0,#0x32              ;171
000102  dbee              BLT      |L4.226|
;;;174    		}
;;;175    		Imon_Load_value=sum1/50;//
000104  2132              MOVS     r1,#0x32
000106  9802              LDR      r0,[sp,#8]
000108  fbb0f0f1          UDIV     r0,r0,r1
00010c  490c              LDR      r1,|L4.320|
00010e  8008              STRH     r0,[r1,#0]
                  |L4.272|
;;;176    	}
;;;177    }
000110  b005              ADD      sp,sp,#0x14
000112  bd00              POP      {pc}
                          ENDP

                  |L4.276|
                          DCD      AD7689_Buffer
                  |L4.280|
                          DCD      R1mon_value
                  |L4.284|
                          DCD      R2mon_value
                  |L4.288|
                          DCD      Vmon_Load_value
                  |L4.292|
                          DCD      Vmon_POWE_value
                  |L4.296|
                          DCD      Imon_POWE_value
                  |L4.300|
                          DCD      R_cont
                  |L4.304|
                          DCD      Ad7689_Fit_Rmon
                  |L4.308|
                          DCD      Rmon_value
                  |L4.312|
                          DCD      I_cont
                  |L4.316|
                          DCD      Ad7689_Fit_Imon
                  |L4.320|
                          DCD      Imon_Load_value

                          AREA ||i.AD7689_TransferByte||, CODE, READONLY, ALIGN=2

                  AD7689_TransferByte PROC
;;;93     /************************************************************************/
;;;94     vu16 AD7689_TransferByte(vu16 uiTxData1)
000000  b501              PUSH     {r0,lr}
;;;95     {
000002  b082              SUB      sp,sp,#8
;;;96     	vu16 uiRxData;
;;;97     	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L5.6|
000006  2102              MOVS     r1,#2
000008  480b              LDR      r0,|L5.56|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L5.6|
;;;98     	SPI_I2S_SendData(SPI1,uiTxData1);
000012  f8bd1008          LDRH     r1,[sp,#8]
000016  4808              LDR      r0,|L5.56|
000018  f7fffffe          BL       SPI_I2S_SendData
;;;99     	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001c  bf00              NOP      
                  |L5.30|
00001e  2101              MOVS     r1,#1
000020  4805              LDR      r0,|L5.56|
000022  f7fffffe          BL       SPI_I2S_GetFlagStatus
000026  2800              CMP      r0,#0
000028  d0f9              BEQ      |L5.30|
;;;100    	uiRxData = SPI_I2S_ReceiveData(SPI1);
00002a  4803              LDR      r0,|L5.56|
00002c  f7fffffe          BL       SPI_I2S_ReceiveData
000030  9001              STR      r0,[sp,#4]
;;;101    	return uiRxData;
000032  f8bd0004          LDRH     r0,[sp,#4]
;;;102    }
000036  bd0e              POP      {r1-r3,pc}
;;;103    /************************************************************************/
                          ENDP

                  |L5.56|
                          DCD      0x40013000

                          AREA ||i.SPI_AD7689_Read||, CODE, READONLY, ALIGN=2

                  SPI_AD7689_Read PROC
;;;69     
;;;70     vu16 SPI_AD7689_Read(vu16 AD7689_CFG, vu16 AD7689_INx)
000000  b503              PUSH     {r0,r1,lr}
;;;71     {
000002  b083              SUB      sp,sp,#0xc
;;;72     	vu16 AD7689_Config=0;
000004  2000              MOVS     r0,#0
000006  9002              STR      r0,[sp,#8]
;;;73     	vu16 AD7689_Data;
;;;74     	vu8 i;
;;;75     	AD7689_Config = AD7689_CFG<<13|AD7689_INCC<<10|AD7689_INx<<7|AD7689_BW<<6|AD7689_REF<<3|AD7689_SEQ<<1|AD7689_RB;//写入配置参数
000008  f8bd000c          LDRH     r0,[sp,#0xc]
00000c  f44f51c0          MOV      r1,#0x1800
000010  ea413040          ORR      r0,r1,r0,LSL #13
000014  f8bd1010          LDRH     r1,[sp,#0x10]
000018  ea4010c1          ORR      r0,r0,r1,LSL #7
00001c  f0400058          ORR      r0,r0,#0x58
000020  1c40              ADDS     r0,r0,#1
000022  b280              UXTH     r0,r0
000024  9002              STR      r0,[sp,#8]
;;;76     	AD7689_Config <<=2;
000026  f8bd0008          LDRH     r0,[sp,#8]
00002a  f64f71ff          MOV      r1,#0xffff
00002e  ea010080          AND      r0,r1,r0,LSL #2
000032  9002              STR      r0,[sp,#8]
;;;77     	AD7689_CNV_0;
000034  2104              MOVS     r1,#4
000036  480a              LDR      r0,|L6.96|
000038  f7fffffe          BL       GPIO_ResetBits
;;;78       AD7689_Data=AD7689_TransferByte(AD7689_Config);
00003c  f8bd0008          LDRH     r0,[sp,#8]
000040  f7fffffe          BL       AD7689_TransferByte
000044  9001              STR      r0,[sp,#4]
;;;79     	AD7689_Delay(); 
000046  f7fffffe          BL       AD7689_Delay
;;;80     	AD7689_CNV_1;
00004a  2104              MOVS     r1,#4
00004c  4804              LDR      r0,|L6.96|
00004e  f7fffffe          BL       GPIO_SetBits
;;;81     	AD7689_Delay(); 
000052  f7fffffe          BL       AD7689_Delay
;;;82     	return AD7689_Data;
000056  f8bd0004          LDRH     r0,[sp,#4]
;;;83     }
00005a  b005              ADD      sp,sp,#0x14
00005c  bd00              POP      {pc}
;;;84     
                          ENDP

00005e  0000              DCW      0x0000
                  |L6.96|
                          DCD      0x40020c00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  AD7689_Buffer
                          %        16
                  Ad7689_Fit_Imon
                          %        200
                  Ad7689_Fit_Vmon
                          %        20
                  Ad7689_Fit_Rmon
                          %        200

                          AREA ||.data||, DATA, ALIGN=0

                  I_cont
000000  00                DCB      0x00
                  R_cont
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\AD7689.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_5bab55e0____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_AD7689_c_5bab55e0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_AD7689_c_5bab55e0____REVSH|
#line 144
|__asm___8_AD7689_c_5bab55e0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
