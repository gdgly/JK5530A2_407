; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\iic_24c01.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\iic_24c01.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\iic_24c01.crf --no_multibyte_chars ..\drive\IIC_24C01.c]
                          THUMB

                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=2

                  i2c_Ack PROC
;;;208    */
;;;209    void i2c_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;210    {
;;;211    	I2C_SDA_0();	/* CPU驱动SDA = 0 */
000002  2108              MOVS     r1,#8
000004  480a              LDR      r0,|L1.48|
000006  f7fffffe          BL       GPIO_ResetBits
;;;212    	i2c_Delay();
00000a  f7fffffe          BL       i2c_Delay
;;;213    	I2C_SCL_1();	/* CPU产生1个时钟 */
00000e  2140              MOVS     r1,#0x40
000010  4807              LDR      r0,|L1.48|
000012  f7fffffe          BL       GPIO_SetBits
;;;214    	i2c_Delay();
000016  f7fffffe          BL       i2c_Delay
;;;215    	I2C_SCL_0();
00001a  2140              MOVS     r1,#0x40
00001c  4804              LDR      r0,|L1.48|
00001e  f7fffffe          BL       GPIO_ResetBits
;;;216    	i2c_Delay();
000022  f7fffffe          BL       i2c_Delay
;;;217    	I2C_SDA_1();	/* CPU释放SDA总线 */
000026  2108              MOVS     r1,#8
000028  4801              LDR      r0,|L1.48|
00002a  f7fffffe          BL       GPIO_SetBits
;;;218    }
00002e  bd10              POP      {r4,pc}
;;;219    
                          ENDP

                  |L1.48|
                          DCD      0x40020c00

                          AREA ||i.i2c_CfgGpio||, CODE, READONLY, ALIGN=2

                  i2c_CfgGpio PROC
;;;245    */
;;;246    void i2c_CfgGpio(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;247    {
;;;248    	GPIO_InitTypeDef GPIO_InitStructure;//调用GPIO结构体
;;;249    
;;;250    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);//开启GPIOF时钟
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;251    
;;;252    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_6;//定义端口PF
00000a  2048              MOVS     r0,#0x48
00000c  9000              STR      r0,[sp,#0]
;;;253    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
00000e  2001              MOVS     r0,#1
000010  f88d0004          STRB     r0,[sp,#4]
;;;254    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;//设置为输出模式
000014  f88d0006          STRB     r0,[sp,#6]
;;;255    	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;//设置输出频率
000018  2002              MOVS     r0,#2
00001a  f88d0005          STRB     r0,[sp,#5]
;;;256    	GPIO_Init(GPIOD, &GPIO_InitStructure);//将设置输入函数
00001e  4669              MOV      r1,sp
000020  4802              LDR      r0,|L2.44|
000022  f7fffffe          BL       GPIO_Init
;;;257    
;;;258    	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;259    	i2c_Stop();
000026  f7fffffe          BL       i2c_Stop
;;;260    }
00002a  bd1c              POP      {r2-r4,pc}
;;;261    
                          ENDP

                  |L2.44|
                          DCD      0x40020c00

                          AREA ||i.i2c_CheckDevice||, CODE, READONLY, ALIGN=1

                  i2c_CheckDevice PROC
;;;269    */
;;;270    vu8 i2c_CheckDevice(vu8 _Address)
000000  b501              PUSH     {r0,lr}
;;;271    {
000002  b082              SUB      sp,sp,#8
;;;272    	vu8 ucAck;
;;;273    
;;;274    	i2c_CfgGpio();		/* 配置GPIO */
000004  f7fffffe          BL       i2c_CfgGpio
;;;275    
;;;276    	
;;;277    	i2c_Start();		/* 发送启动信号 */
000008  f7fffffe          BL       i2c_Start
;;;278    
;;;279    	/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;280    	i2c_SendByte(_Address | I2C_WR);
00000c  f89d0008          LDRB     r0,[sp,#8]
000010  f7fffffe          BL       i2c_SendByte
;;;281    	ucAck = i2c_WaitAck();	/* 检测设备的ACK应答 */
000014  f7fffffe          BL       i2c_WaitAck
000018  9001              STR      r0,[sp,#4]
;;;282    
;;;283    	i2c_Stop();			/* 发送停止信号 */
00001a  f7fffffe          BL       i2c_Stop
;;;284    
;;;285    	return ucAck;
00001e  f89d0004          LDRB     r0,[sp,#4]
;;;286    }
000022  bd0e              POP      {r1-r3,pc}
                          ENDP


                          AREA ||i.i2c_Delay||, CODE, READONLY, ALIGN=1

                  i2c_Delay PROC
;;;52     */
;;;53     static void i2c_Delay(void)
000000  b508              PUSH     {r3,lr}
;;;54     {
;;;55     	vu8 i;
;;;56     
;;;57     	/*　
;;;58     	 	下面的时间是通过安富莱AX-Pro逻辑分析仪测试得到的。
;;;59     		CPU主频72MHz时，在内部Flash运行, MDK工程不优化
;;;60     		循环次数为10时，SCL频率 = 205KHz 
;;;61     		循环次数为7时，SCL频率 = 347KHz， SCL高电平时间1.5us，SCL低电平时间2.87us 
;;;62     	 	循环次数为5时，SCL频率 = 421KHz， SCL高电平时间1.25us，SCL低电平时间2.375us 
;;;63             
;;;64         IAR工程编译效率高，不能设置为7
;;;65     	*/
;;;66     	for (i = 0; i < 100; i++);
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  e004              B        |L4.18|
                  |L4.8|
000008  f89d0000          LDRB     r0,[sp,#0]
00000c  1c40              ADDS     r0,r0,#1
00000e  b2c0              UXTB     r0,r0
000010  9000              STR      r0,[sp,#0]
                  |L4.18|
000012  f89d0000          LDRB     r0,[sp,#0]
000016  2864              CMP      r0,#0x64
000018  dbf6              BLT      |L4.8|
;;;67     }
00001a  bd08              POP      {r3,pc}
;;;68     
                          ENDP


                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=2

                  i2c_NAck PROC
;;;227    */
;;;228    void i2c_NAck(void)
000000  b510              PUSH     {r4,lr}
;;;229    {
;;;230    	I2C_SDA_1();	/* CPU驱动SDA = 1 */
000002  2108              MOVS     r1,#8
000004  4808              LDR      r0,|L5.40|
000006  f7fffffe          BL       GPIO_SetBits
;;;231    	i2c_Delay();
00000a  f7fffffe          BL       i2c_Delay
;;;232    	I2C_SCL_1();	/* CPU产生1个时钟 */
00000e  2140              MOVS     r1,#0x40
000010  4805              LDR      r0,|L5.40|
000012  f7fffffe          BL       GPIO_SetBits
;;;233    	i2c_Delay();
000016  f7fffffe          BL       i2c_Delay
;;;234    	I2C_SCL_0();
00001a  2140              MOVS     r1,#0x40
00001c  4802              LDR      r0,|L5.40|
00001e  f7fffffe          BL       GPIO_ResetBits
;;;235    	i2c_Delay();	
000022  f7fffffe          BL       i2c_Delay
;;;236    }
000026  bd10              POP      {r4,pc}
;;;237    
                          ENDP

                  |L5.40|
                          DCD      0x40020c00

                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=2

                  i2c_ReadByte PROC
;;;149    */
;;;150    vu8 i2c_ReadByte(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;151    {
;;;152    	vu8 i;
;;;153    	vu8 value;
;;;154    
;;;155    	/* 读到第1个bit为数据的bit7 */
;;;156    	value = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;157    	for (i = 0; i < 8; i++)
000006  9001              STR      r0,[sp,#4]
000008  e01f              B        |L6.74|
                  |L6.10|
;;;158    	{
;;;159    		value <<= 1;
00000a  f89d0000          LDRB     r0,[sp,#0]
00000e  0640              LSLS     r0,r0,#25
000010  0e00              LSRS     r0,r0,#24
000012  9000              STR      r0,[sp,#0]
;;;160    		I2C_SCL_1();
000014  2140              MOVS     r1,#0x40
000016  4810              LDR      r0,|L6.88|
000018  f7fffffe          BL       GPIO_SetBits
;;;161    		i2c_Delay();
00001c  f7fffffe          BL       i2c_Delay
;;;162    		if (I2C_SDA_READ())
000020  2108              MOVS     r1,#8
000022  480d              LDR      r0,|L6.88|
000024  f7fffffe          BL       GPIO_ReadInputDataBit
000028  b120              CBZ      r0,|L6.52|
;;;163    		{
;;;164    			value++;
00002a  f89d0000          LDRB     r0,[sp,#0]
00002e  1c40              ADDS     r0,r0,#1
000030  b2c0              UXTB     r0,r0
000032  9000              STR      r0,[sp,#0]
                  |L6.52|
;;;165    		}
;;;166    		I2C_SCL_0();
000034  2140              MOVS     r1,#0x40
000036  4808              LDR      r0,|L6.88|
000038  f7fffffe          BL       GPIO_ResetBits
;;;167    		i2c_Delay();
00003c  f7fffffe          BL       i2c_Delay
000040  f89d0004          LDRB     r0,[sp,#4]            ;157
000044  1c40              ADDS     r0,r0,#1              ;157
000046  b2c0              UXTB     r0,r0                 ;157
000048  9001              STR      r0,[sp,#4]            ;157
                  |L6.74|
00004a  f89d0004          LDRB     r0,[sp,#4]            ;157
00004e  2808              CMP      r0,#8                 ;157
000050  dbdb              BLT      |L6.10|
;;;168    	}
;;;169    	return value;
000052  f89d0000          LDRB     r0,[sp,#0]
;;;170    }
000056  bd1c              POP      {r2-r4,pc}
;;;171    
                          ENDP

                  |L6.88|
                          DCD      0x40020c00

                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=2

                  i2c_SendByte PROC
;;;113    */
;;;114    void i2c_SendByte(vu8 _ucByte)
000000  b501              PUSH     {r0,lr}
;;;115    {
000002  b082              SUB      sp,sp,#8
;;;116    	vu8 i;
;;;117    
;;;118    	/* 先发送字节的高位bit7 */
;;;119    	for (i = 0; i < 8; i++)
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
000008  e02d              B        |L7.102|
                  |L7.10|
;;;120    	{		
;;;121    		if (_ucByte & 0x80)
00000a  f89d0008          LDRB     r0,[sp,#8]
00000e  f0000080          AND      r0,r0,#0x80
000012  b120              CBZ      r0,|L7.30|
;;;122    		{
;;;123    			I2C_SDA_1();
000014  2108              MOVS     r1,#8
000016  4816              LDR      r0,|L7.112|
000018  f7fffffe          BL       GPIO_SetBits
00001c  e003              B        |L7.38|
                  |L7.30|
;;;124    		}
;;;125    		else
;;;126    		{
;;;127    			I2C_SDA_0();
00001e  2108              MOVS     r1,#8
000020  4813              LDR      r0,|L7.112|
000022  f7fffffe          BL       GPIO_ResetBits
                  |L7.38|
;;;128    		}
;;;129    		i2c_Delay();
000026  f7fffffe          BL       i2c_Delay
;;;130    		I2C_SCL_1();
00002a  2140              MOVS     r1,#0x40
00002c  4810              LDR      r0,|L7.112|
00002e  f7fffffe          BL       GPIO_SetBits
;;;131    		i2c_Delay();	
000032  f7fffffe          BL       i2c_Delay
;;;132    		I2C_SCL_0();
000036  2140              MOVS     r1,#0x40
000038  480d              LDR      r0,|L7.112|
00003a  f7fffffe          BL       GPIO_ResetBits
;;;133    		if (i == 7)
00003e  f89d0004          LDRB     r0,[sp,#4]
000042  2807              CMP      r0,#7
000044  d103              BNE      |L7.78|
;;;134    		{
;;;135    			 I2C_SDA_1(); // 释放总线
000046  2108              MOVS     r1,#8
000048  4809              LDR      r0,|L7.112|
00004a  f7fffffe          BL       GPIO_SetBits
                  |L7.78|
;;;136    		}
;;;137    		_ucByte <<= 1;	/* 左移一个bit */
00004e  f89d0008          LDRB     r0,[sp,#8]
000052  0640              LSLS     r0,r0,#25
000054  0e00              LSRS     r0,r0,#24
000056  9002              STR      r0,[sp,#8]
;;;138    		i2c_Delay();
000058  f7fffffe          BL       i2c_Delay
00005c  f89d0004          LDRB     r0,[sp,#4]            ;119
000060  1c40              ADDS     r0,r0,#1              ;119
000062  b2c0              UXTB     r0,r0                 ;119
000064  9001              STR      r0,[sp,#4]            ;119
                  |L7.102|
000066  f89d0004          LDRB     r0,[sp,#4]            ;119
00006a  2808              CMP      r0,#8                 ;119
00006c  dbcd              BLT      |L7.10|
;;;139    	}
;;;140    }
00006e  bd0e              POP      {r1-r3,pc}
;;;141    
                          ENDP

                  |L7.112|
                          DCD      0x40020c00

                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=2

                  i2c_Start PROC
;;;76     */
;;;77     void i2c_Start(void)
000000  b510              PUSH     {r4,lr}
;;;78     {
;;;79     	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;80     	I2C_SDA_1();
000002  2108              MOVS     r1,#8
000004  480a              LDR      r0,|L8.48|
000006  f7fffffe          BL       GPIO_SetBits
;;;81     	I2C_SCL_1();
00000a  2140              MOVS     r1,#0x40
00000c  4808              LDR      r0,|L8.48|
00000e  f7fffffe          BL       GPIO_SetBits
;;;82     	i2c_Delay();
000012  f7fffffe          BL       i2c_Delay
;;;83     	I2C_SDA_0();
000016  2108              MOVS     r1,#8
000018  4805              LDR      r0,|L8.48|
00001a  f7fffffe          BL       GPIO_ResetBits
;;;84     	i2c_Delay();
00001e  f7fffffe          BL       i2c_Delay
;;;85     	I2C_SCL_0();
000022  2140              MOVS     r1,#0x40
000024  4802              LDR      r0,|L8.48|
000026  f7fffffe          BL       GPIO_ResetBits
;;;86     	i2c_Delay();
00002a  f7fffffe          BL       i2c_Delay
;;;87     }
00002e  bd10              POP      {r4,pc}
;;;88     
                          ENDP

                  |L8.48|
                          DCD      0x40020c00

                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=2

                  i2c_Stop PROC
;;;96     */
;;;97     void i2c_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99     	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;100    	I2C_SDA_0();
000002  2108              MOVS     r1,#8
000004  4806              LDR      r0,|L9.32|
000006  f7fffffe          BL       GPIO_ResetBits
;;;101    	I2C_SCL_1();
00000a  2140              MOVS     r1,#0x40
00000c  4804              LDR      r0,|L9.32|
00000e  f7fffffe          BL       GPIO_SetBits
;;;102    	i2c_Delay();
000012  f7fffffe          BL       i2c_Delay
;;;103    	I2C_SDA_1();
000016  2108              MOVS     r1,#8
000018  4801              LDR      r0,|L9.32|
00001a  f7fffffe          BL       GPIO_SetBits
;;;104    }
00001e  bd10              POP      {r4,pc}
;;;105    
                          ENDP

                  |L9.32|
                          DCD      0x40020c00

                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=2

                  i2c_WaitAck PROC
;;;179    */
;;;180    vu8 i2c_WaitAck(void)
000000  b508              PUSH     {r3,lr}
;;;181    {
;;;182    	vu8 re;
;;;183    
;;;184    	I2C_SDA_1();	/* CPU释放SDA总线 */
000002  2108              MOVS     r1,#8
000004  480e              LDR      r0,|L10.64|
000006  f7fffffe          BL       GPIO_SetBits
;;;185    	i2c_Delay();
00000a  f7fffffe          BL       i2c_Delay
;;;186    	I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
00000e  2140              MOVS     r1,#0x40
000010  480b              LDR      r0,|L10.64|
000012  f7fffffe          BL       GPIO_SetBits
;;;187    	i2c_Delay();
000016  f7fffffe          BL       i2c_Delay
;;;188    	if (I2C_SDA_READ())	/* CPU读取SDA口线状态 */
00001a  2108              MOVS     r1,#8
00001c  4808              LDR      r0,|L10.64|
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
000022  b110              CBZ      r0,|L10.42|
;;;189    	{
;;;190    		re = 1;
000024  2001              MOVS     r0,#1
000026  9000              STR      r0,[sp,#0]
000028  e001              B        |L10.46|
                  |L10.42|
;;;191    	}
;;;192    	else
;;;193    	{
;;;194    		re = 0;
00002a  2000              MOVS     r0,#0
00002c  9000              STR      r0,[sp,#0]
                  |L10.46|
;;;195    	}
;;;196    	I2C_SCL_0();
00002e  2140              MOVS     r1,#0x40
000030  4803              LDR      r0,|L10.64|
000032  f7fffffe          BL       GPIO_ResetBits
;;;197    	i2c_Delay();
000036  f7fffffe          BL       i2c_Delay
;;;198    	return re;
00003a  f89d0000          LDRB     r0,[sp,#0]
;;;199    }
00003e  bd08              POP      {r3,pc}
;;;200    
                          ENDP

                  |L10.64|
                          DCD      0x40020c00

;*** Start embedded assembler ***

#line 1 "..\\drive\\IIC_24C01.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_IIC_24C01_c_0e3d169d____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_IIC_24C01_c_0e3d169d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_IIC_24C01_c_0e3d169d____REVSH|
#line 144
|__asm___11_IIC_24C01_c_0e3d169d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
