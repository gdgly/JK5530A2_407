; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\usart.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\usart.crf --no_multibyte_chars ..\drive\usart.c]
                          THUMB

                          AREA ||i.IsDigitChar||, CODE, READONLY, ALIGN=1

                  IsDigitChar PROC
;;;61     /*****************************************************************/
;;;62     unsigned short IsDigitChar(unsigned char a)             //如果a的值是数字的话返回1，否则返回0
000000  4601              MOV      r1,r0
;;;63     {
;;;64     	int b;
;;;65       if(a<0x30 || a>0x39)                     //数字1-9
000002  2930              CMP      r1,#0x30
000004  db01              BLT      |L1.10|
000006  2939              CMP      r1,#0x39
000008  dd01              BLE      |L1.14|
                  |L1.10|
;;;66       	{
;;;67       	   b=0;
00000a  2200              MOVS     r2,#0
00000c  e000              B        |L1.16|
                  |L1.14|
;;;68       	}
;;;69       else
;;;70       	{
;;;71       	   b=1;
00000e  2201              MOVS     r2,#1
                  |L1.16|
;;;72       	}
;;;73       return b;
000010  b290              UXTH     r0,r2
;;;74     }
000012  4770              BX       lr
;;;75     
                          ENDP


                          AREA ||i.SerialRemoteHandleL||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                  SerialRemoteHandleL PROC
;;;114    
;;;115    u16 SerialRemoteHandleL(u8 len,char* buf)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;116    {
000004  b0b7              SUB      sp,sp,#0xdc
000006  4683              MOV      r11,r0
000008  460d              MOV      r5,r1
;;;117    
;;;118      
;;;119        u16 currCharNum;
;;;120        u32 temp1;
;;;121      u8 Gmode_Vale;
;;;122    	u8 i,j;
;;;123    	
;;;124    	u8 addr = 0;
00000a  2000              MOVS     r0,#0
00000c  9036              STR      r0,[sp,#0xd8]
;;;125    	char str[200]={0};
00000e  21c8              MOVS     r1,#0xc8
000010  a804              ADD      r0,sp,#0x10
000012  f7fffffe          BL       __aeabi_memclr4
;;;126    	int cmd_flag=255;
000016  20ff              MOVS     r0,#0xff
000018  9003              STR      r0,[sp,#0xc]
;;;127    	u8 templen =0;
00001a  2000              MOVS     r0,#0
00001c  9002              STR      r0,[sp,#8]
;;;128    	u8 tmpFg;
;;;129    	u8 LM_S_Vale,LOW_I_Vale,H_L_Vale,SWITCH_Vale;
;;;130    	u16 I_ADC_Vale,V_ADC_Vale;
;;;131    	int32_t V_CS_Vale,I_CS_Vale;
;;;132    	float Lvl_Vale,fadcx,fsingal, fVale;
;;;133     
;;;134    //	u8 len = 11;
;;;135    	u8 pntlen = 0;
00001e  2700              MOVS     r7,#0
;;;136    
;;;137    
;;;138    	
;;;139    	currCharNum=0;
000020  2400              MOVS     r4,#0
;;;140    	if((buf[currCharNum] != ChrStartR) || (buf[len-2] != ChrEndR)||(buf[len-1] != ChrEndS))
000022  5d28              LDRB     r0,[r5,r4]
000024  283c              CMP      r0,#0x3c
000026  d109              BNE      |L2.60|
000028  f1ab0002          SUB      r0,r11,#2
00002c  5c28              LDRB     r0,[r5,r0]
00002e  280d              CMP      r0,#0xd
000030  d104              BNE      |L2.60|
000032  f1ab0001          SUB      r0,r11,#1
000036  5c28              LDRB     r0,[r5,r0]
000038  280a              CMP      r0,#0xa
00003a  d007              BEQ      |L2.76|
                  |L2.60|
;;;141        {
;;;142    		return SetErr_ACK(buf,addr ,CMD_ERR); 
00003c  2202              MOVS     r2,#2
00003e  4628              MOV      r0,r5
000040  9936              LDR      r1,[sp,#0xd8]
000042  f7fffffe          BL       SetErr_ACK
                  |L2.70|
;;;143        } 
;;;144    	str[currCharNum++] = ChrStartR;
;;;145    	sprintf(&str[currCharNum],"%d",addr);
;;;146    	strncat(str,"/",1);
;;;147    	currCharNum =strlen(str);
;;;148    	cmd_flag=strncmp(buf,str,strlen(str));
;;;149    	//testflag = cmd_flag;
;;;150    	if(0!=cmd_flag)
;;;151    	{
;;;152    		return SetErr_ACK(buf, addr ,CMD_ERR);
;;;153    		
;;;154    	}
;;;155    	for (j=0;j<CmdNumb;j++)
;;;156        {
;;;157    		templen = strlen(CmdStr[j]);
;;;158    		cmd_flag=strncmp(&buf[currCharNum],CmdStr[j],templen);
;;;159    	    if(0==cmd_flag)
;;;160    	    {
;;;161    
;;;162    		  buf[0] = ChrStartS;
;;;163    		  currCharNum+=templen;
;;;164    		  switch(j)
;;;165              {
;;;166    			case 0:
;;;167    				pntlen = 5;    //
;;;168    				if(buf[currCharNum]=='?')
;;;169    				{
;;;170    
;;;171    					
;;;172    					sprintf(&buf[currCharNum],"%05d",CLists.CVoltage);
;;;173    					currCharNum+=pntlen;
;;;174    					
;;;175    					buf[currCharNum++]=(',');
;;;176    					sprintf(&buf[currCharNum],"%05d",CLists.CLaod_Current);
;;;177    					currCharNum+=pntlen;
;;;178    					
;;;179    					buf[currCharNum++]=(',');
;;;180    					sprintf(&buf[currCharNum],"%05d",CLists.CPOW_Voltage);
;;;181    					currCharNum+=pntlen;
;;;182    					
;;;183    					buf[currCharNum++]=(',');
;;;184    					sprintf(&buf[currCharNum],"%05d",CLists.CCurrent);
;;;185    					currCharNum+=pntlen;
;;;186    					
;;;187    					buf[currCharNum++]=(',');
;;;188    					sprintf(&buf[currCharNum],"%05d",CLists.CR_VLUE);
;;;189    					currCharNum+=pntlen;
;;;190    					
;;;191    //					buf[currCharNum++]=(',');
;;;192    //					sprintf(&buf[currCharNum],"%d",H_L);
;;;193    //					currCharNum++;
;;;194    					
;;;195    //					buf[currCharNum++]=(',');
;;;196    //					sprintf(&buf[currCharNum],"%d",LM_S);
;;;197    //					currCharNum++;
;;;198    					
;;;199    //					buf[currCharNum++]=(',');
;;;200    //					sprintf(&buf[currCharNum],"%02d",(int)temperature);
;;;201    //					currCharNum+=2;
;;;202    					
;;;203    				  buf[currCharNum++ ] = ChrEndR;
;;;204    				  buf[currCharNum++ ] = ChrEndS;
;;;205    				}
;;;206    				else
;;;207    				{
;;;208    					return SetErr_ACK(buf, addr ,CMD_ERR);
;;;209    				}
;;;210    				break;
;;;211    			case 1:
;;;212    				pntlen = 1;
;;;213    				if(buf[currCharNum]=='?')
;;;214    				{
;;;215    					  sprintf(&buf[currCharNum],"%1d",FLAG_WIN);
;;;216    				    currCharNum+=pntlen;
;;;217    				    buf[currCharNum ++] = ChrEndS;
;;;218    					
;;;219    				}
;;;220    				else
;;;221    				{
;;;222    					tmpFg = 1;
;;;223    		            for(i=0;i<pntlen;i++)
;;;224    		            {
;;;225    					   if(IsDigitChar(buf[currCharNum+i])==1)
;;;226    					   {
;;;227    					      tmpFg = (tmpFg&0x01);
;;;228    					   }
;;;229    					   else
;;;230    					   {
;;;231    					      tmpFg = 0;
;;;232    					   }
;;;233    		            }
;;;234    					if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;235    					{
;;;236    						return SetErr_ACK(buf, addr ,CMD_ERR);
;;;237    						
;;;238    					}					
;;;239    					for(i=0,temp1=0;i<pntlen;i++)
;;;240    		            {
;;;241    		                  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;242    					}		                   
;;;243    				    if(temp1 > 5)
;;;244    			         {
;;;245    			             return SetErr_ACK(buf, addr ,PARA_ERR);
;;;246    						 
;;;247    			         }
;;;248    							 FLAG_WIN = temp1;
;;;249    					 buf[currCharNum++] = ChrEndS;
;;;250    		        }
;;;251    				break;
;;;252    				case 2:
;;;253    				pntlen = 1;
;;;254    				if(buf[currCharNum]=='?')
;;;255    				{
;;;256    					  sprintf(&buf[currCharNum],"%1d",C_DISCHARGE);
;;;257    				    currCharNum+=pntlen;
;;;258    				    buf[currCharNum ++] = ChrEndS;
;;;259    					
;;;260    				}
;;;261    				else
;;;262    				{
;;;263    					tmpFg = 1;
;;;264    		            for(i=0;i<pntlen;i++)
;;;265    		            {
;;;266    					   if(IsDigitChar(buf[currCharNum+i])==1)
;;;267    					   {
;;;268    					      tmpFg = (tmpFg&0x01);
;;;269    					   }
;;;270    					   else
;;;271    					   {
;;;272    					      tmpFg = 0;
;;;273    					   }
;;;274    		            }
;;;275    					if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;276    					{
;;;277    						return SetErr_ACK(buf, addr ,CMD_ERR);
;;;278    						
;;;279    					}					
;;;280    					for(i=0,temp1=0;i<pntlen;i++)
;;;281    		            {
;;;282    		                  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;283    					}		                   
;;;284    				    if(temp1 > 5)
;;;285    			         {
;;;286    			             return SetErr_ACK(buf, addr ,PARA_ERR);
;;;287    						 
;;;288    			         }
;;;289    					 switch(FLAG_WIN)
;;;290    					 {
;;;291    						 
;;;292    					 }
;;;293    							 FLAG_WIN = temp1;
;;;294    					 buf[currCharNum++] = ChrEndS;
;;;295    		        }
;;;296    				break;
;;;297    				case 3:
;;;298    				pntlen = 1;
;;;299    				if(buf[currCharNum]=='?')
;;;300    				{
;;;301    					  sprintf(&buf[currCharNum],"%1d",C_DISCHARGE);
;;;302    				    currCharNum+=pntlen;
;;;303    				    buf[currCharNum ++] = ChrEndS;
;;;304    					
;;;305    				}
;;;306    				else
;;;307    				{
;;;308    					for(i=0,temp1=0;i<pntlen;i++)
;;;309    		            {
;;;310    		                  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;311    					}		                   
;;;312    				    if(temp1 > 5)
;;;313    			         {
;;;314    			             return SetErr_ACK(buf, addr ,PARA_ERR);
;;;315    						 
;;;316    			         }
;;;317    					 switch(FLAG_WIN)
;;;318    					 {
;;;319    						 
;;;320    					 }
;;;321    							 FLAG_WIN = temp1;
;;;322    					 buf[currCharNum++] = ChrEndS;
;;;323    		        }
;;;324    				break;
;;;325    //			case 2:
;;;326    //				pntlen = 5;    //
;;;327    //				if(buf[currCharNum]=='?')
;;;328    //				{
;;;329    ////					V_CS_Vale = Read_CS1237V();
;;;330    //					
;;;331    //					buf[currCharNum++]=(TEMPV>=0?'+':'-');
;;;332    //					
;;;333    //					sprintf(&buf[currCharNum],"%05d",TEMPV);
;;;334    //					currCharNum+=pntlen;
;;;335    //					buf[currCharNum++]=(TEMPI>=0?'+':'-');
;;;336    //					sprintf(&buf[currCharNum],"%05d",abs(TEMPI));
;;;337    //					currCharNum+=pntlen;
;;;338    //					
;;;339    ////					currCharNum++;
;;;340    //					buf[currCharNum++]=(',');
;;;341    //					sprintf(&buf[currCharNum],"%d",H_L);
;;;342    //					currCharNum++;
;;;343    //					
;;;344    //					buf[currCharNum++]=(',');
;;;345    //					sprintf(&buf[currCharNum],"%d",LM_S);
;;;346    //					currCharNum++;
;;;347    //					
;;;348    //					buf[currCharNum++]=(',');
;;;349    //					sprintf(&buf[currCharNum],"%02d",(int)temperature);
;;;350    //					currCharNum+=2;
;;;351    //					
;;;352    //				  buf[currCharNum++ ] = ChrEndR;
;;;353    //				  buf[currCharNum++ ] = ChrEndS;
;;;354    //				}
;;;355    //				else
;;;356    //				{
;;;357    //					return SetErr_ACK(buf, addr ,CMD_ERR);
;;;358    //				}
;;;359    //				break;
;;;360    //			case 3:
;;;361    //				pntlen = 1;
;;;362    //				if(buf[currCharNum]=='?')
;;;363    //				{
;;;364    //					sprintf(&buf[currCharNum],"%1d",Gmode_Vale);
;;;365    //				    currCharNum+=pntlen;
;;;366    //					buf[currCharNum] = ChrEndR;
;;;367    //					currCharNum++;
;;;368    ////				    buf[currCharNum ++] = ChrEndS;
;;;369    //					
;;;370    //				}
;;;371    //				else
;;;372    //				{
;;;373    //					tmpFg = 1;
;;;374    //		            for(i=0;i<pntlen;i++)
;;;375    //		            {
;;;376    //					   if(IsDigitChar(buf[currCharNum+i])==1)
;;;377    //					   {
;;;378    //					      tmpFg = (tmpFg&0x01);
;;;379    //					   }
;;;380    //					   else
;;;381    //					   {
;;;382    //					      tmpFg = 0;
;;;383    //					   }
;;;384    //		            }
;;;385    //					if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;386    //					{
;;;387    //						return SetErr_ACK(buf, addr ,CMD_ERR);
;;;388    //						
;;;389    //					}					
;;;390    //					for(i=0,temp1=0;i<pntlen;i++)
;;;391    //		            {
;;;392    //		                  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;393    //					}		                   
;;;394    ////				    if(temp1 >Mode_H)
;;;395    ////			         {
;;;396    ////			             return SetErr_ACK(buf, addr ,PARA_ERR);
;;;397    ////						 
;;;398    ////			         }
;;;399    //		        
;;;400    //							 calflag=temp1;
;;;401    //							if(calflag == 3)
;;;402    //							{
;;;403    //								LVL_DA = 5000;
;;;404    //							}
;;;405    ////							Change_MODE_Val(Mode);
;;;406    //					 buf[currCharNum++] = ChrEndS;
;;;407    //		        }
;;;408    //				break;
;;;409    //			case 4:
;;;410    //				pntlen = 10;    //
;;;411    //				if(buf[currCharNum]=='?')
;;;412    //				{
;;;413    //					I_CS_Vale = Read_CS1237();
;;;414    //					
;;;415    //					buf[currCharNum++]=(TEMPI>=0?'+':'-');
;;;416    //					sprintf(&buf[currCharNum],"%05d",TEMPI);
;;;417    //					currCharNum+=pntlen;
;;;418    //				  buf[currCharNum++ ] = ChrEndR;
;;;419    //				  buf[currCharNum++ ] = ChrEndS;
;;;420    //					
;;;421    //				}
;;;422    //				else
;;;423    //				{
;;;424    //					return SetErr_ACK(buf, addr ,CMD_ERR);
;;;425    //		    }
;;;426    //				break;
;;;427    //			case 5:
;;;428    //				pntlen = 7;
;;;429    //				if(buf[currCharNum]=='?')
;;;430    //				{
;;;431    //					I_ADC_Vale = Get_Adc_Average(ADC_Channel_14,3);
;;;432    //					fadcx=(Vref*(((float)I_ADC_Vale/4096))); 
;;;433    //					sprintf(&buf[currCharNum],"%01.5f",fadcx);
;;;434    //				//	sprintf(&buf[currCharNum],"%07d",I_ADC_Vale);
;;;435    //				    currCharNum+=pntlen;
;;;436    //				    buf[currCharNum++ ] = ChrEndS;
;;;437    //					
;;;438    //				}
;;;439    //				else
;;;440    //				{
;;;441    //					return SetErr_ACK(buf, addr ,CMD_ERR);
;;;442    //		    }
;;;443    //		  
;;;444    //				break;
;;;445    //			case 6:
;;;446    //				pntlen = 1;
;;;447    //				if(buf[currCharNum]=='?')
;;;448    //				{
;;;449    //					sprintf(&buf[currCharNum],"%1d",LM_S_Vale);
;;;450    //				    currCharNum+=pntlen;
;;;451    //				    buf[currCharNum++ ] = ChrEndR;
;;;452    //					
;;;453    //				}
;;;454    //				else
;;;455    //				{
;;;456    //					tmpFg = 1;
;;;457    //		            for(i=0;i<pntlen;i++)
;;;458    //		            {
;;;459    //					   if(IsDigitChar(buf[currCharNum+i])==1)
;;;460    //					   {
;;;461    //					      tmpFg = (tmpFg&0x01);
;;;462    //					   }
;;;463    //					   else
;;;464    //					   {
;;;465    //					      tmpFg = 0;
;;;466    //					   }
;;;467    //		            }
;;;468    //					if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;469    //					{
;;;470    //						return SetErr_ACK(buf, addr ,CMD_ERR);
;;;471    //						
;;;472    //					}					
;;;473    //					for(i=0,temp1=0;i<pntlen;i++)
;;;474    //		            {
;;;475    //		                  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;476    //					}		                   
;;;477    //				    if(temp1>LM_S_H)
;;;478    //			         {
;;;479    //			             return SetErr_ACK(buf, addr ,PARA_ERR);
;;;480    //						 
;;;481    //			         }
;;;482    //		        	 LM_S=temp1;
;;;483    ////					 if(calflag == 0)
;;;484    ////					 {
;;;485    //						Change_H_L_Vale(1);
;;;486    ////					 }
;;;487    ////					 SWITCH_Vale=temp1;
;;;488    ////					 H_L_Vale = temp1;
;;;489    ////					 Change_SWITCH_Val(SWITCH_Vale);
;;;490    ////					 SWITCH_A = temp1;
;;;491    ////					 Switch(0);
;;;492    ////					  if(temp1 == 0)
;;;493    ////					  {
;;;494    ////						 Output_DAC8562(Voltage_Convert(0), Voltage_Convert(0));
;;;495    ////					  }
;;;496    ////					 Change_LM_Val(LM_S_Vale);
;;;497    //					
;;;498    ////					 Change_H_L_Vale(H_L_Vale);
;;;499    //					 buf[currCharNum++] = ChrEndR;
;;;500    //		        }
;;;501    //				break;
;;;502    //			case 7:
;;;503    //				pntlen = 7;
;;;504    //				if(buf[currCharNum]=='?')
;;;505    //				{
;;;506    //					V_ADC_Vale = Get_Adc_Average(ADC_Channel_15,3);
;;;507    //					fadcx=(Vref*(((float)V_ADC_Vale/4096))); 
;;;508    //							sprintf(&buf[currCharNum],"%01.5f",fadcx);
;;;509    //					//V_ADC_Vale = Get_Adc_Average(15,5);
;;;510    //					//sprintf(&buf[currCharNum],"%07d",V_ADC_Vale);
;;;511    //				  currCharNum+=pntlen;
;;;512    //				  buf[currCharNum++ ] = ChrEndS;
;;;513    //				}
;;;514    //				else
;;;515    //				{
;;;516    //					return SetErr_ACK(buf, addr ,CMD_ERR);
;;;517    //		    }
;;;518    //				break;
;;;519    //			case 8:
;;;520    //				pntlen = 1;
;;;521    //				if(buf[currCharNum]=='?')
;;;522    //				{
;;;523    //					LOW_I_Vale = OverI();
;;;524    //					LOW_I = LOW_I_Vale;
;;;525    //					sprintf(&buf[currCharNum],"%1d",LOW_I_Vale);
;;;526    //				    currCharNum+=pntlen;
;;;527    //				    buf[currCharNum++ ] = ChrEndS;
;;;528    //					
;;;529    //				}
;;;530    //				else
;;;531    //				{
;;;532    //					tmpFg = 1;
;;;533    //		            for(i=0;i<pntlen;i++)
;;;534    //		            {
;;;535    //					   if(IsDigitChar(buf[currCharNum+i])==1)
;;;536    //					   {
;;;537    //					      tmpFg = (tmpFg&0x01);
;;;538    //					   }
;;;539    //					   else
;;;540    //					   {
;;;541    //					      tmpFg = 0;
;;;542    //					   }
;;;543    //		            }
;;;544    //					if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;545    //					{
;;;546    //						return SetErr_ACK(buf, addr ,CMD_ERR);
;;;547    //						
;;;548    //					}					
;;;549    //					for(i=0,temp1=0;i<pntlen;i++)
;;;550    //		            {
;;;551    //		                  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;552    //					}		                   
;;;553    //				    if(temp1>SWITCH_A_H)
;;;554    //			         {
;;;555    //			             return SetErr_ACK(buf, addr ,PARA_ERR);
;;;556    //						 
;;;557    //			         }
;;;558    //		        	 LOW_I_Vale=temp1;
;;;559    //							Change_LOW_I_Val(LOW_I_Vale);
;;;560    //					 buf[currCharNum++] = ChrEndR;
;;;561    //		        }
;;;562    //				
;;;563    //				break;
;;;564    //			case 9:
;;;565    //				pntlen = 1;
;;;566    //				if(buf[currCharNum]=='?')
;;;567    //				{
;;;568    //					sprintf(&buf[currCharNum],"%1d",H_L_Vale);
;;;569    //				    currCharNum+=pntlen;
;;;570    //				    buf[currCharNum ++] = ChrEndS;
;;;571    //					
;;;572    //				}
;;;573    //				else
;;;574    //				{
;;;575    //					tmpFg = 1;
;;;576    //		            for(i=0;i<pntlen;i++)
;;;577    //		            {
;;;578    //					   if(IsDigitChar(buf[currCharNum+i])==1)
;;;579    //					   {
;;;580    //					      tmpFg = (tmpFg&0x01);
;;;581    //					   }
;;;582    //					   else
;;;583    //					   {
;;;584    //					      tmpFg = 0;
;;;585    //					   }
;;;586    //		            }
;;;587    //					if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;588    //					{
;;;589    //						return SetErr_ACK(buf, addr ,CMD_ERR);
;;;590    //						
;;;591    //					}					
;;;592    //					for(i=0,temp1=0;i<pntlen;i++)
;;;593    //		            {
;;;594    //		                  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;595    //					}		                   
;;;596    //				    if(temp1 >1)
;;;597    //			         {
;;;598    //			             return SetErr_ACK(buf, addr ,PARA_ERR);
;;;599    //						 
;;;600    //			         }
;;;601    
;;;602    //							 H_L_Vale=temp1;
;;;603    //							 H_L = temp1;
;;;604    //							Change_H_L_Vale(H_L_Vale);
;;;605    //					 buf[currCharNum++] = ChrEndR;
;;;606    //		        }
;;;607    //				break;
;;;608    //			case 10:
;;;609    //				pntlen = 8;
;;;610    //				if(buf[currCharNum]=='?')
;;;611    //				{
;;;612    //					buf[currCharNum++]=(Lvl_Vale>=0?'+':'-');
;;;613    //								sprintf(&buf[currCharNum],"%03.3f",Lvl_Vale);
;;;614    //				    currCharNum+=pntlen;
;;;615    //				    buf[currCharNum++ ] = ChrEndS;
;;;616    //				}
;;;617    ////				else
;;;618    ////				{
;;;619    ////					tmpFg = 1;
;;;620    ////		            for(i=0;i<pntlen;i++)
;;;621    ////		            {
;;;622    ////									if(i==0||i==4)
;;;623    ////										continue;
;;;624    ////					   if(IsDigitChar(buf[currCharNum+i])==1)
;;;625    ////					   {
;;;626    ////					      tmpFg = (tmpFg&0x01);
;;;627    ////					   }
;;;628    ////					   else
;;;629    ////					   {
;;;630    ////					      tmpFg = 0;
;;;631    ////					   }
;;;632    ////		            }
;;;633    ////					if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;634    ////					{
;;;635    ////						return SetErr_ACK(buf, addr ,CMD_ERR);
;;;636    ////						
;;;637    ////					}
;;;638    ////					temp1=0;
;;;639    ////					for(i=0;i<pntlen;i++)
;;;640    ////		            {
;;;641    ////		               if(i==0)
;;;642    ////					   {
;;;643    ////						   fsingal = (buf[currCharNum++]=='+'?1:(-1));
;;;644    ////						   continue; 
;;;645    ////					   } 
;;;646    ////					   else if(i==4)
;;;647    ////					   {
;;;648    ////						   currCharNum++;
;;;649    ////						   continue; 
;;;650    ////					   }
;;;651    ////					   else									 
;;;652    ////					   temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;653    ////					}		                   
;;;654    //					if(buf[currCharNum]=='+')
;;;655    //					{
;;;656    //						fsingal = 1;
;;;657    //						temp1 = 0;
;;;658    //						currCharNum++;
;;;659    //						for(i=0;i<7;i++)
;;;660    //						{
;;;661    //							if(i == 3)
;;;662    //							{
;;;663    //								currCharNum++;
;;;664    //								continue;
;;;665    //							}else{
;;;666    //								temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;667    //							}
;;;668    //						}
;;;669    ////						Lvl_Vale=temp1*0.0001*fsingal;
;;;670    //						Lvl_Vale=temp1;
;;;671    //						LVL_DA =Lvl_Vale;
;;;672    //	//					currCharNum++;
;;;673    //						temp1 = 0;
;;;674    //						
;;;675    //						if(buf[currCharNum]==',')
;;;676    //						{
;;;677    //							currCharNum++;
;;;678    //							for(i=0;i<7;i++)
;;;679    //							{
;;;680    //								if(i == 3)
;;;681    //								{
;;;682    //									currCharNum++;
;;;683    //									continue;
;;;684    //								}else{
;;;685    //									temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;686    //								}
;;;687    //							}
;;;688    //						}						
;;;689    //						ChargePC = temp1;
;;;690    //						temp1 = 0;
;;;691    //						
;;;692    //						if(buf[currCharNum]==',')
;;;693    //						{
;;;694    //							currCharNum++;
;;;695    //							for(i=0;i<7;i++)
;;;696    //							{
;;;697    //								if(i == 3)
;;;698    //								{
;;;699    //									currCharNum++;
;;;700    //									continue;
;;;701    //								}else{
;;;702    //									temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;703    //								}
;;;704    //							}
;;;705    //						}						
;;;706    //						LoadPC = temp1;
;;;707    //						temp1 = 0;
;;;708    //						
;;;709    //						if(buf[currCharNum]==',')
;;;710    //						{
;;;711    //							currCharNum++;
;;;712    //							for(i=0;i<3;i++)
;;;713    //							{
;;;714    //								temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;715    //							}
;;;716    //						}						
;;;717    //						charget = temp1;
;;;718    //						temp1 = 0;
;;;719    //						
;;;720    //						if(buf[currCharNum]==',')
;;;721    //						{
;;;722    //							currCharNum++;
;;;723    //							for(i=0;i<3;i++)
;;;724    //							{
;;;725    //								temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;726    //							}
;;;727    //						}						
;;;728    //						loadt = temp1;
;;;729    //						
;;;730    ////						temp1 = 0;
;;;731    ////						currCharNum++;
;;;732    ////						if(buf[currCharNum++] == ',')
;;;733    ////						{
;;;734    ////							temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;735    ////							Irange = temp1;
;;;736    ////						}
;;;737    ////					}
;;;738    //               
;;;739    ////							  Lvl_Vale=temp1*0.0001*fsingal;
;;;740    ////						    LVL_DA =Lvl_Vale;
;;;741    ////							Voltage_Convert(LVL_DA);
;;;742    //					 buf[currCharNum++] = ChrEndR;
;;;743    //		        }
;;;744    //				break;
;;;745    //			case 11:
;;;746    //				pntlen = 1;
;;;747    //				if(buf[currCharNum]=='?')
;;;748    //				{
;;;749    //					sprintf(&buf[currCharNum],"%1d",SWITCH_Vale);
;;;750    //				    currCharNum+=pntlen;
;;;751    //				    buf[currCharNum++ ] = ChrEndS;
;;;752    //					
;;;753    //				}
;;;754    //				else
;;;755    //				{
;;;756    //					tmpFg = 1;
;;;757    //		            for(i=0;i<pntlen;i++)
;;;758    //		            {
;;;759    //					   if(IsDigitChar(buf[currCharNum+i])==1)
;;;760    //					   {
;;;761    //					      tmpFg = (tmpFg&0x01);
;;;762    //					   }
;;;763    //					   else
;;;764    //					   {
;;;765    //					      tmpFg = 0;
;;;766    //					   }
;;;767    //		            }
;;;768    //					if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;769    //					{
;;;770    //						return SetErr_ACK(buf, addr ,CMD_ERR);
;;;771    //						
;;;772    //					}					
;;;773    //					for(i=0,temp1=0;i<pntlen;i++)
;;;774    //		            {
;;;775    //		                  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;776    //					}		                   
;;;777    //				    if(temp1>SWITCH_A_H)
;;;778    //			         {
;;;779    //			             return SetErr_ACK(buf, addr ,PARA_ERR);
;;;780    //						 
;;;781    //			         }
;;;782    //		        	 SWITCH_Vale=temp1;
;;;783    //							Change_SWITCH_Val(SWITCH_Vale);
;;;784    //					 buf[currCharNum++] = ChrEndR;
;;;785    //		        }
;;;786    //				break;
;;;787    //				case 12:
;;;788    //				{
;;;789    //					pntlen = 8;
;;;790    //					if(buf[currCharNum]=='?')
;;;791    //					{
;;;792    //						buf[currCharNum++]=(Lvl_Vale>=0?'+':'-');
;;;793    //									sprintf(&buf[currCharNum],"%03.3f",Lvl_Vale);
;;;794    //						currCharNum+=pntlen;
;;;795    //						buf[currCharNum++ ] = ChrEndS;
;;;796    //					}
;;;797    //					else
;;;798    //					{
;;;799    //						tmpFg = 1;
;;;800    //						for(i=0;i<pntlen;i++)
;;;801    //						{
;;;802    //						   if(i==0||i==4)
;;;803    //							  continue;
;;;804    //						   if(IsDigitChar(buf[currCharNum+i])==1)
;;;805    //						   {
;;;806    //							  tmpFg = (tmpFg&0x01);
;;;807    //						   }
;;;808    //						   else
;;;809    //						   {
;;;810    //							  tmpFg = 0;
;;;811    //						   }
;;;812    //						}
;;;813    //						if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;814    //						{
;;;815    //							return SetErr_ACK(buf, addr ,CMD_ERR);
;;;816    //							
;;;817    //						}
;;;818    //						temp1=0;
;;;819    //						for(i=0;i<pntlen;i++)
;;;820    //						{
;;;821    //						   if(i==0)
;;;822    //						   {
;;;823    //							   fsingal = buf[currCharNum++]-0x30;
;;;824    //							   continue; 
;;;825    //						   } 
;;;826    //						   else if(i==4)
;;;827    //						   {
;;;828    //							   currCharNum++;
;;;829    //							   continue; 
;;;830    //						   }
;;;831    //						   else									 
;;;832    //						   temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;833    //						}	
;;;834    //						CalHandle(0,fsingal,temp1);
;;;835    //						
;;;836    //					}
;;;837    //				}break;
;;;838    //				case 13:
;;;839    //				{
;;;840    //					pntlen = 8;
;;;841    //					if(buf[currCharNum]=='?')
;;;842    //					{
;;;843    //						buf[currCharNum++]=(Lvl_Vale>=0?'+':'-');
;;;844    //									sprintf(&buf[currCharNum],"%03.3f",Lvl_Vale);
;;;845    //						currCharNum+=pntlen;
;;;846    //						buf[currCharNum++ ] = ChrEndS;
;;;847    //					}
;;;848    //					else
;;;849    //					{
;;;850    //						tmpFg = 1;
;;;851    //						for(i=0;i<pntlen;i++)
;;;852    //						{
;;;853    //						   if(i==0||i==4)
;;;854    //							  continue;
;;;855    //						   if(IsDigitChar(buf[currCharNum+i])==1)
;;;856    //						   {
;;;857    //							  tmpFg = (tmpFg&0x01);
;;;858    //						   }
;;;859    //						   else
;;;860    //						   {
;;;861    //							  tmpFg = 0;
;;;862    //						   }
;;;863    //						}
;;;864    //						if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;865    //						{
;;;866    //							return SetErr_ACK(buf, addr ,CMD_ERR);
;;;867    //							
;;;868    //						}
;;;869    //						temp1=0;
;;;870    //						for(i=0;i<pntlen;i++)
;;;871    //						{
;;;872    //						   if(i==0)
;;;873    //						   {
;;;874    //							   fsingal = buf[currCharNum++]-0x30;
;;;875    //							   continue; 
;;;876    //						   } 
;;;877    //						   else if(i==4)
;;;878    //						   {
;;;879    //							   currCharNum++;
;;;880    //							   continue; 
;;;881    //						   }
;;;882    //						   else									 
;;;883    //						   temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;884    //						}	
;;;885    //						CalHandle(1,fsingal,temp1);
;;;886    //						
;;;887    //					}
;;;888    //				}break;
;;;889    //				case 14://控制电压校准
;;;890    //				{
;;;891    //					pntlen = 8;
;;;892    //					if(buf[currCharNum]=='?')
;;;893    //					{
;;;894    //						buf[currCharNum++]=(Lvl_Vale>=0?'+':'-');
;;;895    //									sprintf(&buf[currCharNum],"%03.3f",Lvl_Vale);
;;;896    //						currCharNum+=pntlen;
;;;897    //						buf[currCharNum++ ] = ChrEndS;
;;;898    //					}
;;;899    //					else
;;;900    //					{
;;;901    //						tmpFg = 1;
;;;902    //						for(i=0;i<pntlen;i++)
;;;903    //						{
;;;904    //						   if(i==0||i==4)
;;;905    //							  continue;
;;;906    //						   if(IsDigitChar(buf[currCharNum+i])==1)
;;;907    //						   {
;;;908    //							  tmpFg = (tmpFg&0x01);
;;;909    //						   }
;;;910    //						   else
;;;911    //						   {
;;;912    //							  tmpFg = 0;
;;;913    //						   }
;;;914    //						}
;;;915    //						if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;916    //						{
;;;917    //							return SetErr_ACK(buf, addr ,CMD_ERR);
;;;918    //							
;;;919    //						}
;;;920    //						temp1=0;
;;;921    //						for(i=0;i<pntlen;i++)
;;;922    //						{
;;;923    //						   if(i==0)
;;;924    //						   {
;;;925    //							   fsingal = buf[currCharNum++]-0x30;
;;;926    //							   continue; 
;;;927    //						   } 
;;;928    //						   else if(i==4)
;;;929    //						   {
;;;930    //							   currCharNum++;
;;;931    //							   continue; 
;;;932    //						   }
;;;933    //						   else									 
;;;934    //						   temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;935    //						}
;;;936    //						CalHandle(2,fsingal,temp1);
;;;937    //						
;;;938    //					}
;;;939    //				}break;
;;;940    //				case 15:
;;;941    //				{
;;;942    //					pntlen = 1;
;;;943    //					if(buf[currCharNum]=='?')
;;;944    //					{
;;;945    //						sprintf(&buf[currCharNum],"%1d",Gmode_Vale);
;;;946    //						currCharNum+=pntlen;
;;;947    //						buf[currCharNum] = ChrEndR;
;;;948    //						currCharNum++;
;;;949    //	//				    buf[currCharNum ++] = ChrEndS;
;;;950    //						
;;;951    //					}
;;;952    //					else
;;;953    //					{
;;;954    //						tmpFg = 1;
;;;955    //						for(i=0;i<pntlen;i++)
;;;956    //						{
;;;957    //						   if(IsDigitChar(buf[currCharNum+i])==1)
;;;958    //						   {
;;;959    //							  tmpFg = (tmpFg&0x01);
;;;960    //						   }
;;;961    //						   else
;;;962    //						   {
;;;963    //							  tmpFg = 0;
;;;964    //						   }
;;;965    //						}
;;;966    //						if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;967    //						{
;;;968    //							return SetErr_ACK(buf, addr ,CMD_ERR);
;;;969    //							
;;;970    //						}					
;;;971    //						for(i=0,temp1=0;i<pntlen;i++)
;;;972    //						{
;;;973    //							  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;974    //						}		                   
;;;975    //						if(temp1 >Mode_H)
;;;976    //						 {
;;;977    //							 return SetErr_ACK(buf, addr ,PARA_ERR);
;;;978    //							 
;;;979    //						 }
;;;980    //						 if(H_L == 1)
;;;981    //						 {
;;;982    //							CalHandle(3,1,temp1);
;;;983    //						 }else{
;;;984    //							 CalHandle(3,0,temp1);
;;;985    //						 }
;;;986    //						 
;;;987    ////								 Mode=temp1;
;;;988    ////								Change_MODE_Val(Mode);
;;;989    ////						 buf[currCharNum++] = ChrEndS;
;;;990    //					}
;;;991    //					break;
;;;992    //				}break;
;;;993    //				case 16:
;;;994    //				{
;;;995    //					pntlen = 3;
;;;996    //					if(buf[currCharNum]=='?')
;;;997    //					{
;;;998    //						sprintf(&buf[currCharNum],"%1d",Gmode_Vale);
;;;999    //						currCharNum+=pntlen;
;;;1000   //						buf[currCharNum] = ChrEndR;
;;;1001   //						currCharNum++;
;;;1002   //	//				    buf[currCharNum ++] = ChrEndS;
;;;1003   //						
;;;1004   //					}
;;;1005   //					else
;;;1006   //					{
;;;1007   //						tmpFg = 1;
;;;1008   //						for(i=0;i<pntlen;i++)
;;;1009   //						{
;;;1010   //						   if(IsDigitChar(buf[currCharNum+i])==1)
;;;1011   //						   {
;;;1012   //							  tmpFg = (tmpFg&0x01);
;;;1013   //						   }
;;;1014   //						   else
;;;1015   //						   {
;;;1016   //							  tmpFg = 0;
;;;1017   //						   }
;;;1018   //						}
;;;1019   //						if(tmpFg!=1||buf[currCharNum+pntlen]!=ChrEndR)
;;;1020   //						{
;;;1021   //							return SetErr_ACK(buf, addr ,CMD_ERR);
;;;1022   //							
;;;1023   //						}					
;;;1024   //						for(i=0,temp1=0;i<pntlen;i++)
;;;1025   //						{
;;;1026   //							  temp1 = temp1*10+(buf[currCharNum++]-0x30);
;;;1027   //						}		                   
;;;1028   //						 overflag = temp1;
;;;1029   //						 
;;;1030   ////								 Mode=temp1;
;;;1031   ////								Change_MODE_Val(Mode);
;;;1032   ////						 buf[currCharNum++] = ChrEndS;
;;;1033   //					}
;;;1034   //					break;
;;;1035   //				}break;
;;;1036   //				case 17:
;;;1037   //				{
;;;1038   //					pntlen = 2;
;;;1039   //					if(buf[currCharNum]=='?')
;;;1040   //					{
;;;1041   ////						buf[currCharNum++]=(Lvl_Vale>=0?'+':'-');
;;;1042   //									sprintf(&buf[currCharNum],"%02d",(int)temperature);
;;;1043   //						currCharNum+=pntlen;
;;;1044   //						buf[currCharNum++ ] = ChrEndR;
;;;1045   //						buf[currCharNum++ ] = ChrEndS;
;;;1046   //					}
;;;1047   //				}break;
;;;1048   			default:    //ERR
;;;1049              		 return SetErr_ACK(buf, addr ,CMD_ERR);
;;;1050   				  
;;;1051   		  }
;;;1052   		  break;
;;;1053   		}
;;;1054   		
;;;1055   	}
;;;1056   	if(j>=CmdNumb)
;;;1057   	{
;;;1058   		return SetErr_ACK(buf, addr ,CMD_ERR);			  
;;;1059   	}
;;;1060   	return currCharNum+1;
;;;1061   }
000046  b037              ADD      sp,sp,#0xdc
000048  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.76|
00004c  223c              MOVS     r2,#0x3c              ;144
00004e  4620              MOV      r0,r4                 ;144
000050  1c61              ADDS     r1,r4,#1              ;144
000052  b28c              UXTH     r4,r1                 ;144
000054  a904              ADD      r1,sp,#0x10           ;144
000056  540a              STRB     r2,[r1,r0]            ;144
000058  1908              ADDS     r0,r1,r4              ;145
00005a  a1ce              ADR      r1,|L2.916|
00005c  9a36              LDR      r2,[sp,#0xd8]         ;145
00005e  f7fffffe          BL       __2sprintf
000062  2201              MOVS     r2,#1                 ;146
000064  a1cc              ADR      r1,|L2.920|
000066  a804              ADD      r0,sp,#0x10           ;146
000068  f7fffffe          BL       strncat
00006c  a804              ADD      r0,sp,#0x10           ;147
00006e  f7fffffe          BL       strlen
000072  b284              UXTH     r4,r0                 ;147
000074  a804              ADD      r0,sp,#0x10           ;148
000076  f7fffffe          BL       strlen
00007a  4602              MOV      r2,r0                 ;148
00007c  a904              ADD      r1,sp,#0x10           ;148
00007e  9001              STR      r0,[sp,#4]            ;148
000080  4628              MOV      r0,r5                 ;148
000082  f7fffffe          BL       strncmp
000086  9003              STR      r0,[sp,#0xc]          ;148
000088  9803              LDR      r0,[sp,#0xc]          ;150
00008a  b128              CBZ      r0,|L2.152|
00008c  2202              MOVS     r2,#2                 ;152
00008e  4628              MOV      r0,r5                 ;152
000090  9936              LDR      r1,[sp,#0xd8]         ;152
000092  f7fffffe          BL       SetErr_ACK
000096  e7d6              B        |L2.70|
                  |L2.152|
000098  f04f0900          MOV      r9,#0                 ;155
00009c  e168              B        |L2.880|
                  |L2.158|
00009e  eb0901c9          ADD      r1,r9,r9,LSL #3       ;157
0000a2  4abe              LDR      r2,|L2.924|
0000a4  1888              ADDS     r0,r1,r2              ;157
0000a6  f7fffffe          BL       strlen
0000aa  b2c0              UXTB     r0,r0                 ;157
0000ac  9002              STR      r0,[sp,#8]            ;157
0000ae  eb0902c9          ADD      r2,r9,r9,LSL #3       ;158
0000b2  4bba              LDR      r3,|L2.924|
0000b4  18d1              ADDS     r1,r2,r3              ;158
0000b6  1928              ADDS     r0,r5,r4              ;158
0000b8  9a02              LDR      r2,[sp,#8]            ;158
0000ba  f7fffffe          BL       strncmp
0000be  9003              STR      r0,[sp,#0xc]          ;158
0000c0  9803              LDR      r0,[sp,#0xc]          ;159
0000c2  2800              CMP      r0,#0                 ;159
0000c4  d175              BNE      |L2.434|
0000c6  203e              MOVS     r0,#0x3e              ;162
0000c8  7028              STRB     r0,[r5,#0]            ;162
0000ca  9802              LDR      r0,[sp,#8]            ;163
0000cc  4420              ADD      r0,r0,r4              ;163
0000ce  b284              UXTH     r4,r0                 ;163
0000d0  f1b90f00          CMP      r9,#0                 ;164
0000d4  d009              BEQ      |L2.234|
0000d6  f1b90f01          CMP      r9,#1                 ;164
0000da  d058              BEQ      |L2.398|
0000dc  f1b90f02          CMP      r9,#2                 ;164
0000e0  d068              BEQ      |L2.436|
0000e2  f1b90f03          CMP      r9,#3                 ;164
0000e6  d173              BNE      |L2.464|
0000e8  e0ff              B        |L2.746|
                  |L2.234|
0000ea  2705              MOVS     r7,#5                 ;167
0000ec  5d28              LDRB     r0,[r5,r4]            ;168
0000ee  283f              CMP      r0,#0x3f              ;168
0000f0  d146              BNE      |L2.384|
0000f2  49ab              LDR      r1,|L2.928|
0000f4  6aca              LDR      r2,[r1,#0x2c]         ;172  ; CLists
0000f6  1928              ADDS     r0,r5,r4              ;172
0000f8  a1aa              ADR      r1,|L2.932|
0000fa  f7fffffe          BL       __2sprintf
0000fe  19e0              ADDS     r0,r4,r7              ;173
000100  b284              UXTH     r4,r0                 ;173
000102  222c              MOVS     r2,#0x2c              ;175
000104  4620              MOV      r0,r4                 ;175
000106  1c61              ADDS     r1,r4,#1              ;175
000108  b28c              UXTH     r4,r1                 ;175
00010a  542a              STRB     r2,[r5,r0]            ;175
00010c  49a4              LDR      r1,|L2.928|
00010e  6b4a              LDR      r2,[r1,#0x34]         ;176  ; CLists
000110  1928              ADDS     r0,r5,r4              ;176
000112  a1a4              ADR      r1,|L2.932|
000114  f7fffffe          BL       __2sprintf
000118  19e0              ADDS     r0,r4,r7              ;177
00011a  b284              UXTH     r4,r0                 ;177
00011c  222c              MOVS     r2,#0x2c              ;179
00011e  4620              MOV      r0,r4                 ;179
000120  1c61              ADDS     r1,r4,#1              ;179
000122  b28c              UXTH     r4,r1                 ;179
000124  542a              STRB     r2,[r5,r0]            ;179
000126  499e              LDR      r1,|L2.928|
000128  6a8a              LDR      r2,[r1,#0x28]         ;180  ; CLists
00012a  1928              ADDS     r0,r5,r4              ;180
00012c  a19d              ADR      r1,|L2.932|
00012e  f7fffffe          BL       __2sprintf
000132  19e0              ADDS     r0,r4,r7              ;181
000134  b284              UXTH     r4,r0                 ;181
000136  222c              MOVS     r2,#0x2c              ;183
000138  4620              MOV      r0,r4                 ;183
00013a  1c61              ADDS     r1,r4,#1              ;183
00013c  b28c              UXTH     r4,r1                 ;183
00013e  542a              STRB     r2,[r5,r0]            ;183
000140  4997              LDR      r1,|L2.928|
000142  6b0a              LDR      r2,[r1,#0x30]         ;184  ; CLists
000144  1928              ADDS     r0,r5,r4              ;184
000146  a197              ADR      r1,|L2.932|
000148  f7fffffe          BL       __2sprintf
00014c  19e0              ADDS     r0,r4,r7              ;185
00014e  b284              UXTH     r4,r0                 ;185
000150  222c              MOVS     r2,#0x2c              ;187
000152  4620              MOV      r0,r4                 ;187
000154  1c61              ADDS     r1,r4,#1              ;187
000156  b28c              UXTH     r4,r1                 ;187
000158  542a              STRB     r2,[r5,r0]            ;187
00015a  4991              LDR      r1,|L2.928|
00015c  6b8a              LDR      r2,[r1,#0x38]         ;188  ; CLists
00015e  1928              ADDS     r0,r5,r4              ;188
000160  a190              ADR      r1,|L2.932|
000162  f7fffffe          BL       __2sprintf
000166  19e0              ADDS     r0,r4,r7              ;189
000168  b284              UXTH     r4,r0                 ;189
00016a  220d              MOVS     r2,#0xd               ;203
00016c  4620              MOV      r0,r4                 ;203
00016e  1c61              ADDS     r1,r4,#1              ;203
000170  b28c              UXTH     r4,r1                 ;203
000172  542a              STRB     r2,[r5,r0]            ;203
000174  220a              MOVS     r2,#0xa               ;204
000176  4620              MOV      r0,r4                 ;204
000178  1c61              ADDS     r1,r4,#1              ;204
00017a  b28c              UXTH     r4,r1                 ;204
00017c  542a              STRB     r2,[r5,r0]            ;204
00017e  e005              B        |L2.396|
                  |L2.384|
000180  2202              MOVS     r2,#2                 ;208
000182  4628              MOV      r0,r5                 ;208
000184  9936              LDR      r1,[sp,#0xd8]         ;208
000186  f7fffffe          BL       SetErr_ACK
00018a  e75c              B        |L2.70|
                  |L2.396|
00018c  e0ea              B        |L2.868|
                  |L2.398|
00018e  2701              MOVS     r7,#1                 ;212
000190  5d28              LDRB     r0,[r5,r4]            ;213
000192  283f              CMP      r0,#0x3f              ;213
000194  d10f              BNE      |L2.438|
000196  1928              ADDS     r0,r5,r4              ;215
000198  4984              LDR      r1,|L2.940|
00019a  780a              LDRB     r2,[r1,#0]            ;215  ; FLAG_WIN
00019c  a184              ADR      r1,|L2.944|
00019e  f7fffffe          BL       __2sprintf
0001a2  19e0              ADDS     r0,r4,r7              ;216
0001a4  b284              UXTH     r4,r0                 ;216
0001a6  220a              MOVS     r2,#0xa               ;217
0001a8  4620              MOV      r0,r4                 ;217
0001aa  1c61              ADDS     r1,r4,#1              ;217
0001ac  b28c              UXTH     r4,r1                 ;217
0001ae  542a              STRB     r2,[r5,r0]            ;217
0001b0  e043              B        |L2.570|
                  |L2.434|
0001b2  e0d9              B        |L2.872|
                  |L2.436|
0001b4  e042              B        |L2.572|
                  |L2.438|
0001b6  f04f0a01          MOV      r10,#1                ;222
0001ba  2600              MOVS     r6,#0                 ;223
0001bc  e00d              B        |L2.474|
                  |L2.446|
0001be  19a1              ADDS     r1,r4,r6              ;225
0001c0  5c68              LDRB     r0,[r5,r1]            ;225
0001c2  f7fffffe          BL       IsDigitChar
0001c6  2801              CMP      r0,#1                 ;225
0001c8  d103              BNE      |L2.466|
0001ca  f00a0a01          AND      r10,r10,#1            ;227
0001ce  e002              B        |L2.470|
                  |L2.464|
0001d0  e0c2              B        |L2.856|
                  |L2.466|
0001d2  f04f0a00          MOV      r10,#0                ;231
                  |L2.470|
0001d6  1c70              ADDS     r0,r6,#1              ;223
0001d8  b2c6              UXTB     r6,r0                 ;223
                  |L2.474|
0001da  42be              CMP      r6,r7                 ;223
0001dc  dbef              BLT      |L2.446|
0001de  f1ba0f01          CMP      r10,#1                ;234
0001e2  d103              BNE      |L2.492|
0001e4  19e0              ADDS     r0,r4,r7              ;234
0001e6  5c28              LDRB     r0,[r5,r0]            ;234
0001e8  280d              CMP      r0,#0xd               ;234
0001ea  d005              BEQ      |L2.504|
                  |L2.492|
0001ec  2202              MOVS     r2,#2                 ;236
0001ee  4628              MOV      r0,r5                 ;236
0001f0  9936              LDR      r1,[sp,#0xd8]         ;236
0001f2  f7fffffe          BL       SetErr_ACK
0001f6  e726              B        |L2.70|
                  |L2.504|
0001f8  2600              MOVS     r6,#0                 ;239
0001fa  46b0              MOV      r8,r6                 ;239
0001fc  e00a              B        |L2.532|
                  |L2.510|
0001fe  4620              MOV      r0,r4                 ;241
000200  1c61              ADDS     r1,r4,#1              ;241
000202  b28c              UXTH     r4,r1                 ;241
000204  5c28              LDRB     r0,[r5,r0]            ;241
000206  3830              SUBS     r0,r0,#0x30           ;241
000208  eb080188          ADD      r1,r8,r8,LSL #2       ;241
00020c  eb000841          ADD      r8,r0,r1,LSL #1       ;241
000210  1c70              ADDS     r0,r6,#1              ;239
000212  b2c6              UXTB     r6,r0                 ;239
                  |L2.532|
000214  42be              CMP      r6,r7                 ;239
000216  dbf2              BLT      |L2.510|
000218  f1b80f05          CMP      r8,#5                 ;243
00021c  d905              BLS      |L2.554|
00021e  2201              MOVS     r2,#1                 ;245
000220  4628              MOV      r0,r5                 ;245
000222  9936              LDR      r1,[sp,#0xd8]         ;245
000224  f7fffffe          BL       SetErr_ACK
000228  e70d              B        |L2.70|
                  |L2.554|
00022a  4960              LDR      r1,|L2.940|
00022c  f8818000          STRB     r8,[r1,#0]            ;248
000230  220a              MOVS     r2,#0xa               ;249
000232  4620              MOV      r0,r4                 ;249
000234  1c61              ADDS     r1,r4,#1              ;249
000236  b28c              UXTH     r4,r1                 ;249
000238  542a              STRB     r2,[r5,r0]            ;249
                  |L2.570|
00023a  e093              B        |L2.868|
                  |L2.572|
00023c  2701              MOVS     r7,#1                 ;253
00023e  5d28              LDRB     r0,[r5,r4]            ;254
000240  283f              CMP      r0,#0x3f              ;254
000242  d10d              BNE      |L2.608|
000244  1928              ADDS     r0,r5,r4              ;256
000246  495b              LDR      r1,|L2.948|
000248  780a              LDRB     r2,[r1,#0]            ;256  ; C_DISCHARGE
00024a  a159              ADR      r1,|L2.944|
00024c  f7fffffe          BL       __2sprintf
000250  19e0              ADDS     r0,r4,r7              ;257
000252  b284              UXTH     r4,r0                 ;257
000254  220a              MOVS     r2,#0xa               ;258
000256  4620              MOV      r0,r4                 ;258
000258  1c61              ADDS     r1,r4,#1              ;258
00025a  b28c              UXTH     r4,r1                 ;258
00025c  542a              STRB     r2,[r5,r0]            ;258
00025e  e043              B        |L2.744|
                  |L2.608|
000260  f04f0a01          MOV      r10,#1                ;263
000264  2600              MOVS     r6,#0                 ;264
000266  e00c              B        |L2.642|
                  |L2.616|
000268  19a1              ADDS     r1,r4,r6              ;266
00026a  5c68              LDRB     r0,[r5,r1]            ;266
00026c  f7fffffe          BL       IsDigitChar
000270  2801              CMP      r0,#1                 ;266
000272  d102              BNE      |L2.634|
000274  f00a0a01          AND      r10,r10,#1            ;268
000278  e001              B        |L2.638|
                  |L2.634|
00027a  f04f0a00          MOV      r10,#0                ;272
                  |L2.638|
00027e  1c70              ADDS     r0,r6,#1              ;264
000280  b2c6              UXTB     r6,r0                 ;264
                  |L2.642|
000282  42be              CMP      r6,r7                 ;264
000284  dbf0              BLT      |L2.616|
000286  f1ba0f01          CMP      r10,#1                ;275
00028a  d103              BNE      |L2.660|
00028c  19e0              ADDS     r0,r4,r7              ;275
00028e  5c28              LDRB     r0,[r5,r0]            ;275
000290  280d              CMP      r0,#0xd               ;275
000292  d005              BEQ      |L2.672|
                  |L2.660|
000294  2202              MOVS     r2,#2                 ;277
000296  4628              MOV      r0,r5                 ;277
000298  9936              LDR      r1,[sp,#0xd8]         ;277
00029a  f7fffffe          BL       SetErr_ACK
00029e  e6d2              B        |L2.70|
                  |L2.672|
0002a0  2600              MOVS     r6,#0                 ;280
0002a2  46b0              MOV      r8,r6                 ;280
0002a4  e00a              B        |L2.700|
                  |L2.678|
0002a6  4620              MOV      r0,r4                 ;282
0002a8  1c61              ADDS     r1,r4,#1              ;282
0002aa  b28c              UXTH     r4,r1                 ;282
0002ac  5c28              LDRB     r0,[r5,r0]            ;282
0002ae  3830              SUBS     r0,r0,#0x30           ;282
0002b0  eb080188          ADD      r1,r8,r8,LSL #2       ;282
0002b4  eb000841          ADD      r8,r0,r1,LSL #1       ;282
0002b8  1c70              ADDS     r0,r6,#1              ;280
0002ba  b2c6              UXTB     r6,r0                 ;280
                  |L2.700|
0002bc  42be              CMP      r6,r7                 ;280
0002be  dbf2              BLT      |L2.678|
0002c0  f1b80f05          CMP      r8,#5                 ;284
0002c4  d905              BLS      |L2.722|
0002c6  2201              MOVS     r2,#1                 ;286
0002c8  4628              MOV      r0,r5                 ;286
0002ca  9936              LDR      r1,[sp,#0xd8]         ;286
0002cc  f7fffffe          BL       SetErr_ACK
0002d0  e6b9              B        |L2.70|
                  |L2.722|
0002d2  4836              LDR      r0,|L2.940|
0002d4  7800              LDRB     r0,[r0,#0]            ;289  ; FLAG_WIN
0002d6  bf00              NOP                            ;289
0002d8  4934              LDR      r1,|L2.940|
0002da  f8818000          STRB     r8,[r1,#0]            ;293
0002de  220a              MOVS     r2,#0xa               ;294
0002e0  4620              MOV      r0,r4                 ;294
0002e2  1c61              ADDS     r1,r4,#1              ;294
0002e4  b28c              UXTH     r4,r1                 ;294
0002e6  542a              STRB     r2,[r5,r0]            ;294
                  |L2.744|
0002e8  e03c              B        |L2.868|
                  |L2.746|
0002ea  2701              MOVS     r7,#1                 ;298
0002ec  5d28              LDRB     r0,[r5,r4]            ;299
0002ee  283f              CMP      r0,#0x3f              ;299
0002f0  d10d              BNE      |L2.782|
0002f2  1928              ADDS     r0,r5,r4              ;301
0002f4  492f              LDR      r1,|L2.948|
0002f6  780a              LDRB     r2,[r1,#0]            ;301  ; C_DISCHARGE
0002f8  a12d              ADR      r1,|L2.944|
0002fa  f7fffffe          BL       __2sprintf
0002fe  19e0              ADDS     r0,r4,r7              ;302
000300  b284              UXTH     r4,r0                 ;302
000302  220a              MOVS     r2,#0xa               ;303
000304  4620              MOV      r0,r4                 ;303
000306  1c61              ADDS     r1,r4,#1              ;303
000308  b28c              UXTH     r4,r1                 ;303
00030a  542a              STRB     r2,[r5,r0]            ;303
00030c  e023              B        |L2.854|
                  |L2.782|
00030e  2600              MOVS     r6,#0                 ;308
000310  46b0              MOV      r8,r6                 ;308
000312  e00a              B        |L2.810|
                  |L2.788|
000314  4620              MOV      r0,r4                 ;310
000316  1c61              ADDS     r1,r4,#1              ;310
000318  b28c              UXTH     r4,r1                 ;310
00031a  5c28              LDRB     r0,[r5,r0]            ;310
00031c  3830              SUBS     r0,r0,#0x30           ;310
00031e  eb080188          ADD      r1,r8,r8,LSL #2       ;310
000322  eb000841          ADD      r8,r0,r1,LSL #1       ;310
000326  1c70              ADDS     r0,r6,#1              ;308
000328  b2c6              UXTB     r6,r0                 ;308
                  |L2.810|
00032a  42be              CMP      r6,r7                 ;308
00032c  dbf2              BLT      |L2.788|
00032e  f1b80f05          CMP      r8,#5                 ;312
000332  d905              BLS      |L2.832|
000334  2201              MOVS     r2,#1                 ;314
000336  4628              MOV      r0,r5                 ;314
000338  9936              LDR      r1,[sp,#0xd8]         ;314
00033a  f7fffffe          BL       SetErr_ACK
00033e  e682              B        |L2.70|
                  |L2.832|
000340  481a              LDR      r0,|L2.940|
000342  7800              LDRB     r0,[r0,#0]            ;317  ; FLAG_WIN
000344  bf00              NOP                            ;317
000346  4919              LDR      r1,|L2.940|
000348  f8818000          STRB     r8,[r1,#0]            ;321
00034c  220a              MOVS     r2,#0xa               ;322
00034e  4620              MOV      r0,r4                 ;322
000350  1c61              ADDS     r1,r4,#1              ;322
000352  b28c              UXTH     r4,r1                 ;322
000354  542a              STRB     r2,[r5,r0]            ;322
                  |L2.854|
000356  e005              B        |L2.868|
                  |L2.856|
000358  2202              MOVS     r2,#2                 ;1049
00035a  4628              MOV      r0,r5                 ;1049
00035c  9936              LDR      r1,[sp,#0xd8]         ;1049
00035e  f7fffffe          BL       SetErr_ACK
000362  e670              B        |L2.70|
                  |L2.868|
000364  bf00              NOP                            ;210
000366  e007              B        |L2.888|
                  |L2.872|
000368  f1090001          ADD      r0,r9,#1              ;155
00036c  f00009ff          AND      r9,r0,#0xff           ;155
                  |L2.880|
000370  f1b90f12          CMP      r9,#0x12              ;155
000374  f6ffae93          BLT      |L2.158|
                  |L2.888|
000378  bf00              NOP                            ;1052
00037a  f1b90f12          CMP      r9,#0x12              ;1056
00037e  db05              BLT      |L2.908|
000380  2202              MOVS     r2,#2                 ;1058
000382  4628              MOV      r0,r5                 ;1058
000384  9936              LDR      r1,[sp,#0xd8]         ;1058
000386  f7fffffe          BL       SetErr_ACK
00038a  e65c              B        |L2.70|
                  |L2.908|
00038c  1c60              ADDS     r0,r4,#1              ;1060
00038e  b280              UXTH     r0,r0                 ;1060
000390  e659              B        |L2.70|
;;;1062   
                          ENDP

000392  0000              DCW      0x0000
                  |L2.916|
000394  256400            DCB      "%d",0
000397  00                DCB      0
                  |L2.920|
000398  2f00              DCB      "/",0
00039a  00                DCB      0
00039b  00                DCB      0
                  |L2.924|
                          DCD      CmdStr
                  |L2.928|
                          DCD      CLists
                  |L2.932|
0003a4  25303564          DCB      "%05d",0
0003a8  00      
0003a9  00                DCB      0
0003aa  00                DCB      0
0003ab  00                DCB      0
                  |L2.940|
                          DCD      FLAG_WIN
                  |L2.944|
0003b0  25316400          DCB      "%1d",0
                  |L2.948|
                          DCD      C_DISCHARGE

                          AREA ||i.SetErr_ACK||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  SetErr_ACK PROC
;;;76     
;;;77     u16 SetErr_ACK(char *buf, u8 addr ,u8 ucErr)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;78     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;79     		u16 i=0;
00000a  2400              MOVS     r4,#0
;;;80     		u8 len = 0;
00000c  46a0              MOV      r8,r4
;;;81     		char stradd[3] = {0};
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
;;;82     		int addlen=0;
000012  4681              MOV      r9,r0
;;;83     		memset(buf,0,sizeof(buf));
000014  6028              STR      r0,[r5,#0]
;;;84         	buf[i++] = ChrStartS;
000016  223e              MOVS     r2,#0x3e
000018  4621              MOV      r1,r4
00001a  1c64              ADDS     r4,r4,#1
00001c  546a              STRB     r2,[r5,r1]
;;;85     		sprintf(stradd,"%d",addr);
00001e  4632              MOV      r2,r6
000020  a126              ADR      r1,|L3.188|
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       __2sprintf
;;;86     		addlen=strlen(stradd);
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       strlen
00002e  4681              MOV      r9,r0
;;;87     		strncat(&buf[i],stradd,addlen);
000030  1928              ADDS     r0,r5,r4
000032  464a              MOV      r2,r9
000034  4669              MOV      r1,sp
000036  f7fffffe          BL       strncat
;;;88     		i+=addlen;
00003a  eb040009          ADD      r0,r4,r9
00003e  b284              UXTH     r4,r0
;;;89     		buf[i++] = '/';
000040  222f              MOVS     r2,#0x2f
000042  4620              MOV      r0,r4
000044  1c61              ADDS     r1,r4,#1
000046  b28c              UXTH     r4,r1
000048  542a              STRB     r2,[r5,r0]
;;;90     		switch(ucErr)
00004a  2f01              CMP      r7,#1
00004c  d004              BEQ      |L3.88|
00004e  2f02              CMP      r7,#2
000050  d00a              BEQ      |L3.104|
000052  2f03              CMP      r7,#3
000054  d118              BNE      |L3.136|
000056  e00f              B        |L3.120|
                  |L3.88|
;;;91             {
;;;92               case 1:         //
;;;93               	   len = 9;
000058  f04f0809          MOV      r8,#9
;;;94               	   memmove(&buf[i],"PARA ERR!",len);   
00005c  1928              ADDS     r0,r5,r4
00005e  4642              MOV      r2,r8
000060  a117              ADR      r1,|L3.192|
000062  f7fffffe          BL       __aeabi_memmove
;;;95               	   break;
000066  e017              B        |L3.152|
                  |L3.104|
;;;96     	      case 2:         //
;;;97               	   len = 8;
000068  f04f0808          MOV      r8,#8
;;;98               	   memmove(&buf[i],"CMD ERR!",len);   
00006c  1928              ADDS     r0,r5,r4
00006e  4642              MOV      r2,r8
000070  a116              ADR      r1,|L3.204|
000072  f7fffffe          BL       __aeabi_memmove
;;;99               	   break;
000076  e00f              B        |L3.152|
                  |L3.120|
;;;100    	      case 3:         //
;;;101              	   len = 8;
000078  f04f0808          MOV      r8,#8
;;;102              	   memmove(&buf[i],"REM ERR!",len);   
00007c  1928              ADDS     r0,r5,r4
00007e  4642              MOV      r2,r8
000080  a115              ADR      r1,|L3.216|
000082  f7fffffe          BL       __aeabi_memmove
;;;103              	   break;
000086  e007              B        |L3.152|
                  |L3.136|
;;;104    		  default:    
;;;105                   len = 8;
000088  f04f0808          MOV      r8,#8
;;;106              	   memmove(&buf[i],"CMD ERR!",len);   
00008c  1928              ADDS     r0,r5,r4
00008e  4642              MOV      r2,r8
000090  a10e              ADR      r1,|L3.204|
000092  f7fffffe          BL       __aeabi_memmove
;;;107                   break;
000096  bf00              NOP      
                  |L3.152|
000098  bf00              NOP                            ;95
;;;108    	    }
;;;109    	    i+=len;
00009a  eb040008          ADD      r0,r4,r8
00009e  b284              UXTH     r4,r0
;;;110    		buf[i++] = ChrEndR;
0000a0  220d              MOVS     r2,#0xd
0000a2  4620              MOV      r0,r4
0000a4  1c61              ADDS     r1,r4,#1
0000a6  b28c              UXTH     r4,r1
0000a8  542a              STRB     r2,[r5,r0]
;;;111    		buf[i++] = ChrEndS;
0000aa  220a              MOVS     r2,#0xa
0000ac  4621              MOV      r1,r4
0000ae  1c60              ADDS     r0,r4,#1
0000b0  b284              UXTH     r4,r0
0000b2  546a              STRB     r2,[r5,r1]
;;;112    		return i;
0000b4  4620              MOV      r0,r4
;;;113    }
0000b6  e8bd83f8          POP      {r3-r9,pc}
;;;114    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L3.188|
0000bc  256400            DCB      "%d",0
0000bf  00                DCB      0
                  |L3.192|
0000c0  50415241          DCB      "PARA ERR!",0
0000c4  20455252
0000c8  2100    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L3.204|
0000cc  434d4420          DCB      "CMD ERR!",0
0000d0  45525221
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L3.216|
0000d8  52454d20          DCB      "REM ERR!",0
0000dc  45525221
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||i.UART1_Send||, CODE, READONLY, ALIGN=2

                  UART1_Send PROC
;;;1231   
;;;1232   void UART1_Send(void)
000000  b510              PUSH     {r4,lr}
;;;1233   {
;;;1234   	static vu8 UART_Buffer_Send_pointer=0;
;;;1235   		if (UART_Buffer_Send_pointer < Transmit_BUFFERsize)
000002  4815              LDR      r0,|L4.88|
000004  7800              LDRB     r0,[r0,#0]  ; UART_Buffer_Send_pointer
000006  4915              LDR      r1,|L4.92|
000008  7809              LDRB     r1,[r1,#0]  ; Transmit_BUFFERsize
00000a  4288              CMP      r0,r1
00000c  da19              BGE      |L4.66|
;;;1236            {
;;;1237   					 if(UART_Buffer_Send[0]==ADDR)
00000e  4814              LDR      r0,|L4.96|
000010  7800              LDRB     r0,[r0,#0]  ; UART_Buffer_Send
000012  4914              LDR      r1,|L4.100|
000014  7809              LDRB     r1,[r1,#0]  ; ADDR
000016  4288              CMP      r0,r1
000018  d11c              BNE      |L4.84|
;;;1238   					 {
;;;1239   						USART_SendData(USART1,UART_Buffer_Send[UART_Buffer_Send_pointer]);
00001a  4811              LDR      r0,|L4.96|
00001c  4a0e              LDR      r2,|L4.88|
00001e  7812              LDRB     r2,[r2,#0]  ; UART_Buffer_Send_pointer
000020  5c81              LDRB     r1,[r0,r2]
000022  4811              LDR      r0,|L4.104|
000024  f7fffffe          BL       USART_SendData
;;;1240   						while (USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);//等待发送完成
000028  bf00              NOP      
                  |L4.42|
00002a  2180              MOVS     r1,#0x80
00002c  480e              LDR      r0,|L4.104|
00002e  f7fffffe          BL       USART_GetFlagStatus
000032  2800              CMP      r0,#0
000034  d0f9              BEQ      |L4.42|
;;;1241   						UART_Buffer_Send_pointer++;
000036  4808              LDR      r0,|L4.88|
000038  7800              LDRB     r0,[r0,#0]  ; UART_Buffer_Send_pointer
00003a  1c40              ADDS     r0,r0,#1
00003c  4906              LDR      r1,|L4.88|
00003e  7008              STRB     r0,[r1,#0]
000040  e008              B        |L4.84|
                  |L4.66|
;;;1242   					}
;;;1243            }
;;;1244   		else 
;;;1245   		{
;;;1246   			UART_Buffer_Send_pointer=0;
000042  2000              MOVS     r0,#0
000044  4904              LDR      r1,|L4.88|
000046  7008              STRB     r0,[r1,#0]
;;;1247   			UART_SEND_flag=0;//发送完成一帧数据
000048  4808              LDR      r0,|L4.108|
00004a  6800              LDR      r0,[r0,#0]  ; flagA
00004c  f0200010          BIC      r0,r0,#0x10
000050  4906              LDR      r1,|L4.108|
000052  6008              STR      r0,[r1,#0]  ; flagA
                  |L4.84|
;;;1248   		}
;;;1249   }
000054  bd10              POP      {r4,pc}
;;;1250   
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      |symbol_number.33|
                  |L4.92|
                          DCD      Transmit_BUFFERsize
                  |L4.96|
                          DCD      UART_Buffer_Send
                  |L4.100|
                          DCD      ADDR
                  |L4.104|
                          DCD      0x40011000
                  |L4.108|
                          DCD      flagA

                          AREA ||i.UART2_Send||, CODE, READONLY, ALIGN=2

                  UART2_Send PROC
;;;1212   }
;;;1213   void UART2_Send(void)
000000  b510              PUSH     {r4,lr}
;;;1214   {
;;;1215   	static vu8 UART_Buffer_Send_pointer=0;
;;;1216   		if (UART_Buffer_Send_pointer < Transmit_BUFFERsize)
000002  4815              LDR      r0,|L5.88|
000004  7800              LDRB     r0,[r0,#0]  ; UART_Buffer_Send_pointer
000006  4915              LDR      r1,|L5.92|
000008  7809              LDRB     r1,[r1,#0]  ; Transmit_BUFFERsize
00000a  4288              CMP      r0,r1
00000c  da19              BGE      |L5.66|
;;;1217            {
;;;1218   					 if(UART_Buffer_Send[0]==ADDR)
00000e  4814              LDR      r0,|L5.96|
000010  7800              LDRB     r0,[r0,#0]  ; UART_Buffer_Send
000012  4914              LDR      r1,|L5.100|
000014  7809              LDRB     r1,[r1,#0]  ; ADDR
000016  4288              CMP      r0,r1
000018  d11c              BNE      |L5.84|
;;;1219   					 {
;;;1220   						USART_SendData(USART2,UART_Buffer_Send[UART_Buffer_Send_pointer]);
00001a  4811              LDR      r0,|L5.96|
00001c  4a0e              LDR      r2,|L5.88|
00001e  7812              LDRB     r2,[r2,#0]  ; UART_Buffer_Send_pointer
000020  5c81              LDRB     r1,[r0,r2]
000022  4811              LDR      r0,|L5.104|
000024  f7fffffe          BL       USART_SendData
;;;1221   						while (USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);//等待发送完成
000028  bf00              NOP      
                  |L5.42|
00002a  2180              MOVS     r1,#0x80
00002c  480f              LDR      r0,|L5.108|
00002e  f7fffffe          BL       USART_GetFlagStatus
000032  2800              CMP      r0,#0
000034  d0f9              BEQ      |L5.42|
;;;1222   						UART_Buffer_Send_pointer++;
000036  4808              LDR      r0,|L5.88|
000038  7800              LDRB     r0,[r0,#0]  ; UART_Buffer_Send_pointer
00003a  1c40              ADDS     r0,r0,#1
00003c  4906              LDR      r1,|L5.88|
00003e  7008              STRB     r0,[r1,#0]
000040  e008              B        |L5.84|
                  |L5.66|
;;;1223   					}
;;;1224            }
;;;1225   		else 
;;;1226   		{
;;;1227   			UART_Buffer_Send_pointer=0;
000042  2000              MOVS     r0,#0
000044  4904              LDR      r1,|L5.88|
000046  7008              STRB     r0,[r1,#0]
;;;1228   			UART_SEND_flag=0;//发送完成一帧数据
000048  4809              LDR      r0,|L5.112|
00004a  6800              LDR      r0,[r0,#0]  ; flagA
00004c  f0200010          BIC      r0,r0,#0x10
000050  4907              LDR      r1,|L5.112|
000052  6008              STR      r0,[r1,#0]  ; flagA
                  |L5.84|
;;;1229   		}
;;;1230   }
000054  bd10              POP      {r4,pc}
;;;1231   
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      UART_Buffer_Send_pointer
                  |L5.92|
                          DCD      Transmit_BUFFERsize
                  |L5.96|
                          DCD      UART_Buffer_Send
                  |L5.100|
                          DCD      ADDR
                  |L5.104|
                          DCD      0x40004400
                  |L5.108|
                          DCD      0x40011000
                  |L5.112|
                          DCD      flagA

                          AREA ||i.USART1_NVIC_Config||, CODE, READONLY, ALIGN=1

                  USART1_NVIC_Config PROC
;;;1064   
;;;1065   static void USART1_NVIC_Config(void)//串口接收中断配置
000000  b508              PUSH     {r3,lr}
;;;1066   {
;;;1067   	NVIC_InitTypeDef NVIC_InitStructure; 
;;;1068   	/* Configure the NVIC Preemption Priority Bits */  
;;;1069   	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
000002  f44f60e0          MOV      r0,#0x700
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;1070   	
;;;1071   	/* Enable the USARTy Interrupt */
;;;1072   	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;	 
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
;;;1073   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2000              MOVS     r0,#0
000012  f88d0001          STRB     r0,[sp,#1]
;;;1074   	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000016  2001              MOVS     r0,#1
000018  f88d0002          STRB     r0,[sp,#2]
;;;1075   	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  f88d0003          STRB     r0,[sp,#3]
;;;1076   	NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;1077   }
000026  bd08              POP      {r3,pc}
;;;1078   
                          ENDP


                          AREA ||i.USART2_Configuration||, CODE, READONLY, ALIGN=2

                  USART2_Configuration PROC
;;;1131   
;;;1132   void USART2_Configuration(void)//串口初始化函数
000000  b500              PUSH     {lr}
;;;1133   {  
000002  b087              SUB      sp,sp,#0x1c
;;;1134   	GPIO_InitTypeDef GPIO_InitStructure;
;;;1135   	USART_InitTypeDef USART_InitStructure;
;;;1136   	
;;;1137   	/* config USART1 clock */
;;;1138   	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
000004  2101              MOVS     r1,#1
000006  0448              LSLS     r0,r1,#17
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1139   	GPIO_PinAFConfig(GPIOA,GPIO_PinSource2,GPIO_AF_USART2);
00000c  2207              MOVS     r2,#7
00000e  2102              MOVS     r1,#2
000010  4822              LDR      r0,|L7.156|
000012  f7fffffe          BL       GPIO_PinAFConfig
;;;1140   	GPIO_PinAFConfig(GPIOA,GPIO_PinSource3,GPIO_AF_USART2);
000016  2207              MOVS     r2,#7
000018  2103              MOVS     r1,#3
00001a  4820              LDR      r0,|L7.156|
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;1141   	/* USART1 GPIO config */
;;;1142   	/* Configure USART1 Tx (PA.02) as alternate function push-pull */
;;;1143   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000020  2004              MOVS     r0,#4
000022  9005              STR      r0,[sp,#0x14]
;;;1144   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000024  2002              MOVS     r0,#2
000026  f88d0018          STRB     r0,[sp,#0x18]
;;;1145   	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00002a  2000              MOVS     r0,#0
00002c  f88d001a          STRB     r0,[sp,#0x1a]
;;;1146   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000030  2002              MOVS     r0,#2
000032  f88d0019          STRB     r0,[sp,#0x19]
;;;1147   	GPIO_Init(GPIOA, &GPIO_InitStructure);    
000036  a905              ADD      r1,sp,#0x14
000038  4818              LDR      r0,|L7.156|
00003a  f7fffffe          BL       GPIO_Init
;;;1148   	/* Configure USART1 Rx (PA.03) as input floating */
;;;1149   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
00003e  2008              MOVS     r0,#8
000040  9005              STR      r0,[sp,#0x14]
;;;1150   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000042  2002              MOVS     r0,#2
000044  f88d0018          STRB     r0,[sp,#0x18]
;;;1151   	GPIO_Init(GPIOA, &GPIO_InitStructure);
000048  a905              ADD      r1,sp,#0x14
00004a  4814              LDR      r0,|L7.156|
00004c  f7fffffe          BL       GPIO_Init
;;;1152   	
;;;1153   	/* USART1 mode config */
;;;1154   	USART_InitStructure.USART_BaudRate = 115200;
000050  f44f30e1          MOV      r0,#0x1c200
000054  9001              STR      r0,[sp,#4]
;;;1155   	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000056  2000              MOVS     r0,#0
000058  f8ad0008          STRH     r0,[sp,#8]
;;;1156   	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00005c  f8ad000a          STRH     r0,[sp,#0xa]
;;;1157   	USART_InitStructure.USART_Parity = USART_Parity_No ;
000060  f8ad000c          STRH     r0,[sp,#0xc]
;;;1158   	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000064  f8ad0010          STRH     r0,[sp,#0x10]
;;;1159   	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000068  200c              MOVS     r0,#0xc
00006a  f8ad000e          STRH     r0,[sp,#0xe]
;;;1160   	USART_Init(USART2, &USART_InitStructure);
00006e  a901              ADD      r1,sp,#4
000070  480b              LDR      r0,|L7.160|
000072  f7fffffe          BL       USART_Init
;;;1161   	
;;;1162   	/******使能串口接收中断******************/
;;;1163   	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000076  2201              MOVS     r2,#1
000078  f2405125          MOV      r1,#0x525
00007c  4808              LDR      r0,|L7.160|
00007e  f7fffffe          BL       USART_ITConfig
;;;1164   //	USART_ITConfig(USART2, USART_IT_ORE, ENABLE);	
;;;1165   	USART_Cmd(USART2, ENABLE);//使能串口1
000082  2101              MOVS     r1,#1
000084  4806              LDR      r0,|L7.160|
000086  f7fffffe          BL       USART_Cmd
;;;1166     USART_ClearFlag(USART2, USART_FLAG_TC);
00008a  2140              MOVS     r1,#0x40
00008c  4804              LDR      r0,|L7.160|
00008e  f7fffffe          BL       USART_ClearFlag
;;;1167     
;;;1168     USART2_NVIC_Config();//串口中断配置
000092  f7fffffe          BL       USART2_NVIC_Config
;;;1169   }
000096  b007              ADD      sp,sp,#0x1c
000098  bd00              POP      {pc}
;;;1170   
                          ENDP

00009a  0000              DCW      0x0000
                  |L7.156|
                          DCD      0x40020000
                  |L7.160|
                          DCD      0x40004400

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;1170   
;;;1171   void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1172   {
;;;1173   	u8 Res;
;;;1174    	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  482d              LDR      r0,|L8.188|
000008  f7fffffe          BL       USART_GetITStatus
00000c  2800              CMP      r0,#0
00000e  d053              BEQ      |L8.184|
;;;1175   	{
;;;1176   		USART_ClearITPendingBit(USART2,USART_IT_RXNE);
000010  f2405125          MOV      r1,#0x525
000014  4829              LDR      r0,|L8.188|
000016  f7fffffe          BL       USART_ClearITPendingBit
;;;1177   		Res=USART_ReceiveData(USART2);
00001a  4828              LDR      r0,|L8.188|
00001c  f7fffffe          BL       USART_ReceiveData
000020  b2c4              UXTB     r4,r0
;;;1178   
;;;1179   		if((USART_RX_STA&0x8000)==0)//接收未完成
000022  4827              LDR      r0,|L8.192|
000024  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000026  f4004000          AND      r0,r0,#0x8000
00002a  2800              CMP      r0,#0
00002c  d144              BNE      |L8.184|
;;;1180   		{
;;;1181   		if(USART_RX_STA&0x4000)//接收到了0x0d
00002e  4824              LDR      r0,|L8.192|
000030  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000032  f4004080          AND      r0,r0,#0x4000
000036  b1d8              CBZ      r0,|L8.112|
;;;1182   			{
;;;1183   			if(Res!=0x0a)
000038  2c0a              CMP      r4,#0xa
00003a  d003              BEQ      |L8.68|
;;;1184   				USART_RX_STA=0;//接收错误,重新开始
00003c  2000              MOVS     r0,#0
00003e  4920              LDR      r1,|L8.192|
000040  8008              STRH     r0,[r1,#0]
000042  e039              B        |L8.184|
                  |L8.68|
;;;1185   			else 
;;;1186   			{
;;;1187   		//		SerialRemoteHandleL(USART_RX_STA,USART_RX_BUF);
;;;1188   				USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;			//将接收的数据 存入数组中
000044  481e              LDR      r0,|L8.192|
000046  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000048  f3c0000d          UBFX     r0,r0,#0,#14
00004c  491d              LDR      r1,|L8.196|
00004e  540c              STRB     r4,[r1,r0]
;;;1189   				USART_RX_STA++;
000050  481b              LDR      r0,|L8.192|
000052  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000054  1c40              ADDS     r0,r0,#1
000056  491a              LDR      r1,|L8.192|
000058  8008              STRH     r0,[r1,#0]
;;;1190   				USART_RX_CNT = USART_RX_STA;
00005a  4608              MOV      r0,r1
00005c  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00005e  491a              LDR      r1,|L8.200|
000060  8008              STRH     r0,[r1,#0]
;;;1191   				USART_RX_STA|=0x8000;	//接收完成了 			  //接收到回车的后字节  置位状态寄存器 
000062  4817              LDR      r0,|L8.192|
000064  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000066  f4404000          ORR      r0,r0,#0x8000
00006a  4915              LDR      r1,|L8.192|
00006c  8008              STRH     r0,[r1,#0]
00006e  e023              B        |L8.184|
                  |L8.112|
;;;1192   			}
;;;1193   			}
;;;1194   		else //还没收到0X0D
;;;1195   			{	
;;;1196   			if(Res==0x0d)
000070  2c0d              CMP      r4,#0xd
000072  d110              BNE      |L8.150|
;;;1197   			{
;;;1198   				USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;			//将接收的数据 存入数组中
000074  4812              LDR      r0,|L8.192|
000076  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000078  f3c0000d          UBFX     r0,r0,#0,#14
00007c  4911              LDR      r1,|L8.196|
00007e  540c              STRB     r4,[r1,r0]
;;;1199   				USART_RX_STA++;	
000080  480f              LDR      r0,|L8.192|
000082  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000084  1c40              ADDS     r0,r0,#1
000086  490e              LDR      r1,|L8.192|
000088  8008              STRH     r0,[r1,#0]
;;;1200   				USART_RX_STA|=0x4000;					 //接收到回车的前一字节  置位状态寄存器
00008a  4608              MOV      r0,r1
00008c  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00008e  f4404080          ORR      r0,r0,#0x4000
000092  8008              STRH     r0,[r1,#0]
000094  e010              B        |L8.184|
                  |L8.150|
;;;1201   			}
;;;1202   			else
;;;1203   				{
;;;1204   				USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;			//将接收的数据 存入数组中
000096  480a              LDR      r0,|L8.192|
000098  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00009a  f3c0000d          UBFX     r0,r0,#0,#14
00009e  4909              LDR      r1,|L8.196|
0000a0  540c              STRB     r4,[r1,r0]
;;;1205   					USART_RX_STA++;									//长度+1 为下一次做准备
0000a2  4807              LDR      r0,|L8.192|
0000a4  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
0000a6  1c40              ADDS     r0,r0,#1
0000a8  4905              LDR      r1,|L8.192|
0000aa  8008              STRH     r0,[r1,#0]
;;;1206   				if(USART_RX_STA>(USART_REC_LEN-1))
0000ac  4608              MOV      r0,r1
0000ae  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
0000b0  28c7              CMP      r0,#0xc7
0000b2  dd01              BLE      |L8.184|
;;;1207   					USART_RX_STA=0;//接收数据错误,重新开始接收	  
0000b4  2000              MOVS     r0,#0
0000b6  8008              STRH     r0,[r1,#0]
                  |L8.184|
;;;1208   				}		 
;;;1209   			}
;;;1210   		} 
;;;1211   	}
;;;1212   }
0000b8  bd10              POP      {r4,pc}
;;;1213   void UART2_Send(void)
                          ENDP

0000ba  0000              DCW      0x0000
                  |L8.188|
                          DCD      0x40004400
                  |L8.192|
                          DCD      USART_RX_STA
                  |L8.196|
                          DCD      USART_RX_BUF
                  |L8.200|
                          DCD      USART_RX_CNT

                          AREA ||i.USART2_NVIC_Config||, CODE, READONLY, ALIGN=1

                  USART2_NVIC_Config PROC
;;;1117   
;;;1118   static void USART2_NVIC_Config(void)//串口接收中断配置
000000  b508              PUSH     {r3,lr}
;;;1119   {
;;;1120   	NVIC_InitTypeDef NVIC_InitStructure; 
;;;1121   	/* Configure the NVIC Preemption Priority Bits */  
;;;1122   	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
000002  f44f60e0          MOV      r0,#0x700
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;1123   	
;;;1124   	/* Enable the USARTy Interrupt */
;;;1125   	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;	 
00000a  2026              MOVS     r0,#0x26
00000c  f88d0000          STRB     r0,[sp,#0]
;;;1126   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2000              MOVS     r0,#0
000012  f88d0001          STRB     r0,[sp,#1]
;;;1127   	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000016  2001              MOVS     r0,#1
000018  f88d0002          STRB     r0,[sp,#2]
;;;1128   	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  f88d0003          STRB     r0,[sp,#3]
;;;1129   	NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;1130   }
000026  bd08              POP      {r3,pc}
;;;1131   
                          ENDP


                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;1078   
;;;1079   void USART_Configuration(void)//串口初始化函数
000000  b500              PUSH     {lr}
;;;1080   {  
000002  b087              SUB      sp,sp,#0x1c
;;;1081   	GPIO_InitTypeDef GPIO_InitStructure;
;;;1082   	USART_InitTypeDef USART_InitStructure;
;;;1083   	
;;;1084   	/* config USART1 clock */
;;;1085   	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
000004  2101              MOVS     r1,#1
000006  2010              MOVS     r0,#0x10
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1086   	GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1);
00000c  2207              MOVS     r2,#7
00000e  2109              MOVS     r1,#9
000010  4823              LDR      r0,|L10.160|
000012  f7fffffe          BL       GPIO_PinAFConfig
;;;1087   	GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1);
000016  2207              MOVS     r2,#7
000018  210a              MOVS     r1,#0xa
00001a  4821              LDR      r0,|L10.160|
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;1088   	/* USART1 GPIO config */
;;;1089   	/* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;1090   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000020  f44f7000          MOV      r0,#0x200
000024  9005              STR      r0,[sp,#0x14]
;;;1091   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000026  2002              MOVS     r0,#2
000028  f88d0018          STRB     r0,[sp,#0x18]
;;;1092   	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00002c  2000              MOVS     r0,#0
00002e  f88d001a          STRB     r0,[sp,#0x1a]
;;;1093   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000032  2002              MOVS     r0,#2
000034  f88d0019          STRB     r0,[sp,#0x19]
;;;1094   	GPIO_Init(GPIOA, &GPIO_InitStructure);    
000038  a905              ADD      r1,sp,#0x14
00003a  4819              LDR      r0,|L10.160|
00003c  f7fffffe          BL       GPIO_Init
;;;1095   	/* Configure USART1 Rx (PA.10) as input floating */
;;;1096   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000040  f44f6080          MOV      r0,#0x400
000044  9005              STR      r0,[sp,#0x14]
;;;1097   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000046  2002              MOVS     r0,#2
000048  f88d0018          STRB     r0,[sp,#0x18]
;;;1098   	GPIO_Init(GPIOA, &GPIO_InitStructure);
00004c  a905              ADD      r1,sp,#0x14
00004e  4814              LDR      r0,|L10.160|
000050  f7fffffe          BL       GPIO_Init
;;;1099   	
;;;1100   	/* USART1 mode config */
;;;1101   	USART_InitStructure.USART_BaudRate = 19200;
000054  f44f4096          MOV      r0,#0x4b00
000058  9001              STR      r0,[sp,#4]
;;;1102   	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00005a  2000              MOVS     r0,#0
00005c  f8ad0008          STRH     r0,[sp,#8]
;;;1103   	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;1104   	USART_InitStructure.USART_Parity = USART_Parity_No ;
000064  f8ad000c          STRH     r0,[sp,#0xc]
;;;1105   	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000068  f8ad0010          STRH     r0,[sp,#0x10]
;;;1106   	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00006c  200c              MOVS     r0,#0xc
00006e  f8ad000e          STRH     r0,[sp,#0xe]
;;;1107   	USART_Init(USART1, &USART_InitStructure);
000072  a901              ADD      r1,sp,#4
000074  480b              LDR      r0,|L10.164|
000076  f7fffffe          BL       USART_Init
;;;1108   	
;;;1109   	/******使能串口接收中断******************/
;;;1110   	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	
00007a  2201              MOVS     r2,#1
00007c  f2405125          MOV      r1,#0x525
000080  4808              LDR      r0,|L10.164|
000082  f7fffffe          BL       USART_ITConfig
;;;1111   	USART_Cmd(USART1, ENABLE);//使能串口1
000086  2101              MOVS     r1,#1
000088  4806              LDR      r0,|L10.164|
00008a  f7fffffe          BL       USART_Cmd
;;;1112     USART_ClearFlag(USART1, USART_FLAG_TC);
00008e  2140              MOVS     r1,#0x40
000090  4804              LDR      r0,|L10.164|
000092  f7fffffe          BL       USART_ClearFlag
;;;1113     
;;;1114     USART1_NVIC_Config();//串口中断配置
000096  f7fffffe          BL       USART1_NVIC_Config
;;;1115   }			
00009a  b007              ADD      sp,sp,#0x1c
00009c  bd00              POP      {pc}
;;;1116   
                          ENDP

00009e  0000              DCW      0x0000
                  |L10.160|
                          DCD      0x40020000
                  |L10.164|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UART_Buffer_Rece
                          %        16
                  UART_Buffer_Send
                          %        20
                  USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  UART_Buffer_Size
000000  00                DCB      0x00
                  Transmit_BUFFERsize
000001  00                DCB      0x00
                  t_USART
000002  0000              DCB      0x00,0x00
                  USART_RX_STA
000004  0000              DCW      0x0000
                  USART_RX_CNT
000006  0000              DCW      0x0000
                  CmdStr
000008  53544154          DCB      0x53,0x54,0x41,0x54
00000c  55535f00          DCB      0x55,0x53,0x5f,0x00
000010  004d4f44          DCB      0x00,0x4d,0x4f,0x44
000014  5f000000          DCB      0x5f,0x00,0x00,0x00
000018  00005452          DCB      0x00,0x00,0x54,0x52
00001c  49475f00          DCB      0x49,0x47,0x5f,0x00
000020  00000053          DCB      0x00,0x00,0x00,0x53
000024  45545041          DCB      0x45,0x54,0x50,0x41
000028  52415f00          DCB      0x52,0x41,0x5f,0x00
00002c  4c4f4144          DCB      0x4c,0x4f,0x41,0x44
000030  495f0000          DCB      0x49,0x5f,0x00,0x00
000034  00504f57          DCB      0x00,0x50,0x4f,0x57
000038  565f0000          DCB      0x56,0x5f,0x00,0x00
00003c  0000504f          DCB      0x00,0x00,0x50,0x4f
000040  57495f00          DCB      0x57,0x49,0x5f,0x00
000044  00000041          DCB      0x00,0x00,0x00,0x41
000048  4443565f          DCB      0x44,0x43,0x56,0x5f
00004c  00000000          DCB      0x00,0x00,0x00,0x00
000050  4c4f5749          DCB      0x4c,0x4f,0x57,0x49
000054  5f000000          DCB      0x5f,0x00,0x00,0x00
000058  00484f52          DCB      0x00,0x48,0x4f,0x52
00005c  4c5f0000          DCB      0x4c,0x5f,0x00,0x00
000060  00004c56          DCB      0x00,0x00,0x4c,0x56
000064  4c5f0000          DCB      0x4c,0x5f,0x00,0x00
000068  00000053          DCB      0x00,0x00,0x00,0x53
00006c  57495443          DCB      0x57,0x49,0x54,0x43
000070  485f0000          DCB      0x48,0x5f,0x00,0x00
000074  43414c56          DCB      0x43,0x41,0x4c,0x56
000078  5f000000          DCB      0x5f,0x00,0x00,0x00
00007c  0043414c          DCB      0x00,0x43,0x41,0x4c
000080  495f0000          DCB      0x49,0x5f,0x00,0x00
000084  00004354          DCB      0x00,0x00,0x43,0x54
000088  524c565f          DCB      0x52,0x4c,0x56,0x5f
00008c  00000043          DCB      0x00,0x00,0x00,0x43
000090  4c454152          DCB      0x4c,0x45,0x41,0x52
000094  495f0000          DCB      0x49,0x5f,0x00,0x00
000098  4f564552          DCB      0x4f,0x56,0x45,0x52
00009c  5f000000          DCB      0x5f,0x00,0x00,0x00
0000a0  0054454d          DCB      0x00,0x54,0x45,0x4d
0000a4  505f0000          DCB      0x50,0x5f,0x00,0x00
0000a8  0000              DCB      0x00,0x00
                  UART_Buffer_Send_pointer
0000aa  00                DCB      0x00
                  |symbol_number.33|
0000ab  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_7cc17ae7____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_usart_c_7cc17ae7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_7cc17ae7____REVSH|
#line 144
|__asm___7_usart_c_7cc17ae7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
