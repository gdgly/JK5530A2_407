; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\ssd1963.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\ssd1963.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX -W --omf_browse=..\output\ssd1963.crf --no_multibyte_chars ..\drive\ssd1963.c]
                          THUMB

                          AREA ||i.Delay_ms||, CODE, READONLY, ALIGN=1

                  Delay_ms PROC
;;;92     }
;;;93     void  Delay_ms(vu16 mstime)
000000  b501              PUSH     {r0,lr}
;;;94     {                                                           
;;;95       while (mstime--)
000002  e003              B        |L1.12|
                  |L1.4|
;;;96       {
;;;97         Delay_usS(1000);
000004  f44f707a          MOV      r0,#0x3e8
000008  f7fffffe          BL       Delay_usS
                  |L1.12|
00000c  f8bd0000          LDRH     r0,[sp,#0]            ;95
000010  1e41              SUBS     r1,r0,#1              ;95
000012  b289              UXTH     r1,r1                 ;95
000014  9100              STR      r1,[sp,#0]            ;95
000016  2800              CMP      r0,#0                 ;95
000018  d1f4              BNE      |L1.4|
;;;98       }
;;;99     }
00001a  bd08              POP      {r3,pc}
;;;100    void sLCD_GPIO_Config(void)
                          ENDP


                          AREA ||i.Delay_usS||, CODE, READONLY, ALIGN=1

                  Delay_usS PROC
;;;75     
;;;76     void Delay_usS(vu16 ustime)
000000  b501              PUSH     {r0,lr}
;;;77     {
000002  b082              SUB      sp,sp,#8
;;;78       vu16 ii,jj;
;;;79     
;;;80       for (ii=0; ii<ustime; ++ii)
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
000008  e013              B        |L2.50|
                  |L2.10|
;;;81       {
;;;82         jj=4;
00000a  2004              MOVS     r0,#4
00000c  9000              STR      r0,[sp,#0]
;;;83         do
00000e  bf00              NOP      
                  |L2.16|
;;;84         {
;;;85           NOP;
000010  bf00              NOP      
;;;86     			NOP;
000012  bf00              NOP      
;;;87     			NOP;
000014  bf00              NOP      
;;;88     			NOP;
000016  bf00              NOP      
;;;89     			NOP;
000018  bf00              NOP      
;;;90         }while (--jj);
00001a  f8bd0000          LDRH     r0,[sp,#0]
00001e  1e40              SUBS     r0,r0,#1
000020  b280              UXTH     r0,r0
000022  9000              STR      r0,[sp,#0]
000024  2800              CMP      r0,#0
000026  d1f3              BNE      |L2.16|
000028  f8bd0004          LDRH     r0,[sp,#4]            ;80
00002c  1c40              ADDS     r0,r0,#1              ;80
00002e  b280              UXTH     r0,r0                 ;80
000030  9001              STR      r0,[sp,#4]            ;80
                  |L2.50|
000032  f8bd0004          LDRH     r0,[sp,#4]            ;80
000036  f8bd1008          LDRH     r1,[sp,#8]            ;80
00003a  4288              CMP      r0,r1                 ;80
00003c  dbe5              BLT      |L2.10|
;;;91       }
;;;92     }
00003e  bd0e              POP      {r1-r3,pc}
;;;93     void  Delay_ms(vu16 mstime)
                          ENDP


                          AREA ||i.LCD_GetPoint||, CODE, READONLY, ALIGN=1

                  LCD_GetPoint PROC
;;;364    
;;;365    vu16 LCD_GetPoint(vu16 x, vu16 y)
000000  b503              PUSH     {r0,r1,lr}
;;;366    {
000002  b081              SUB      sp,sp,#4
;;;367        vu16 temp;
;;;368        
;;;369        sLCD_OpenWindow(x, y, x, y);
000004  f8bd3008          LDRH     r3,[sp,#8]
000008  f8bd2004          LDRH     r2,[sp,#4]
00000c  f8bd1008          LDRH     r1,[sp,#8]
000010  f8bd0004          LDRH     r0,[sp,#4]
000014  f7fffffe          BL       sLCD_OpenWindow
;;;370    
;;;371        sLCD_WR_REG(0x2e);
000018  202e              MOVS     r0,#0x2e
00001a  f7fffffe          BL       sLCD_WR_REG
;;;372        temp = sLCD_Read_Data();
00001e  f7fffffe          BL       sLCD_Read_Data
000022  9000              STR      r0,[sp,#0]
;;;373        
;;;374    	return temp;
000024  f8bd0000          LDRH     r0,[sp,#0]
;;;375    }
000028  bd0e              POP      {r1-r3,pc}
;;;376    
                          ENDP


                          AREA ||i.LCD_Initializtion||, CODE, READONLY, ALIGN=1

                  LCD_Initializtion PROC
;;;344    
;;;345    void LCD_Initializtion(void)
000000  b510              PUSH     {r4,lr}
;;;346    {   
;;;347        sLCD_GPIO_Config();
000002  f7fffffe          BL       sLCD_GPIO_Config
;;;348        sLCD_FSMC_Config();
000006  f7fffffe          BL       sLCD_FSMC_Config
;;;349        NOP;
00000a  bf00              NOP      
;;;350    		NOP;
00000c  bf00              NOP      
;;;351    		NOP;NOP;
00000e  bf00              NOP      
000010  bf00              NOP      
;;;352    		NOP;
000012  bf00              NOP      
;;;353    		NOP;
000014  bf00              NOP      
;;;354    		NOP;
000016  bf00              NOP      
;;;355        sLCD_Init();
000018  f7fffffe          BL       sLCD_Init
;;;356    }
00001c  bd10              POP      {r4,pc}
;;;357    
                          ENDP


                          AREA ||i.LCD_SetPoint||, CODE, READONLY, ALIGN=1

                  LCD_SetPoint PROC
;;;357    
;;;358    void LCD_SetPoint(vu16 x,vu16 y,vu16 c)
000000  b507              PUSH     {r0-r2,lr}
;;;359    {
;;;360        sLCD_OpenWindow(x, y, x, y);
000002  f8bd3004          LDRH     r3,[sp,#4]
000006  f8bd2000          LDRH     r2,[sp,#0]
00000a  f8bd1004          LDRH     r1,[sp,#4]
00000e  f8bd0000          LDRH     r0,[sp,#0]
000012  f7fffffe          BL       sLCD_OpenWindow
;;;361        sLCD_WR_REG(0x2c);
000016  202c              MOVS     r0,#0x2c
000018  f7fffffe          BL       sLCD_WR_REG
;;;362        sLCD_WR_Data(c);
00001c  f8bd0008          LDRH     r0,[sp,#8]
000020  f7fffffe          BL       sLCD_WR_Data
;;;363    }
000024  bd0e              POP      {r1-r3,pc}
;;;364    
                          ENDP


                          AREA ||i.sLCD_BGR2RGB||, CODE, READONLY, ALIGN=1

                  sLCD_BGR2RGB PROC
;;;62     
;;;63     vu16 sLCD_BGR2RGB(vu16 c)
000000  b501              PUSH     {r0,lr}
;;;64     {
000002  b084              SUB      sp,sp,#0x10
;;;65       vu16  r, g, b, rgb;
;;;66     
;;;67       b = (c>>0)  & 0x1f;
000004  f8bd0010          LDRH     r0,[sp,#0x10]
000008  f000001f          AND      r0,r0,#0x1f
00000c  9001              STR      r0,[sp,#4]
;;;68       g = (c>>5)  & 0x3f;
00000e  f8bd0010          LDRH     r0,[sp,#0x10]
000012  f3c01045          UBFX     r0,r0,#5,#6
000016  9002              STR      r0,[sp,#8]
;;;69       r = (c>>11) & 0x1f;
000018  f8bd0010          LDRH     r0,[sp,#0x10]
00001c  0ac0              LSRS     r0,r0,#11
00001e  9003              STR      r0,[sp,#0xc]
;;;70       
;;;71       rgb =  (b<<11) + (g<<5) + (r<<0);
000020  f8bd0004          LDRH     r0,[sp,#4]
000024  02c0              LSLS     r0,r0,#11
000026  f8bd1008          LDRH     r1,[sp,#8]
00002a  eb001041          ADD      r0,r0,r1,LSL #5
00002e  f8bd100c          LDRH     r1,[sp,#0xc]
000032  4408              ADD      r0,r0,r1
000034  b280              UXTH     r0,r0
000036  9000              STR      r0,[sp,#0]
;;;72     
;;;73       return( rgb );
000038  f8bd0000          LDRH     r0,[sp,#0]
;;;74     }
00003c  b005              ADD      sp,sp,#0x14
00003e  bd00              POP      {pc}
;;;75     
                          ENDP


                          AREA ||i.sLCD_Clear||, CODE, READONLY, ALIGN=2

                  sLCD_Clear PROC
;;;205    
;;;206    void sLCD_Clear(u16 color)
000000  b570              PUSH     {r4-r6,lr}
;;;207    {
000002  4605              MOV      r5,r0
;;;208        unsigned int l=480 ,w;
000004  f44f76f0          MOV      r6,#0x1e0
;;;209        /*
;;;210    	sLCD_WR_REG(0x002A);	
;;;211    	sLCD_WR_Data(0);	    
;;;212    	sLCD_WR_Data(0);
;;;213    	sLCD_WR_Data(HDP>>8);	    
;;;214    	sLCD_WR_Data(HDP&0x00ff);
;;;215        sLCD_WR_REG(0x002b);	
;;;216    	sLCD_WR_Data(0);	    
;;;217    	sLCD_WR_Data(0);
;;;218    	sLCD_WR_Data(VDP>>8);	    
;;;219    	sLCD_WR_Data(VDP&0x00ff);
;;;220    	*/
;;;221    	sLCD_OpenWindow(0, 0, HDP, VDP);
000008  480c              LDR      r0,|L7.60|
00000a  6803              LDR      r3,[r0,#0]  ; VDP
00000c  480c              LDR      r0,|L7.64|
00000e  6802              LDR      r2,[r0,#0]  ; HDP
000010  2100              MOVS     r1,#0
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       sLCD_OpenWindow
;;;222    	sLCD_WR_REG(0x002c);
000018  202c              MOVS     r0,#0x2c
00001a  f7fffffe          BL       sLCD_WR_REG
;;;223        
;;;224    	while(l--)
00001e  e008              B        |L7.50|
                  |L7.32|
;;;225    	{
;;;226    	    for(w=0;w<272;w++)
000020  2400              MOVS     r4,#0
000022  e003              B        |L7.44|
                  |L7.36|
;;;227    		{    
;;;228    			sLCD_WR_Data(color);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       sLCD_WR_Data
00002a  1c64              ADDS     r4,r4,#1              ;226
                  |L7.44|
00002c  f5b47f88          CMP      r4,#0x110             ;226
000030  d3f8              BCC      |L7.36|
                  |L7.50|
000032  1e30              SUBS     r0,r6,#0              ;224
000034  f1a60601          SUB      r6,r6,#1              ;224
000038  d1f2              BNE      |L7.32|
;;;229    		//  sLCD_WR_Data(color);
;;;230    		 // sLCD_WR_Data(color);
;;;231    		}
;;;232    	}
;;;233    }
00003a  bd70              POP      {r4-r6,pc}
;;;234    
                          ENDP

                  |L7.60|
                          DCD      VDP
                  |L7.64|
                          DCD      HDP

                          AREA ||i.sLCD_FSMC_Config||, CODE, READONLY, ALIGN=1

                  sLCD_FSMC_Config PROC
;;;160    
;;;161     void sLCD_FSMC_Config(void)
000000  b500              PUSH     {lr}
;;;162    {		
000002  b097              SUB      sp,sp,#0x5c
;;;163    	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;164    	FSMC_NORSRAMTimingInitTypeDef  FSMC_NORSRAMTimingInitStructure;
;;;165    
;;;166    	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC,ENABLE);//寮FSMC堕
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;167    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;168    
;;;169    	FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 8;
00000c  2008              MOVS     r0,#8
00000e  9001              STR      r0,[sp,#4]
;;;170    	FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;171    	FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 18;
000014  2012              MOVS     r0,#0x12
000016  9003              STR      r0,[sp,#0xc]
;;;172    	FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0x00;
000018  2000              MOVS     r0,#0
00001a  9004              STR      r0,[sp,#0x10]
;;;173    	FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0x00;
00001c  9005              STR      r0,[sp,#0x14]
;;;174    	FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0x00;
00001e  9006              STR      r0,[sp,#0x18]
;;;175    	FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_A;
000020  9007              STR      r0,[sp,#0x1c]
;;;176    
;;;177    	/*
;;;178    	 LCD configured as follow:
;;;179    	    - Data/Address MUX = Disable
;;;180    	    - Memory Type = SRAM
;;;181    	    - Data Width = 16bit
;;;182    	    - Write Operation = Enable
;;;183    	    - Extended Mode = Enable
;;;184    	    - Asynchronous Wait = Disable
;;;185    	*/
;;;186    	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM1;//  
000022  9008              STR      r0,[sp,#0x20]
;;;187      FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable; // 
000024  9009              STR      r0,[sp,#0x24]
;;;188      FSMC_NORSRAMInitStructure.FSMC_MemoryType =FSMC_MemoryType_SRAM;// FSMC_MemoryType_SRAM;  //SRAM   
000026  900a              STR      r0,[sp,#0x28]
;;;189      FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;//16BIT版
000028  2010              MOVS     r0,#0x10
00002a  900b              STR      r0,[sp,#0x2c]
;;;190      FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode =FSMC_BurstAccessMode_Disable;// FSMC_BurstAccessMode_Disable; 
00002c  2000              MOVS     r0,#0
00002e  900c              STR      r0,[sp,#0x30]
;;;191      FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000030  900e              STR      r0,[sp,#0x38]
;;;192    	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait=FSMC_AsynchronousWait_Disable; 
000032  900d              STR      r0,[sp,#0x34]
;;;193      FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;   
000034  900f              STR      r0,[sp,#0x3c]
;;;194      FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;  
000036  9010              STR      r0,[sp,#0x40]
;;;195      FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;	// 
000038  f44f5080          MOV      r0,#0x1000
00003c  9011              STR      r0,[sp,#0x44]
;;;196      FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;   
00003e  2000              MOVS     r0,#0
000040  9012              STR      r0,[sp,#0x48]
;;;197      FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Enable; //
000042  f44f4080          MOV      r0,#0x4000
000046  9013              STR      r0,[sp,#0x4c]
;;;198      FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable; 
000048  2000              MOVS     r0,#0
00004a  9014              STR      r0,[sp,#0x50]
;;;199    
;;;200      FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);  //
00004c  a808              ADD      r0,sp,#0x20
00004e  f7fffffe          BL       FSMC_NORSRAMInit
;;;201    
;;;202      FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM1, ENABLE);  //
000052  2101              MOVS     r1,#1
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       FSMC_NORSRAMCmd
;;;203    }
00005a  b017              ADD      sp,sp,#0x5c
00005c  bd00              POP      {pc}
;;;204    
                          ENDP


                          AREA ||i.sLCD_GPIO_Config||, CODE, READONLY, ALIGN=2

                  sLCD_GPIO_Config PROC
;;;99     }
;;;100    void sLCD_GPIO_Config(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;101    {
;;;102        GPIO_InitTypeDef GPIO_InitStructure;//
;;;103        
;;;104    		GPIO_PinAFConfig(GPIOD,GPIO_PinSource7,GPIO_AF_FSMC);
000002  220c              MOVS     r2,#0xc
000004  2107              MOVS     r1,#7
000006  484f              LDR      r0,|L9.324|
000008  f7fffffe          BL       GPIO_PinAFConfig
;;;105    		GPIO_PinAFConfig(GPIOD,GPIO_PinSource11,GPIO_AF_FSMC);
00000c  220c              MOVS     r2,#0xc
00000e  210b              MOVS     r1,#0xb
000010  484c              LDR      r0,|L9.324|
000012  f7fffffe          BL       GPIO_PinAFConfig
;;;106    	
;;;107    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
000016  220c              MOVS     r2,#0xc
000018  2100              MOVS     r1,#0
00001a  484a              LDR      r0,|L9.324|
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;108    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
000020  220c              MOVS     r2,#0xc
000022  2101              MOVS     r1,#1
000024  4847              LDR      r0,|L9.324|
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;109    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
00002a  220c              MOVS     r2,#0xc
00002c  2104              MOVS     r1,#4
00002e  4845              LDR      r0,|L9.324|
000030  f7fffffe          BL       GPIO_PinAFConfig
;;;110    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
000034  220c              MOVS     r2,#0xc
000036  2105              MOVS     r1,#5
000038  4842              LDR      r0,|L9.324|
00003a  f7fffffe          BL       GPIO_PinAFConfig
;;;111    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
00003e  220c              MOVS     r2,#0xc
000040  2108              MOVS     r1,#8
000042  4840              LDR      r0,|L9.324|
000044  f7fffffe          BL       GPIO_PinAFConfig
;;;112    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
000048  220c              MOVS     r2,#0xc
00004a  2109              MOVS     r1,#9
00004c  483d              LDR      r0,|L9.324|
00004e  f7fffffe          BL       GPIO_PinAFConfig
;;;113    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
000052  220c              MOVS     r2,#0xc
000054  210a              MOVS     r1,#0xa
000056  483b              LDR      r0,|L9.324|
000058  f7fffffe          BL       GPIO_PinAFConfig
;;;114    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
00005c  220c              MOVS     r2,#0xc
00005e  210e              MOVS     r1,#0xe
000060  4838              LDR      r0,|L9.324|
000062  f7fffffe          BL       GPIO_PinAFConfig
;;;115    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
000066  220c              MOVS     r2,#0xc
000068  210f              MOVS     r1,#0xf
00006a  4836              LDR      r0,|L9.324|
00006c  f7fffffe          BL       GPIO_PinAFConfig
;;;116    	
;;;117    
;;;118    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);
000070  220c              MOVS     r2,#0xc
000072  2107              MOVS     r1,#7
000074  4834              LDR      r0,|L9.328|
000076  f7fffffe          BL       GPIO_PinAFConfig
;;;119    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);
00007a  220c              MOVS     r2,#0xc
00007c  2108              MOVS     r1,#8
00007e  4832              LDR      r0,|L9.328|
000080  f7fffffe          BL       GPIO_PinAFConfig
;;;120    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);
000084  220c              MOVS     r2,#0xc
000086  2109              MOVS     r1,#9
000088  482f              LDR      r0,|L9.328|
00008a  f7fffffe          BL       GPIO_PinAFConfig
;;;121    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FSMC);
00008e  220c              MOVS     r2,#0xc
000090  210a              MOVS     r1,#0xa
000092  482d              LDR      r0,|L9.328|
000094  f7fffffe          BL       GPIO_PinAFConfig
;;;122    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FSMC);
000098  220c              MOVS     r2,#0xc
00009a  210b              MOVS     r1,#0xb
00009c  482a              LDR      r0,|L9.328|
00009e  f7fffffe          BL       GPIO_PinAFConfig
;;;123    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FSMC);
0000a2  220c              MOVS     r2,#0xc
0000a4  4611              MOV      r1,r2
0000a6  4828              LDR      r0,|L9.328|
0000a8  f7fffffe          BL       GPIO_PinAFConfig
;;;124    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FSMC);
0000ac  220c              MOVS     r2,#0xc
0000ae  210d              MOVS     r1,#0xd
0000b0  4825              LDR      r0,|L9.328|
0000b2  f7fffffe          BL       GPIO_PinAFConfig
;;;125    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FSMC);
0000b6  220c              MOVS     r2,#0xc
0000b8  210e              MOVS     r1,#0xe
0000ba  4823              LDR      r0,|L9.328|
0000bc  f7fffffe          BL       GPIO_PinAFConfig
;;;126    		GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FSMC);
0000c0  220c              MOVS     r2,#0xc
0000c2  210f              MOVS     r1,#0xf
0000c4  4820              LDR      r0,|L9.328|
0000c6  f7fffffe          BL       GPIO_PinAFConfig
;;;127        /*
;;;128            FSMC Data 管脚初始化 D0~D15
;;;129        */
;;;130        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14 | GPIO_Pin_15 | GPIO_Pin_8 | 
0000ca  f24c7003          MOV      r0,#0xc703
0000ce  9000              STR      r0,[sp,#0]
;;;131                                        GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_0 |
;;;132                                        GPIO_Pin_1 ;
;;;133        GPIO_InitStructure.GPIO_Speed =GPIO_Speed_100MHz;
0000d0  2003              MOVS     r0,#3
0000d2  f88d0005          STRB     r0,[sp,#5]
;;;134        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000d6  2002              MOVS     r0,#2
0000d8  f88d0004          STRB     r0,[sp,#4]
;;;135    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
0000dc  2000              MOVS     r0,#0
0000de  f88d0006          STRB     r0,[sp,#6]
;;;136    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
0000e2  f88d0007          STRB     r0,[sp,#7]
;;;137        GPIO_Init(GPIOD, &GPIO_InitStructure);
0000e6  4669              MOV      r1,sp
0000e8  4816              LDR      r0,|L9.324|
0000ea  f7fffffe          BL       GPIO_Init
;;;138    
;;;139        GPIO_InitStructure.GPIO_Pin =    GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | 
0000ee  f64f7080          MOV      r0,#0xff80
0000f2  9000              STR      r0,[sp,#0]
;;;140                                        GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 |
;;;141                                        GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15 ;
;;;142    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
0000f4  2003              MOVS     r0,#3
0000f6  f88d0005          STRB     r0,[sp,#5]
;;;143        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000fa  2002              MOVS     r0,#2
0000fc  f88d0004          STRB     r0,[sp,#4]
;;;144    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
000100  2000              MOVS     r0,#0
000102  f88d0006          STRB     r0,[sp,#6]
;;;145    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000106  f88d0007          STRB     r0,[sp,#7]
;;;146        GPIO_Init(GPIOE, &GPIO_InitStructure);
00010a  4669              MOV      r1,sp
00010c  480e              LDR      r0,|L9.328|
00010e  f7fffffe          BL       GPIO_Init
;;;147    
;;;148        /*
;;;149            CS      RD      RW      RS
;;;150        */
;;;151        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_4 | GPIO_Pin_5 |
000112  f44f600b          MOV      r0,#0x8b0
000116  9000              STR      r0,[sp,#0]
;;;152                                        GPIO_Pin_11;
;;;153    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000118  2003              MOVS     r0,#3
00011a  f88d0005          STRB     r0,[sp,#5]
;;;154        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00011e  2002              MOVS     r0,#2
000120  f88d0004          STRB     r0,[sp,#4]
;;;155    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000124  2000              MOVS     r0,#0
000126  f88d0006          STRB     r0,[sp,#6]
;;;156    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
00012a  f88d0007          STRB     r0,[sp,#7]
;;;157        GPIO_Init(GPIOD, &GPIO_InitStructure);
00012e  4669              MOV      r1,sp
000130  4804              LDR      r0,|L9.324|
000132  f7fffffe          BL       GPIO_Init
;;;158    		GPIO_ResetBits(GPIOD,GPIO_Pin_13);//RST_lcd
000136  f44f5100          MOV      r1,#0x2000
00013a  4802              LDR      r0,|L9.324|
00013c  f7fffffe          BL       GPIO_ResetBits
;;;159     }
000140  bd1c              POP      {r2-r4,pc}
;;;160    
                          ENDP

000142  0000              DCW      0x0000
                  |L9.324|
                          DCD      0x40020c00
                  |L9.328|
                          DCD      0x40021000

                          AREA ||i.sLCD_Init||, CODE, READONLY, ALIGN=2

                  sLCD_Init PROC
;;;234    
;;;235    static void sLCD_Init(void)
000000  b508              PUSH     {r3,lr}
;;;236    {
;;;237        vu16 DeviceCode;
;;;238        sLCD_WR_REG(0xa1);
000002  20a1              MOVS     r0,#0xa1
000004  f7fffffe          BL       sLCD_WR_REG
;;;239        DeviceCode = sLCD_Read_Data();    
000008  f7fffffe          BL       sLCD_Read_Data
00000c  9000              STR      r0,[sp,#0]
;;;240        DeviceCode = sLCD_Read_Data();    
00000e  f7fffffe          BL       sLCD_Read_Data
000012  9000              STR      r0,[sp,#0]
;;;241        DeviceCode = sLCD_Read_Data();    
000014  f7fffffe          BL       sLCD_Read_Data
000018  9000              STR      r0,[sp,#0]
;;;242        DeviceCode = sLCD_Read_Data();    
00001a  f7fffffe          BL       sLCD_Read_Data
00001e  9000              STR      r0,[sp,#0]
;;;243        DeviceCode = sLCD_Read_Data();    
000020  f7fffffe          BL       sLCD_Read_Data
000024  9000              STR      r0,[sp,#0]
;;;244        DeviceCode = DeviceCode;
000026  f8bd0000          LDRH     r0,[sp,#0]
00002a  9000              STR      r0,[sp,#0]
;;;245        //  Step 2: PLL设置
;;;246        sLCD_WR_REG(0x00E2);     //0XE2是设置PLL 的寄存器。
00002c  20e2              MOVS     r0,#0xe2
00002e  f7fffffe          BL       sLCD_WR_REG
;;;247        sLCD_WR_Data(0x001D);// (0x002C);//   //设置倍频数 M   0x21D for 10M
000032  201d              MOVS     r0,#0x1d
000034  f7fffffe          BL       sLCD_WR_Data
;;;248        sLCD_WR_Data(0x0002);    //设置分频数 N
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       sLCD_WR_Data
;;;249        sLCD_WR_Data(0x0004);    //使能MN   PLL = INCLK*(M+1) / (N+1)  PLL 倍频到120M PLL=8*44/3=120M
00003e  2004              MOVS     r0,#4
000040  f7fffffe          BL       sLCD_WR_Data
;;;250    
;;;251        sLCD_WR_REG(0x00E0);     //0XE0是PLL使能寄存器
000044  20e0              MOVS     r0,#0xe0
000046  f7fffffe          BL       sLCD_WR_REG
;;;252        sLCD_WR_Data(0x0001);    //先开启PLL
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       sLCD_WR_Data
;;;253        Delay_ms(10);
000050  200a              MOVS     r0,#0xa
000052  f7fffffe          BL       Delay_ms
;;;254    	
;;;255        sLCD_WR_REG(0x00E0);     //还要一次
000056  20e0              MOVS     r0,#0xe0
000058  f7fffffe          BL       sLCD_WR_REG
;;;256        sLCD_WR_Data(0x0003);    // 使用 PLL作为时钟
00005c  2003              MOVS     r0,#3
00005e  f7fffffe          BL       sLCD_WR_Data
;;;257        Delay_ms(10);
000062  200a              MOVS     r0,#0xa
000064  f7fffffe          BL       Delay_ms
;;;258        sLCD_WR_REG(0x0001);     // 软件复位
000068  2001              MOVS     r0,#1
00006a  f7fffffe          BL       sLCD_WR_REG
;;;259        Delay_ms(10);
00006e  200a              MOVS     r0,#0xa
000070  f7fffffe          BL       Delay_ms
;;;260    
;;;261        //step 3 : 设置PCLK，也就是像素时钟
;;;262        sLCD_WR_REG(0xE6);        //嗯，没错 0XE6是设置像素时钟的寄存器  
000074  20e6              MOVS     r0,#0xe6
000076  f7fffffe          BL       sLCD_WR_REG
;;;263        sLCD_WR_Data(0x0001);//(0x01);//       //我的屏幕是4.3寸，这个频率就可以了，如果屏幕比较大，有闪烁的话，可以再加大
00007a  2001              MOVS     r0,#1
00007c  f7fffffe          BL       sLCD_WR_Data
;;;264        sLCD_WR_Data(0x0093);//(0x93);//
000080  2093              MOVS     r0,#0x93
000082  f7fffffe          BL       sLCD_WR_Data
;;;265        sLCD_WR_Data(0x0032);// ( 0xE0);//     //忘记说了，寄存器指令都是8位传输的，这里的像素时钟需要3个字节来设置，高位在前
000086  2032              MOVS     r0,#0x32
000088  f7fffffe          BL       sLCD_WR_Data
;;;266    
;;;267        //step 4 : 设置LCD的显示模式，需要根据屏幕大小和LCD的电路控制方法相匹配，
;;;268        sLCD_WR_REG(0x00B0);        //设置LCD显示模式及分辨率
00008c  20b0              MOVS     r0,#0xb0
00008e  f7fffffe          BL       sLCD_WR_REG
;;;269        sLCD_WR_Data(0x0020);//(0x0018);        // 使能FRC 0X0018 18bit LCD控制 
000092  2020              MOVS     r0,#0x20
000094  f7fffffe          BL       sLCD_WR_Data
;;;270        sLCD_WR_Data(0x0000);     //TFT模式
000098  2000              MOVS     r0,#0
00009a  f7fffffe          BL       sLCD_WR_Data
;;;271        sLCD_WR_Data((HDP>>8)&0X00FF);  //Set HDP         水平大小
00009e  483e              LDR      r0,|L10.408|
0000a0  6800              LDR      r0,[r0,#0]  ; HDP
0000a2  f3c02007          UBFX     r0,r0,#8,#8
0000a6  f7fffffe          BL       sLCD_WR_Data
;;;272        sLCD_WR_Data(HDP&0X00FF);             //双字节，高位在前
0000aa  493b              LDR      r1,|L10.408|
0000ac  6809              LDR      r1,[r1,#0]  ; HDP
0000ae  b2c8              UXTB     r0,r1
0000b0  f7fffffe          BL       sLCD_WR_Data
;;;273        sLCD_WR_Data((VDP>>8)&0X00FF);  //Set VDP         垂直尺寸
0000b4  4839              LDR      r0,|L10.412|
0000b6  6800              LDR      r0,[r0,#0]  ; VDP
0000b8  f3c02007          UBFX     r0,r0,#8,#8
0000bc  f7fffffe          BL       sLCD_WR_Data
;;;274        sLCD_WR_Data(VDP&0X00FF);
0000c0  4936              LDR      r1,|L10.412|
0000c2  6809              LDR      r1,[r1,#0]  ; VDP
0000c4  b2c8              UXTB     r0,r1
0000c6  f7fffffe          BL       sLCD_WR_Data
;;;275        sLCD_WR_Data(0x0000);                        //RGB顺序串行TFT接口
0000ca  2000              MOVS     r0,#0
0000cc  f7fffffe          BL       sLCD_WR_Data
;;;276    
;;;277        sLCD_WR_REG(0x00B4);        //设置  水平显示时间参数
0000d0  20b4              MOVS     r0,#0xb4
0000d2  f7fffffe          BL       sLCD_WR_REG
;;;278        sLCD_WR_Data((HT>>8)&0X00FF);  //Set HT 水平总周期
0000d6  4832              LDR      r0,|L10.416|
0000d8  6800              LDR      r0,[r0,#0]  ; HT
0000da  f3c02007          UBFX     r0,r0,#8,#8
0000de  f7fffffe          BL       sLCD_WR_Data
;;;279        sLCD_WR_Data(HT&0X00FF);
0000e2  492f              LDR      r1,|L10.416|
0000e4  6809              LDR      r1,[r1,#0]  ; HT
0000e6  b2c8              UXTB     r0,r1
0000e8  f7fffffe          BL       sLCD_WR_Data
;;;280        sLCD_WR_Data((HPS>>8)&0X00FF);  //Set HPS 水平同步脉冲开始位
0000ec  482d              LDR      r0,|L10.420|
0000ee  6800              LDR      r0,[r0,#0]  ; HPS
0000f0  f3c02007          UBFX     r0,r0,#8,#8
0000f4  f7fffffe          BL       sLCD_WR_Data
;;;281        sLCD_WR_Data(HPS&0X00FF);
0000f8  492a              LDR      r1,|L10.420|
0000fa  6809              LDR      r1,[r1,#0]  ; HPS
0000fc  b2c8              UXTB     r0,r1
0000fe  f7fffffe          BL       sLCD_WR_Data
;;;282        sLCD_WR_Data(HPW);                           //Set HPW 水平同步脉冲宽度
000102  4829              LDR      r0,|L10.424|
000104  7800              LDRB     r0,[r0,#0]  ; HPW
000106  f7fffffe          BL       sLCD_WR_Data
;;;283        sLCD_WR_Data((LPS>>8)&0X00FF);  //Set LPS 显示开始位
00010a  4828              LDR      r0,|L10.428|
00010c  6800              LDR      r0,[r0,#0]  ; LPS
00010e  f3c02007          UBFX     r0,r0,#8,#8
000112  f7fffffe          BL       sLCD_WR_Data
;;;284        sLCD_WR_Data(LPS&0X00FF);
000116  4925              LDR      r1,|L10.428|
000118  6809              LDR      r1,[r1,#0]  ; LPS
00011a  b2c8              UXTB     r0,r1
00011c  f7fffffe          BL       sLCD_WR_Data
;;;285        sLCD_WR_Data(0x0000);         //TFT mode下，如此设置
000120  2000              MOVS     r0,#0
000122  f7fffffe          BL       sLCD_WR_Data
;;;286    
;;;287        sLCD_WR_REG(0x00B6);        //设置        垂直显示时间参数
000126  20b6              MOVS     r0,#0xb6
000128  f7fffffe          BL       sLCD_WR_REG
;;;288        sLCD_WR_Data((VT>>8)&0X00FF);   //Set VT 垂直总周期
00012c  4820              LDR      r0,|L10.432|
00012e  6800              LDR      r0,[r0,#0]  ; VT
000130  f3c02007          UBFX     r0,r0,#8,#8
000134  f7fffffe          BL       sLCD_WR_Data
;;;289        sLCD_WR_Data(VT&0X00FF);
000138  491d              LDR      r1,|L10.432|
00013a  6809              LDR      r1,[r1,#0]  ; VT
00013c  b2c8              UXTB     r0,r1
00013e  f7fffffe          BL       sLCD_WR_Data
;;;290        sLCD_WR_Data((VPS>>8)&0X00FF);  //Set VPS 垂直同步脉冲开始位
000142  481c              LDR      r0,|L10.436|
000144  6800              LDR      r0,[r0,#0]  ; VPS
000146  f3c02007          UBFX     r0,r0,#8,#8
00014a  f7fffffe          BL       sLCD_WR_Data
;;;291        sLCD_WR_Data(VPS&0X00FF);
00014e  4919              LDR      r1,|L10.436|
000150  6809              LDR      r1,[r1,#0]  ; VPS
000152  b2c8              UXTB     r0,r1
000154  f7fffffe          BL       sLCD_WR_Data
;;;292        sLCD_WR_Data(VPW);                           //Set VPW垂直同步脉冲宽度
000158  4817              LDR      r0,|L10.440|
00015a  7800              LDRB     r0,[r0,#0]  ; VPW
00015c  f7fffffe          BL       sLCD_WR_Data
;;;293        sLCD_WR_Data((FPS>>8)&0X00FF);  //Set FPS  显示开始位置
000160  4816              LDR      r0,|L10.444|
000162  6800              LDR      r0,[r0,#0]  ; FPS
000164  f3c02007          UBFX     r0,r0,#8,#8
000168  f7fffffe          BL       sLCD_WR_Data
;;;294        sLCD_WR_Data(FPS&0X00FF);
00016c  4913              LDR      r1,|L10.444|
00016e  6809              LDR      r1,[r1,#0]  ; FPS
000170  b2c8              UXTB     r0,r1
000172  f7fffffe          BL       sLCD_WR_Data
;;;295        
;;;296        sLCD_WR_REG(0X0036);    //设置从主机读取指令顺序，可以省略，上电默认为0
000176  2036              MOVS     r0,#0x36
000178  f7fffffe          BL       sLCD_WR_REG
;;;297        sLCD_WR_Data(0X0000);
00017c  2000              MOVS     r0,#0
00017e  f7fffffe          BL       sLCD_WR_Data
;;;298        sLCD_WR_REG(0x00F0); //pixel data interface  设置像素数据接口为16位
000182  20f0              MOVS     r0,#0xf0
000184  f7fffffe          BL       sLCD_WR_REG
;;;299        sLCD_WR_Data(0x0003); //03为 565 的16位通讯。
000188  2003              MOVS     r0,#3
00018a  f7fffffe          BL       sLCD_WR_Data
;;;300        
;;;301        //step 5 : 可选。设置图形后处理。
;;;302        //sLCD_WR_REG(0x0021);        //进入图形颜色翻转模式 
;;;303    
;;;304        //sLCD_WR_REG(0x00BC);//设置图像后处理
;;;305        //sLCD_WR_Data(0x005A);//(0x0080);//对比度
;;;306        //sLCD_WR_Data(0x0064);//(0x0080);//亮度
;;;307        //sLCD_WR_Data(0x005A);//(0x0080);//饱和度值  //
;;;308        //sLCD_WR_Data(0x0001);//处理机允许
;;;309    
;;;310        //sLCD_Clear(0Xffff);//刷成白色
;;;311        //sLCD_Clear(0x0000000);//黑色
;;;312        sLCD_WR_REG(0x0029); //display on
00018e  2029              MOVS     r0,#0x29
000190  f7fffffe          BL       sLCD_WR_REG
;;;313        
;;;314    //    // step 6 ，背光设置，也是屏幕亮起来的一步。
;;;315    //    sLCD_WR_REG(0x00BE); //set PWM控制
;;;316    //    sLCD_WR_Data(0x0006);        //PWM频率 = PLL / (256* 0x06) /256        
;;;317    //    sLCD_WR_Data(0x00ff); // PWM占空比设置 
;;;318    //    sLCD_WR_Data(0x09); //DBC 控制PWM 使能 
;;;319    //    sLCD_WR_Data(0xFF); //DBC手动亮度设置
;;;320    //    sLCD_WR_Data(0x00); //DBC 最小亮度设置 
;;;321    //    sLCD_WR_Data(0x00);
;;;322    //
;;;323    //    sLCD_WR_REG(0xD4); //设置每个等级的电源阀值
;;;324    //    //TH1 = display width * display height * 3 * 0.1 /16 
;;;325    //    //480*272 * 3 * 0.1 /16 =990H
;;;326    //    sLCD_WR_Data(0x00); // 
;;;327    //    sLCD_WR_Data(0x09); // 
;;;328    //    sLCD_WR_Data(0x90); // 
;;;329    //  
;;;330    //    //TH2 = display width * display height * 3 * 0.25 /16
;;;331    //    //480*272 * 3 * 0.25 /16 =17E8H
;;;332    //    sLCD_WR_Data(0x00); // 
;;;333    //    sLCD_WR_Data(0xE8); // 
;;;334    //
;;;335    //    //TH3 = display width * display height * 3 * 0.6 /16 
;;;336    //    //480*272 * 3 * 0.6 /16 =3960H
;;;337    //    sLCD_WR_Data(0x00); // 
;;;338    //    sLCD_WR_Data(0x39); // 
;;;339    //    sLCD_WR_Data(0x60); //
;;;340    //                 
;;;341    //    sLCD_WR_REG(0x00d0);//设置动态背光控制配置 
;;;342    //    sLCD_WR_Data(0x000d); 
;;;343    }
000194  bd08              POP      {r3,pc}
;;;344    
                          ENDP

000196  0000              DCW      0x0000
                  |L10.408|
                          DCD      HDP
                  |L10.412|
                          DCD      VDP
                  |L10.416|
                          DCD      ||HT||
                  |L10.420|
                          DCD      HPS
                  |L10.424|
                          DCD      HPW
                  |L10.428|
                          DCD      LPS
                  |L10.432|
                          DCD      ||VT||
                  |L10.436|
                          DCD      VPS
                  |L10.440|
                          DCD      VPW
                  |L10.444|
                          DCD      ||FPS||

                          AREA ||i.sLCD_OpenWindow||, CODE, READONLY, ALIGN=1

                  sLCD_OpenWindow PROC
;;;46     
;;;47     void sLCD_OpenWindow(vu32 x1, vu32 y1, vu32 x2, vu32 y2)
000000  b50f              PUSH     {r0-r3,lr}
;;;48     {
;;;49     	sLCD_WR_REG(0x002a);
000002  202a              MOVS     r0,#0x2a
000004  f7fffffe          BL       sLCD_WR_REG
;;;50     	sLCD_WR_Data(x1>>8);
000008  9900              LDR      r1,[sp,#0]
00000a  0a08              LSRS     r0,r1,#8
00000c  f7fffffe          BL       sLCD_WR_Data
;;;51     	sLCD_WR_Data(x1);
000010  9800              LDR      r0,[sp,#0]
000012  f7fffffe          BL       sLCD_WR_Data
;;;52     	sLCD_WR_Data(x2>>8);
000016  9902              LDR      r1,[sp,#8]
000018  0a08              LSRS     r0,r1,#8
00001a  f7fffffe          BL       sLCD_WR_Data
;;;53     	sLCD_WR_Data(x2);
00001e  9802              LDR      r0,[sp,#8]
000020  f7fffffe          BL       sLCD_WR_Data
;;;54     
;;;55     	sLCD_WR_REG(0x002b);
000024  202b              MOVS     r0,#0x2b
000026  f7fffffe          BL       sLCD_WR_REG
;;;56     	sLCD_WR_Data(y1>>8);
00002a  9901              LDR      r1,[sp,#4]
00002c  0a08              LSRS     r0,r1,#8
00002e  f7fffffe          BL       sLCD_WR_Data
;;;57     	sLCD_WR_Data(y1);
000032  9801              LDR      r0,[sp,#4]
000034  f7fffffe          BL       sLCD_WR_Data
;;;58     	sLCD_WR_Data(y2>>8);
000038  9903              LDR      r1,[sp,#0xc]
00003a  0a08              LSRS     r0,r1,#8
00003c  f7fffffe          BL       sLCD_WR_Data
;;;59     	sLCD_WR_Data(y2);
000040  9803              LDR      r0,[sp,#0xc]
000042  f7fffffe          BL       sLCD_WR_Data
;;;60     	sLCD_WR_REG(0x002C);
000046  202c              MOVS     r0,#0x2c
000048  f7fffffe          BL       sLCD_WR_REG
;;;61     }
00004c  bd0f              POP      {r0-r3,pc}
;;;62     
                          ENDP


                          AREA ||i.sLCD_Read_Data||, CODE, READONLY, ALIGN=2

                  sLCD_Read_Data PROC
;;;41     
;;;42     vu16 sLCD_Read_Data(void)
000000  4801              LDR      r0,|L12.8|
;;;43     {
;;;44        return  *(__IO u16 *) (Bank1_LCD_D);
000002  8800              LDRH     r0,[r0,#0]
;;;45     }
000004  4770              BX       lr
;;;46     
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x60020000

                          AREA ||i.sLCD_WR_Data||, CODE, READONLY, ALIGN=2

                  sLCD_WR_Data PROC
;;;36     
;;;37     void sLCD_WR_Data(unsigned int val)
000000  4a01              LDR      r2,|L13.8|
;;;38     {   
;;;39     	*(__IO u16 *) (Bank1_LCD_D)= val; 	
000002  8010              STRH     r0,[r2,#0]
;;;40     }
000004  4770              BX       lr
;;;41     
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x60020000

                          AREA ||i.sLCD_WR_REG||, CODE, READONLY, ALIGN=1

                  sLCD_WR_REG PROC
;;;30     
;;;31     void sLCD_WR_REG(unsigned int index)
000000  f04f42c0          MOV      r2,#0x60000000
;;;32     {
;;;33     	*(__IO u16 *) (Bank1_LCD_C)= index;
000004  8010              STRH     r0,[r2,#0]
;;;34     
;;;35     }
000006  4770              BX       lr
;;;36     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  HDP
                          DCD      0x000001df
                  ||HT||
                          DCD      0x00000213
                  HPS
                          DCD      0x0000002b
                  LPS
                          DCD      0x00000008
                  HPW
000010  0a000000          DCB      0x0a,0x00,0x00,0x00
                  VDP
                          DCD      0x0000010f
                  ||VT||
                          DCD      0x00000120
                  VPS
                          DCD      0x0000000c
                  ||FPS||
                          DCD      0x00000004
                  VPW
000024  0a                DCB      0x0a

;*** Start embedded assembler ***

#line 1 "..\\drive\\ssd1963.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_ssd1963_c_HDP____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_ssd1963_c_HDP____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_ssd1963_c_HDP____REVSH|
#line 144
|__asm___9_ssd1963_c_HDP____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
